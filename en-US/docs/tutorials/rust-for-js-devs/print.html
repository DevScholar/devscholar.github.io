<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for JavaScript Developers</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="license.html">License</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/scalar-types.html"><strong aria-hidden="true">2.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="language/strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="language/structured-types.html"><strong aria-hidden="true">2.3.</strong> Structured Types</a></li><li class="chapter-item expanded "><a href="language/custom-types/index.html"><strong aria-hidden="true">2.4.</strong> Custom Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/custom-types/classes.html"><strong aria-hidden="true">2.4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="language/custom-types/records.html"><strong aria-hidden="true">2.4.2.</strong> Records</a></li><li class="chapter-item expanded "><a href="language/custom-types/structs.html"><strong aria-hidden="true">2.4.3.</strong> Structures</a></li><li class="chapter-item expanded "><a href="language/custom-types/interfaces.html"><strong aria-hidden="true">2.4.4.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="language/custom-types/enums.html"><strong aria-hidden="true">2.4.5.</strong> Enumeration Types</a></li><li class="chapter-item expanded "><a href="language/custom-types/members.html"><strong aria-hidden="true">2.4.6.</strong> Members</a></li></ol></li><li class="chapter-item expanded "><a href="language/local-functions.html"><strong aria-hidden="true">2.5.</strong> Local Functions</a></li><li class="chapter-item expanded "><a href="language/lambda-and-closures.html"><strong aria-hidden="true">2.6.</strong> Lambda and Closures</a></li><li class="chapter-item expanded "><a href="language/variables.html"><strong aria-hidden="true">2.7.</strong> Variables</a></li><li class="chapter-item expanded "><a href="language/namespaces.html"><strong aria-hidden="true">2.8.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="language/equality.html"><strong aria-hidden="true">2.9.</strong> Equality</a></li><li class="chapter-item expanded "><a href="language/generics.html"><strong aria-hidden="true">2.10.</strong> Generics</a></li><li class="chapter-item expanded "><a href="language/polymorphism.html"><strong aria-hidden="true">2.11.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="language/inheritance.html"><strong aria-hidden="true">2.12.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="language/exception-handling.html"><strong aria-hidden="true">2.13.</strong> Exception Handling</a></li><li class="chapter-item expanded "><a href="language/nullability-and-optionality.html"><strong aria-hidden="true">2.14.</strong> Nullability and Optionality</a></li><li class="chapter-item expanded "><a href="language/discards.html"><strong aria-hidden="true">2.15.</strong> Discards</a></li><li class="chapter-item expanded "><a href="language/conversion-and-casting.html"><strong aria-hidden="true">2.16.</strong> Conversion and Casting</a></li><li class="chapter-item expanded "><a href="language/operator-overloading.html"><strong aria-hidden="true">2.17.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="language/documentation-comments.html"><strong aria-hidden="true">2.18.</strong> Documentation Comments</a></li></ol></li><li class="chapter-item expanded "><a href="memory-management/index.html"><strong aria-hidden="true">3.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="resource-management/index.html"><strong aria-hidden="true">4.</strong> Resource Management</a></li><li class="chapter-item expanded "><a href="threading/index.html"><strong aria-hidden="true">5.</strong> Threading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threading/synchronization.html"><strong aria-hidden="true">5.1.</strong> Synchronization</a></li><li class="chapter-item expanded "><a href="threading/producer-consumer.html"><strong aria-hidden="true">5.2.</strong> Producer-Consumer</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="benchmarking/index.html"><strong aria-hidden="true">7.</strong> Benchmarking</a></li><li class="chapter-item expanded "><a href="logging-and-tracing/index.html"><strong aria-hidden="true">8.</strong> Logging and Tracing</a></li><li class="chapter-item expanded "><a href="conditional-compilation/index.html"><strong aria-hidden="true">9.</strong> Conditional Compilation</a></li><li class="chapter-item expanded "><a href="environment-and-configuration/index.html"><strong aria-hidden="true">10.</strong> Environment and Configuration</a></li><li class="chapter-item expanded "><a href="linq/index.html"><strong aria-hidden="true">11.</strong> LINQ</a></li><li class="chapter-item expanded "><a href="meta-programming/index.html"><strong aria-hidden="true">12.</strong> Meta Programming</a></li><li class="chapter-item expanded "><a href="asynchronous-programming/index.html"><strong aria-hidden="true">13.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="project-structure/index.html"><strong aria-hidden="true">14.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="compilation-and-building/index.html"><strong aria-hidden="true">15.</strong> Compilation and Building</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for JavaScript Developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a (non-comprehensive) guide for JavaScript developers that are completely new to the Rust programming language. Some concepts and constructs translate fairly well between JavaScript and Rust, but which may be expressed differently, whereas others are a radical departure, like memory management. This guide provides a brief comparison and mapping of those constructs and concepts with concise examples.</p>
<p>The original authors[^authors] of this guide were themselves JavaScript developers who were completely new to Rust. <!--This guide is the compilation of the knowledge acquired by the authors writing Rust code over the course of several months. -->It is the guide the authors wish they had when they started on their Rust journey. That said, the authors would encourage you to read books and other material available on the Web to embrace Rust and its idioms rather than attempting to learn it exclusively through the lens of JavaScript. Meanwhile, this guide can help answers some question quickly, like: <em>Does Rust support inheritance, threading, asynchronous programming, etc.?</em>
Assumptions:</p>
<ul>
<li>Reader is a seasoned JavaScript developer.</li>
<li>Reader is completely new to Rust.</li>
</ul>
<p>Goals:</p>
<ul>
<li>Provide a brief comparison and mapping of various JavaScript topics to their counterparts in Rust.</li>
<li>Provide links to Rust reference, book and articles for further reading on topics.</li>
</ul>
<p>Non-goals:</p>
<ul>
<li>Discussion of design patterns and architectures.</li>
<li>Tutorial on the Rust language.</li>
<li>Reader is proficient in Rust after reading this guide.</li>
<li>While there are short examples that contrast JavaScript and Rust code for some topics, this guide is not meant to be a cookbook of coding recipes in the two languages.</li>
</ul>
<hr />
<!--
[^authors]: The original authors of this guide were (in alphabetical order):
[Atif Aziz], [Bastian Burger], [Daniele Antonio Maggio], [Dariusz Parys] and
[Patrick Schuler].

  [Atif Aziz]: https://github.com/atifaziz
  [Bastian Burger]: https://github.com/bastbu
  [Daniele Antonio Maggio]: https://github.com/danigian
  [Dariusz Parys]: https://github.com/dariuszparys
  [Patrick Schuler]: https://github.com/p-schuler
--><div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<blockquote>
MIT License
<p>Copyright (c) Contributors.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE</p>
</blockquote>
This book is adapted from Microsoft's [Rust for C#/.NET Developers](https://github.com/microsoft/rust-for-dotnet-devs).
<blockquote>
MIT License
<p>Copyright (c) Microsoft Corporation.
Portions Copyright (c) 2010 The Rust Project Developers</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>You are invited to contribute 💖 to this guide by opening issues and submitting pull requests!</p>
<p>Here are some ideas 💡 for how and where you can help most with contributions:</p>
<ul>
<li>
<p>Fix any spelling or grammatical mistakes you see as you read.</p>
</li>
<li>
<p>Fix technical inaccuracies.</p>
</li>
<li>
<p>Fix logical or compilation errors in code examples.</p>
</li>
<li>
<p>Improve the English, especially if it's your native tongue or you have excellent proficiency in the language.</p>
</li>
<li>
<p>Expand an explanation to provide more context or improve the clarity of some topic or concept.</p>
</li>
<li>
<p>Keep it fresh with changes in JavaScript and Rust. For example, if there is a change in JavaScript or Rust that brings the two languages closer together then some parts, including sample code, may need revision.</p>
</li>
</ul>
<p>If you're making a small to modest correction, such fixing a spelling error or a syntax error in a code example, then feel free to submit a pull request directly. For changes that may require a large effort on your part (and reviewers as a result), it is strongly recommended that you submit an issue and seek approval of the maintainers/editors before investing your time. It will avoid heartbreak 💔 if the pull request is rejected for various reasons.</p>
<p>Making quick contributions has been made super simple. If you see an error on a page and happen to be online, you can click edit icon 📝 in the corner of the page to edit the Markdown source of the content and submit a change.</p>
<h2 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h2>
<ul>
<li>
<p>Stick to the goals of this guide laid out in the <a href="introduction.html">introduction</a>; put another way, avoid the non-goals!</p>
</li>
<li>
<p>Prefer to keep text short and use short, concise and realistic code examples to illustrate a point.</p>
</li>
<li>
<p>As much as it is possible, always provide and compare examples in Rust and JavaScript.</p>
</li>
<li>
<p>Feel free to use latest JavaScript/Rust language features if it makes an example simpler, concise and alike across the two languages.</p>
</li>
<li>
<p>Avoid using community packages in JavaScript examples. Stick to the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">Global Objects</a> as much as possible. Since the <a href="https://doc.rust-lang.org/std/">Rust Standard Library</a> has a much smaller API surface, it is more acceptable to call out crates for some functionality, should it be necessary for illustration (like <a href="https://docs.rs/rand/latest/rand/"><code>rand</code></a> for random number generation), but make sure they are mature, popular and rusted.</p>
</li>
<li>
<p>Make example code as self-contained as possible and runnable (unless the idea is to illustrate a compile-time or run-time error).</p>
</li>
<li>
<p>Maintain the general style of this guide, which is to avoid using <em>you</em> as if the reader is being told or instructed; use the third-person voice instead. For example, instead of saying, “You represent optional data in Rust with the <code>Option&lt;T&gt;</code> type”, write instead, “Rust has the <code>Option&lt;T&gt;</code> type that is used to represent optional data”.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h2>
<p>The easiest way to get started with Rust without needing any local installation is to use the <a href="https://play.rust-lang.org/">Rust Playground</a>. It is a minimal development front-end that runs in the Web browser and allows writing and running Rust code.</p>
<h2 id="dev-container"><a class="header" href="#dev-container">Dev Container</a></h2>
<p>The execution environment of the <a href="https://play.rust-lang.org/">Rust Playground</a> has some limitations, such as total compilation/execution time, memory and networking so another option that does not require installing Rust would be to use a <em>dev container</em>, such as the one provided in the repository <a href="https://github.com/microsoft/vscode-remote-try-rust">https://github.com/microsoft/vscode-remote-try-rust</a>. Like Rust Playground, the dev container can be run directly in a Web browser using <a href="https://github.com/features/codespaces">GitHub Codespaces</a> or <a href="https://code.visualstudio.com/docs/devcontainers/containers">locally using Visual Studio Code</a>.</p>
<h2 id="local-install"><a class="header" href="#local-install">Local Install</a></h2>
<p>For a complete local installation of Rust compiler and its development tools, see the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Installation</a> section of the <a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">Getting Started</a> chapter in the <a href="https://doc.rust-lang.org/book/title-page.html">The Rust Programming Language</a> book, or <a href="https://www.rust-lang.org/tools/install">the Install page</a> at <a href="https://www.rust-lang.org/">rust-lang.org</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language"><a class="header" href="#language">Language</a></h1>
<p>This sections compares JavaScript and Rust language features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h1>
<p>The following table lists the primitive types in Rust and their equivalent in JavaScript:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>JavaScript</th><th>Note</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>boolean</code></td><td></td></tr>
<tr><td><code>char</code></td><td><code>string</code></td><td>See note 1.</td></tr>
<tr><td><code>i8</code></td><td><code>number</code></td><td>See note 2.</td></tr>
<tr><td><code>i16</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>i32</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>i64</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>i128</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>isize</code></td><td><code>Number.MAX_SAFE_INTEGER</code></td><td></td></tr>
<tr><td><code>u8</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>u16</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>u32</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>u64</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>u128</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>usize</code></td><td><code>Number.MAX_SAFE_INTEGER</code></td><td></td></tr>
<tr><td><code>f32</code></td><td><code>number</code>/<code>bigdecimal</code></td><td></td></tr>
<tr><td><code>f64</code></td><td><code>number</code>/<code>bigdecimal</code></td><td></td></tr>
<tr><td></td><td><code>number</code></td><td></td></tr>
<tr><td><code>()</code></td><td><code>null</code></td><td></td></tr>
<tr><td></td><td><code>undefined</code></td><td></td></tr>
<tr><td></td><td><code>object</code></td><td>See note 3.</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ol>
<li><a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a> in Rust and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type"><code>string</code></a> in JavaScript have different    definitions. In Rust, a <code>char</code> is 4 bytes wide that is a <a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar    value</a>, but in JavaScript, a character is 2 bytes wide and stores the character    using the UTF-16 encoding. There is no <code>char</code> type equivalent in JavaScript, only <code>string</code>. For more information, see the <a href="https://doc.rust-lang.org/std/primitive.char.html">Rust <code>char</code>    documentation</a>.</li>
<li>There are only three number data type in JavaScript, <code>number</code>, which is essentially a floating point number. And the <code>bigint</code> type for storing numbers that exceed the range -(2<sup>53</sup> - 1) (<code>Number.MIN_SAFE_INTEGER</code>) to 2<sup>53</sup> - 1 (<code>Number.MAX_SAFE_INTEGER</code>). and the <code>bigdecimal</code> type for storing high-precision decimals.</li>
<li>For historical reasons, JavaScript has two empty data types: <code>null</code> and <code>undefined</code>. <code>undefined</code> denotes a value that was never created, and null denotes a value that was created but intentionally left empty.
See also:</li>
</ol>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/primitives.html">Primitives (Rust By Example)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>There are two string types in Rust: <code>String</code> and <code>&amp;str</code>. The former is allocated on the heap and the latter is a slice of a <code>String</code> or a <code>&amp;str</code>.</p>
<p>The mapping of those to JavaScript is shown in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>JavaScript</th><th>Note</th></tr></thead><tbody>
<tr><td><code>&amp;mut str</code></td><td>N/A</td><td></td></tr>
<tr><td><code>&amp;str</code></td><td>N/A</td><td></td></tr>
<tr><td><code>Box&lt;str&gt;</code></td><td><code>string</code></td><td>see Note 1.</td></tr>
<tr><td><code>String</code></td><td><code>string</code></td><td></td></tr>
<tr><td><code>String</code> (mutable)</td><td><code>string</code></td><td>see Note 1.</td></tr>
</tbody></table>
</div>
<p>There are differences in working with strings in Rust and JavaScript, but the equivalents above should be a good starting point. One of the differences is that Rust strings are UTF-8 encoded, but .NET strings are UTF-16 encoded. Rust strings can be mutable when declared as such, for example <code>let s = &amp;mut String::from("hello");</code>.</p>
<p>There are also differences in using strings due to the concept of ownership. To read more about ownership with the String Type, see the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-string-type">Rust Book</a>.</p>
<p>Notes:</p>
<ol>
<li>JavaScript has only one string type, <code>string</code>. JavaScript has no pointer types.</li>
</ol>
<p>JavaScript:</p>
<pre><code class="language-js">let str = "Hello, World!"; 
let str = new String("Hello, World!")
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let str = Box::new("Hello World!");
let mut sb = String::from("Hello World!");</code></pre>
<h2 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h2>
<p>String literals in JavaScript <code>String</code> types and allocated on the heap. In Rust, they are <code>&amp;'static str</code>, which is immutable and has a global lifetime and does not get allocated on the heap; they're embedded in the compiled binary.
JavaScript:</p>
<pre><code class="language-js">let str = "Hello, World!";
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let str: &amp;'static str = "Hello, World!";</code></pre>
<p>JavaScript verbatim string literals are equivalent to Rust raw string literals.</p>
<p>JavaScript</p>
<pre><code class="language-js">let str = `Hello, \World/!`;
</code></pre>
<p>Rust</p>
<pre><code class="language-rust">let str = r#"Hello, \World/!"#;</code></pre>
<!--
C# UTF-8 string literals are equivalent to Rust byte string literals.

C#

```csharp
ReadOnlySpan<byte> str = "hello"u8;
```

Rust

```rust
let str = b"hello";
```
-->
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h2>
<p>JavaScript has a built-in string interpolation feature that allows you to embed expressions inside a string literal. The following example shows how to use string interpolation in JavaScript:</p>
<pre><code class="language-javascript">let name = "John";
let age = 42;
let str = `Person Name: ${name}, Age: ${age} `;
</code></pre>
<p>Rust does not have a built-in string interpolation feature. Instead, the <code>format!</code> macro is used to format a string. The following example shows how to use string interpolation in Rust:</p>
<pre><code class="language-rust">let name = "John";
let age = 42;
let str = format!("Person {{ name: {name}, age: {age} }}");</code></pre>
<p>Custom classes and structs can also be interpolated in JavaScript due to the fact that the <code>toString()</code> method is available for each type as it inherits from <code>object</code>.</p>
<pre><code class="language-js">class Person {
    constructor({
        name,
        age
    }) {
        this.name = name;
        this.age = age;
        this.toString = function() {
            return `Person Name: ${name}, Age: ${age}`;
        }
    }

}
let person = new Person({
    name: "John",
    age: 42
});
console.log(person);
</code></pre>
<p>In Rust, there is no default formatting implemented/inherited for each type. Instead, the <code>std::fmt::Display</code> trait must be implemented for each type that needs to be converted to a string.</p>
<pre><code class="language-rust">use std::fmt::*;

struct Person {
    name: String,
    age: i32,
}

impl Display for Person {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        write!(f, "Person {{ name: {}, age: {} }}", self.name, self.age)
    }
}

let person = Person {
    name: "John".to_owned(),
    age: 42,
};

println!("{person}");</code></pre>
<p>Another option is to use the <code>std::fmt::Debug</code> trait. The <code>Debug</code> trait is implemented for all standard types and can be used to print the internal representation of a type. The following example shows how to use the <code>derive</code> attribute to print the internal representation of a custom struct using the <code>Debug</code> macro. This declaration is used to automatically implement the <code>Debug</code> trait for the <code>Person</code> struct:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: i32,
}

let person = Person {
    name: "John".to_owned(),
    age: 42,
};

println!("{person:?}");</code></pre>
<blockquote>
<p>Note: Using the :? format specifier will use the <code>Debug</code> trait to print the struct, where leaving it out will use the <code>Display</code> trait.</p>
</blockquote>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/hello/print/print_debug.html?highlight=derive#debug">Rust by Example - Debug</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structured-types"><a class="header" href="#structured-types">Structured Types</a></h1>
<p>Commonly used object and collection types in JavaScript and their mapping to Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>JavaScript</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>array</code></td><td><code>Array</code></td></tr>
<tr><td><code>array</code></td><td><code>Vec</code></td></tr>
<tr><td><code>array</code></td><td><code>Tuple</code></td></tr>
<tr><td><code>object</code></td><td><code>HashMap</code></td></tr>
</tbody></table>
</div>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>Fixed arrays are supported the same way in Rust as in JavaScript.</p>
<p>JavaScript:</p>
<pre><code class="language-js">let someArray = [1,2];
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let someArray: [i32; 2] = [1,2];</code></pre>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p>In Rust the equivalent of a <code>array</code> is a <code>Vec&lt;T&gt;</code>. Arrays can be converted
to Vecs and vice versa.</p>
<p>JavaScript:</p>
<pre><code class="language-js">let something = ["a", "b"];
something.push("c");
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let mut something = vec![
    "a".to_owned(),
    "b".to_owned()
];

something.push("c".to_owned());</code></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>JavaScript:</p>
<pre><code class="language-js">const let something = [1, 2];
console.log(`a = ${something[0]} b = ${something[1]}`);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let something = (1, 2);
println!("a = {} b = {}", something.0, something.1);

// deconstruction supported
let (a, b) = something;
println!("a = {} b = {}", a, b);</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Rust tuple elements cannot be named. The only way to access a tuple element is by using the index of the element or deconstructing the tuple.</p>
</blockquote>
<h2 id="dictionary"><a class="header" href="#dictionary">Dictionary</a></h2>
<p>In Rust the equivalent of a <code>Dictionary&lt;TKey, TValue&gt;</code> is a <code>object</code>.</p>
<p>JavaScript:</p>
<pre><code class="language-js">var something = {
    "Foo": "Bar",
    "Baz": "Qux"
};

something["hi"] = "there";
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let mut something = HashMap::from([
    ("Foo".to_owned(), "Bar".to_owned()),
    ("Baz".to_owned(), "Qux".to_owned())
]);

something.insert("hi".to_owned(), "there".to_owned());</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/collections/index.html">Rust's standard library - Collections</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<p>The following sections discuss various topics and constructs related to developing custom types:</p>
<ul>
<li><a href="language/custom-types/classes.html">Classes</a></li>
<li><a href="language/custom-types/records.html">Records</a></li>
<li><a href="language/custom-types/structs.html">Structures</a></li>
<li><a href="language/custom-types/interfaces.html">Interfaces</a></li>
<li><a href="language/custom-types/enums.html">Enumeration Types</a></li>
<li><a href="language/custom-types/members.html">Members</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>Rust doesn't have classes. It only has <a href="language/custom-types/structs.html">structures or <code>struct</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>Rust doesn't have any construct for authoring records.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures-struct"><a class="header" href="#structures-struct">Structures (<code>struct</code>)</a></h1>
<p>In JavaScript, there is no direct concept of a structure, but you can use objects to model similar structures.
Structures in Rust:</p>
<ul>
<li>
<p>In Rust, <code>struct</code> simply defines the data/fields. The behavioural aspects in terms of functions and methods, are defined separately in an <em>implementation block</em> (<code>impl</code>).</p>
</li>
<li>
<p>They can implement multiple traits in Rust.</p>
</li>
<li>
<p>They cannot be sub-classed.</p>
</li>
<li>
<p>They are allocated on stack by default, unless:</p>
<ul>
<li>In Rust, wrapped in a smart pointer like <code>Box</code>, <code>Rc</code>/<code>Arc</code>.</li>
</ul>
</li>
</ul>
<p>In Rust, a <code>struct</code> is the primary construct for modeling any data structure (the other being an <code>enum</code>).</p>
<p>A <code>struct</code> in Rust requires just one more step using <a href="https://doc.rust-lang.org/stable/reference/attributes/derive.html">the <code>#derive</code> attribute</a> and listing the traits to be implemented:</p>
<pre><code class="language-rust">#[derive(Clone, Copy, PartialEq, Eq, Hash)]
struct Point {
    x: i32,
    y: i32,
}</code></pre>
<p>Value types in JavaScript are usually designed by a developer to be mutable. It's considered best practice speaking semantically, but the language does not prevent designing a <code>struct</code> that makes destructive or in-place modifications. In Rust, it's the same. A type has to be consciously developed to be immutable.</p>
<p>Since Rust doesn't have classes and consequently type hierarchies based on sub-classing, shared behaviour is achieved via traits and generics and polymorphism via virtual dispatch using <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a>.</p>
<p>In JavaScript:</p>
<pre><code class="language-js">class Rectangle {
    constructor(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }

    length() {
        return this.y2 - this.y1;
    }

    width() {
        return this.x2 - this.x1;
    }

    top_left() {
        return [this.x1, this.y1];
    }

    bottom_right() {
        return [this.x2, this.y2];
    }

    area() {
        return this.length() * this.width();
    }

    is_square() {
        return this.width() === this.length();
    }

    toString() {
        return `(${this.x1}, ${this.y1}), (${this.x2}, ${this.y2})`;
    }
}

const rect = new Rectangle(0, 0, 4, 4);
console.log(rect.area());
console.log(rect.toString());
</code></pre>
<p>The equivalent in Rust would be:</p>
<pre><code class="language-rust">#![allow(dead_code)]

struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    pub fn x1(&amp;self) -&gt; i32 { self.x1 }
    pub fn y1(&amp;self) -&gt; i32 { self.y1 }
    pub fn x2(&amp;self) -&gt; i32 { self.x2 }
    pub fn y2(&amp;self) -&gt; i32 { self.y2 }

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn top_left(&amp;self) -&gt; (i32, i32) {
        (self.x1, self.y1)
    }

    pub fn bottom_right(&amp;self) -&gt; (i32, i32) {
        (self.x2, self.y2)
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }

    pub fn is_square(&amp;self)  -&gt; bool {
        self.width() == self.length()
    }
}

use std::fmt::*;

impl Display for Rectangle {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        write!(f, "({}, {}), ({}, {})", self.x1, self.y2, self.x2, self.y2)
    }
}</code></pre>
<p>Since there is no inheritance in Rust, the way a type advertises support for some <em>formatted</em> representation is by implementing the <code>Display</code> trait. This then enables for an instance of the structure to participate in formatting, such as shown in the call to <code>println!</code> below:</p>
<pre><code class="language-rust">fn main() {
    let rect = Rectangle::new(12, 34, 56, 78);
    println!("Rectangle = {rect}");
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>Rust doesn't have interfaces. It has <em>traits</em>, instead. Similar to an interface, a trait represents an abstraction and its members form a contract that must be fulfilled when implemented on a type.</p>
<p>In Rust, trait implementing the interface/trait can subsequently provide a more suitable and/or optimized implementation.</p>
<p>Traits in Rust can have (instance-based) method, associated functions and constants.</p>
<p>Apart from class hierarchies, interfaces are a core means of achieving polymorphism via dynamic dispatch for cross-cutting abstractions. They enable general-purpose code to be written against the abstractions represented by the interfaces without much regard to the concrete types implementing them. The same can be achieved with Rust's <em>trait objects</em> in a limited fashion. A trait object is essentially a <em>v-table</em> (virtual table) identified with the <code>dyn</code> keyword followed by the trait name, as in <code>dyn Shape</code> (where <code>Shape</code> is the trait name). Trait objects always live behind a pointer, either a reference (e.g. <code>&amp;dyn Shape</code>) or the heap-allocated <code>Box</code> (e.g. <code>Box&lt;dyn Shape&gt;</code>).<!-- This is somewhat like in .NET, where an interface is a reference type such that a value type cast to an interface is automatically boxed onto the managed heap.--> The passing limitation of trait objects mentioned earlier, is that the original implementing type cannot be recovered. In other words, whereas it's quite common to downcast or test an interface to be an instance of some other interface or sub- or concrete type, the same is not possible in Rust (without additional effort and support).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumeration-types-enum"><a class="header" href="#enumeration-types-enum">Enumeration types (<code>enum</code>)</a></h1>
<p>To convert a Rust enum to JavaScript, you can represent it using an object with key-value pairs.</p>
<pre><code class="language-js">const DayOfWeek = {
    Sunday: 0,
    Monday: 1,
    Tuesday: 2,
    Wednesday: 3,
    Thursday: 4,
    Friday: 5,
    Saturday: 6
};
</code></pre>
<p>Rust syntax for doing the same:</p>
<pre><code class="language-rust">enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}</code></pre>
<p>An instance of an <code>enum</code> type in Rust does not have any pre-defined behaviour that's inherited. It cannot even participate in equality checks as simple as <code>dow == DayOfWeek::Friday</code>.<!-- To bring it somewhat on par in function with an `enum` in C#, use [the `#derive` attribute][derive] to automatically have macros implement the commonly needed functionality:--></p>
<pre><code class="language-rust does_not_compile">#[derive(Debug,     // enables formatting in "{:?}"
         Clone,     // required by Copy
         Copy,      // enables copy-by-value semantics
         Hash,      // enables hash-ability for use in map types
         PartialEq  // enables value equality (==)
)]
enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

fn main() {
    let dow = DayOfWeek::Wednesday;
    println!("Day of week = {dow:?}");

    if dow == DayOfWeek::Friday {
        println!("Yay! It's the weekend!");
    }

    // coerce to integer
    let dow = dow as i32;
    println!("Day of week = {dow:?}");

    let dow = dow as DayOfWeek;
    println!("Day of week = {dow:?}");
}</code></pre>
<p>As the example above shows, an <code>enum</code> can be coerced to its assigned integral value.<!--, but the opposite is not possible as in C# (although that sometimes has the downside in C#/.NET that an `enum` instance can hold an unrepresented value). Instead,--> It's up to the developer to provide such a helper function:</p>
<pre><code class="language-rust">impl DayOfWeek {
    fn try_from_i32(n: i32) -&gt; Result&lt;DayOfWeek, i32&gt; {
        use DayOfWeek::*;
        match n {
            0 =&gt; Ok(Sunday),
            1 =&gt; Ok(Monday),
            2 =&gt; Ok(Tuesday),
            3 =&gt; Ok(Wednesday),
            4 =&gt; Ok(Thursday),
            5 =&gt; Ok(Friday),
            6 =&gt; Ok(Saturday),
            _ =&gt; Err(n)
        }
    }
}</code></pre>
<p>The <code>try_from_i32</code> function returns a <code>DayOfWeek</code> in a <code>Result</code> indicating success (<code>Ok</code>) if <code>n</code> is valid. Otherwise it returns <code>n</code> as-is in a <code>Result</code> indicating failure (<code>Err</code>):</p>
<pre><code class="language-rust">let dow = DayOfWeek::try_from_i32(5);
println!("{dow:?}"); // prints: Ok(Friday)

let dow = DayOfWeek::try_from_i32(50);
println!("{dow:?}"); // prints: Err(50)</code></pre>
<p>There exist crates in Rust that can help with implementing such mapping from integral types instead of having to code them manually.</p>
<p>An <code>enum</code> type in Rust can also serve as a way to design (discriminated) union types, which allow different <em>variants</em> to hold data specific to each variant.
For example:</p>
<pre><code class="language-rust">enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));</code></pre>
<p>This form of <code>enum</code> declaration does not exist in JavaScript, but it can be emulated with classes:</p>
<pre><code class="language-js">class IpAddr {
    constructor(v4, v6) {
        this.v4 = v4;
        this.v6 = v6;
    }
}

const home = new IpAddr([127, 0, 0, 1], null);
const loopback = new IpAddr(null, "::1");
</code></pre>
<p>The difference between the two is that the Rust definition produces a <em>closed type</em> over the variants. In other words, the compiler knows that there will be no other variants of <code>IpAddr</code> except <code>IpAddr::V4</code> and <code>IpAddr::V6</code>, and it can use that knowledge to make stricter checks.<!-- For example, in a `match` expression that's akin to C#'s `switch` expression, the Rust compiler will fail code unless all variants are covered. In contrast, the emulation with C# actually creates a class hierarchy (albeit very succinctly expressed) and since `IpAddr` is an _abstract base class_, the set of all types it can represent is unknown to the compiler.--></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="members"><a class="header" href="#members">Members</a></h1>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>Rust does not have any notion of constructors. Instead, you just write factory functions that return an instance of the type. The factory functions can be stand-alone or <em>associated functions</em> of the type. <!--In C# terms, associated functions are like having static methods on a type.--> Conventionally, if there is just one factory function for a <code>struct</code>, it's named <code>new</code>:</p>
<pre><code class="language-rust">struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }
}</code></pre>
<p>Since Rust functions (associated or otherwise) do not support overloading; the factory functions have to be named uniquely. For example, below are some examples of so-called constructors or factory functions available on <code>String</code>:</p>
<ul>
<li><code>String::new</code>: creates an empty string.</li>
<li><code>String::with_capacity</code>: creates a string with an initial buffer capacity.</li>
<li><code>String::from_utf8</code>: creates a string from bytes of UTF-8 encoded text.</li>
<li><code>String::from_utf16</code>: creates a string from bytes of UTF-16 encoded text.</li>
</ul>
<p>In the case of an <code>enum</code> type in Rust, the variants act as the constructors. See <a href="language/custom-types/enums.html">the section on enumeration types</a> for more.</p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://rust-lang.github.io/api-guidelines/predictability.html?highlight=new#constructors-are-static-inherent-methods-c-ctor">Constructors are static, inherent methods (C-CTOR)</a></p>
</li>
</ul>
<h2 id="methods-static--instance-based"><a class="header" href="#methods-static--instance-based">Methods (static &amp; instance-based)</a></h2>
<p>Rust types (both <code>enum</code> and <code>struct</code>), can have static and instance-based methods. In Rust-speak, a <em>method</em> is always instance-based and is identified by the fact that its first parameter is named <code>self</code>. The <code>self</code> parameter has no type annotation since it's always the type to which the method belongs. A static method is called an <em>associated function</em>. In the example below, <code>new</code> is an associated function and the rest (<code>length</code>, <code>width</code> and <code>area</code>) are methods of the type:</p>
<pre><code class="language-rust">struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }
}</code></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>A type in Rust can have constants. However, the most interesting aspect to note is that Rust allows a type instance to be defined as a constant too:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

impl Point {
    const ZERO: Point = Point { x: 0, y: 0 };
}</code></pre>
<p>In JavaScript, you need to define a Point class, and then, simulate the construction behavior in Rust by setting a static property ZERO directly on the Point class.</p>
<pre><code class="language-js">class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

Point.ZERO = new Point(0, 0);
</code></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Rust has no built-in support for type members to adverstise and fire events.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Rust only has methods <a href="https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md#gettersetter-apis">where a getter is named after the field (in Rust method names can share the same identifier as a field) and the setter uses a <code>set_</code> prefix</a>.</p>
<p>Below is an example showing how property-like accessor methods typically look for a type in Rust:</p>
<pre><code class="language-rust">struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    // like property getters (each shares the same name as the field)

    pub fn x1(&amp;self) -&gt; i32 { self.x1 }
    pub fn y1(&amp;self) -&gt; i32 { self.y1 }
    pub fn x2(&amp;self) -&gt; i32 { self.x2 }
    pub fn y2(&amp;self) -&gt; i32 { self.y2 }

    // like property setters

    pub fn set_x1(&amp;mut self, val: i32) { self.x1 = val }
    pub fn set_y1(&amp;mut self, val: i32) { self.y1 = val }
    pub fn set_x2(&amp;mut self, val: i32) { self.x2 = val }
    pub fn set_y2(&amp;mut self, val: i32) { self.y2 = val }

    // like computed properties

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }
}</code></pre>
<h2 id="extension-methods"><a class="header" href="#extension-methods">Extension Methods</a></h2>
<p>In JavaScript, you can use prototype to add new methods to existing classes. This approach allows you to add new behavior to an existing class without changing the existing class definition:</p>
<pre><code class="language-js">//JavaScript doesn't have a StringBuilder class. This code is only used to demonstrate adding a new method to an existing class.
class StringBuilder {
    constructor(initialString) {
        this.value = initialString;
    }

    toString() {
        return this.value;
    }
}
StringBuilder.prototype.wrap = function (left, right) {
        this.value = left + this.value + right;
    }
const sb = new StringBuilder("Hello, World!");
sb.wrap("&gt;&gt;&gt; ", " &lt;&lt;&lt;");
console.log(sb.toString()); 
</code></pre>
<p>Note that for an extension method to become available (2), the namespace with the type containing the extension method must be imported (1). Rust offers a very similar facility via traits, called <em>extension traits</em>. The following example in Rust is the equivalent of the C# example above; it extends <code>String</code> with the method <code>wrap</code>:</p>
<pre><code class="language-rust">#![allow(dead_code)]

mod exts {
    pub trait StrWrapExt {
        fn wrap(&amp;mut self, left: &amp;str, right: &amp;str);
    }

    impl StrWrapExt for String {
        fn wrap(&amp;mut self, left: &amp;str, right: &amp;str) {
            self.insert_str(0, left);
            self.push_str(right);
        }
    }
}

fn main() {
    use exts::StrWrapExt as _; // (1)

    let mut s = String::from("Hello, World!");
    s.wrap("&gt;&gt;&gt; ", " &lt;&lt;&lt;"); // (2)
    println!("{s}"); // Prints: &gt;&gt;&gt; Hello, World! &lt;&lt;&lt;
}</code></pre>
<!--Just like in C#, for the method in the extension trait to become available
(2), the extension trait must be imported (1).--> Also note, the extension trait identifier `StrWrapExt` can itself be discarded via `_` at the time of import without affecting the availability of `wrap` for `String`.
<h2 id="visibilityaccess-modifiers"><a class="header" href="#visibilityaccess-modifiers">Visibility/Access modifiers</a></h2>
<p>In JavaScript, there is no explicit visibility modifier like in C#, but similar functionality can be achieved with some conventions.</p>
<p>In Rust, a compilation is built-up of a tree of modules where modules contain and define <a href="https://doc.rust-lang.org/reference/items.html"><em>items</em></a> like types, traits, enums, constants and functions. Almost everything is private by default. One exception is, for example, <em>associated items</em> in a public trait, which are public by default. This is similar to how members of a C# interface declared without any public modifiers in the source code are public by default. Rust only has the <code>pub</code> modifier to change the visibility with respect to the module tree. There are variations of <code>pub</code> that change the scope of the public visibility:</p>
<ul>
<li><code>pub(self)</code></li>
<li><code>pub(super)</code></li>
<li><code>pub(crate)</code></li>
<li><code>pub(in PATH)</code></li>
</ul>
<p>For more details, see the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility and Privacy</a> section of The Rust
Reference.</p>
  <!--

The table below is an approximation of the mapping of C# and Rust modifiers:

| C#                            | Rust         | Note        |
| ----------------------------- | ------------ | ----------- |
| `private`                     | (default)    | See note 1. |
| `protected`                   | N/A          | See note 2. |
| `internal`                    | `pub(crate)` |             |
| `protected internal` (family) | N/A          | See note 2. |
| `public`                      | `pub`        |             |

1. There is no keyword to denote private visibility; it's the default in Rust.

2. Since there are no class-based type hierarchies in Rust, there is no
   equivalent of `protected`.
-->
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>When designing a type in JavaScript, it is not the responsiblity of the developer to decide whether the a type is mutable or immutable; whether it supports destructive or non-destructive mutations. In Rust, mutability is expressed on methods through the type of the <code>self</code> parameter as shown in the example below:</p>
<pre><code class="language-rust">struct Point { x: i32, y: i32 }

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Self {
        Self { x, y }
    }

    // self is not mutable

    pub fn x(&amp;self) -&gt; i32 { self.x }
    pub fn y(&amp;self) -&gt; i32 { self.y }

    // self is mutable

    pub fn set_x(&amp;mut self, val: i32) { self.x = val }
    pub fn set_y(&amp;mut self, val: i32) { self.y = val }
}</code></pre>
<p>In JavaScript, use ES6's destructuring assignment and object extension syntax to implement non-destructive mutation:</p>
<pre><code class="language-js">class Point {
    constructor(X, Y) {
        this.X = X;
        this.Y = Y;
    }
}

let pt = new Point(123, 456);
pt = { ...pt, X: 789 };
console.log(pt); // prints: Point { X = 789, Y = 456 }
</code></pre>
<p>There is no <code>with</code> in Rust, but to emulate something similar in Rust, it has to be baked into the type's design:</p>
<pre><code class="language-rust">struct Point { x: i32, y: i32 }

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Self {
        Self { x, y }
    }

    pub fn x(&amp;self) -&gt; i32 { self.x }
    pub fn y(&amp;self) -&gt; i32 { self.y }

    // following methods consume self and return a new instance

    pub fn set_x(self, val: i32) -&gt; Self { Self::new(val, self.y) }
    pub fn set_y(self, val: i32) -&gt; Self { Self::new(self.x, val) }
}</code></pre>
<p>In JavaScript, classes are used to simulate structs, and destructuring objects is assigned to implement something like <code>with</code>.</p>
<pre><code class="language-c#">class Point {
    constructor(x, y) {
        this.X = x;
        this.Y = y;
    }

    toString() {
        return `(${this.X}, ${this.Y})`;
    }
}

let pt = new Point(123, 456);
console.log(pt.toString()); // prints: (123, 456)
pt = { ...pt, X: 789 };
console.log(pt.toString()); // prints: (789, 456)

</code></pre>
<p>Rust has a <em><a href="https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update syntax</a></em> that may seem similar:</p>
<pre><code class="language-rust">mod points {
    #[derive(Debug)]
    pub struct Point { pub x: i32, pub y: i32 }
}

fn main() {
    use points::Point;
    let pt = Point { x: 123, y: 456 };
    println!("{pt:?}"); // prints: Point { x: 123, y: 456 }
    let pt = Point { x: 789, ..pt };
    println!("{pt:?}"); // prints: Point { x: 789, y: 456 }
}</code></pre>
<!--However, while `with` in C# does a non-destructive mutation (copy then update), the [struct update syntax] does (partial) _moves_ and works with fields only.--> Since the syntax requires access to the type's fields, it is generally more common to use it within the Rust module that has access to private details of its types.
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-functions"><a class="header" href="#local-functions">Local Functions</a></h1>
<p>Rust offer local functions,but local functions in Rust cannot use variables from their surrounding lexical scope;but <em>closures</em> can.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-and-closures"><a class="header" href="#lambda-and-closures">Lambda and Closures</a></h1>
<p>Rust allows functions to be used as first-class values that enable writing <em>higher-order functions</em>. Higher-order functions are essentially functions that accept other functions as arguments to allow for the caller to participate in the code of the called function.</p>
<p>Rust has function pointers with the <code>fn</code> type being the simplest:</p>
<pre><code class="language-rust">fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(|x| x + 1, 5);
    println!("The answer is: {}", answer); // Prints: The answer is: 12
}</code></pre>
<p>In JavaScript:</p>
<pre><code class="language-js">function doTwice(f, arg) {
    return f(arg) + f(arg);
}

function main() {
    const answer = doTwice(x =&gt; x + 1, 5);
    console.log(`The answer is: ${answer}`); // Prints: The answer is: 12
}

main();

</code></pre>
<p>However, Rust makes a distinction between <em>function pointers</em> (where <code>fn</code> defines a type) and <em>closures</em>: a closure can reference variables from its surrounding lexical scope, but not a function pointer.</p>
<p>Functions and methods that accept closures are written with generic types that are bound to one of the traits representing functions: <code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code>. When it's time to provide a value for a function pointer or a closure, a Rust developer uses a <em>closure  expression</em> (like <code>|x| x + 1</code> in the example above). Whether the closure expression creates a function pointer or a closure depends on whether the closure expression references its context or not.</p>
<p>When a closure captures variables from its environment then ownership rules come into play because the ownership ends up with the closure. For more information, see the “<a href="https://doc.rust-lang.org/book/ch13-01-closures.html#moving-captured-values-out-of-closures-and-the-fn-traits">Moving Captured Values Out of Closures and the Fn Traits</a>” section of The Rust Programming Language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>⚠️Be Sure to learn about the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">ownership</a> in Rust before reading this article.</p>
<p>Consider the following example around variable assignment in JavaScript:</p>
<pre><code class="language-js">let x = 5;
</code></pre>
<p>And the same in Rust:</p>
<pre><code class="language-rust">let x: i32 = 5;</code></pre>
<p>Rust is type-safe: the compiler guarantees that the value stored in a variable is always of the designated type. The example can be simplified by using the compiler's ability to automatically infer the types of the variable. In JavaScript:</p>
<pre><code class="language-js">let x = 5;
</code></pre>
<p>In Rust:</p>
<pre><code class="language-rust">let x = 5;</code></pre>
<p>When expanding the first example to update the value of the variable (reassignment), the behavior of JavaScript and Rust differ:</p>
<pre><code class="language-js">let x = 5;
x = 6;
console.log(x); // 6
</code></pre>
<p>In Rust, the identical statement will not compile:</p>
<pre><code class="language-rust">let x = 5;
x = 6; // Error: cannot assign twice to immutable variable 'x'.
println!("{}", x);</code></pre>
<p>In Rust, variables are <em>immutable</em> by default. Once a value is bound to a name, the variable's value cannot be changed. Variables can be made <em>mutable</em> by adding <a href="https://doc.rust-lang.org/std/keyword.mut.html"><code>mut</code></a> in front of the variable name:</p>
<pre><code class="language-rust">let mut x = 5;
x = 6;
println!("{}", x); // 6</code></pre>
<p>Rust offers an alternative to fix the example above that does not require mutability through variable <em>shadowing</em>:</p>
<pre><code class="language-rust">let x = 5;
let x = 6;
println!("{}", x); // 6</code></pre>
<p>JavaScript also supports shadowing, e.g. locals can shadow fields and type members can shadow members from the base type. In Rust, the above example demonstrates that shadowing also allows to change the type of a variable without changing the name, which is useful if one wants to transform the data into different types and shapes without having to come up with a distinct name each time.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/races.html">Data races and race conditions</a> for more information around the implications
of mutability</li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/variable_bindings/scope.html#scope-and-shadowing">Scope and shadowing</a></li>
<li><a href="language/../memory-management/index.html">Memory management</a> for explanations around
<em>moving</em> and <em>ownership</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>In JavaScript, there is no such thing as a namespace. Instead, JavaScript developers use sub-objects or conventions to implement namespace-like functionality.</p>
<p>In Rust, namespace refers to a different concept. The equivalent of a namespace in Rust is a <a href="https://doc.rust-lang.org/reference/items/modules.html">module</a>. For Rust, visibility of items can be restricted using access modifiers, respectively visibility modifiers. In Rust, the default visibility is <em>private</em> (with only few exceptions). For more fine-grained access control, refer to the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility modifiers</a> reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality"><a class="header" href="#equality">Equality</a></h1>
<p>When comparing for equality in JavaScript, this refers to testing for <em>equivalence</em> insome cases (also known as <em>value equality</em>), and in other cases it refers to testing for <em>reference equality</em>, which tests whether two variables refer to the same underlying object in memory. In JavaScript, while there is no syntax for explicitly custom types, custom types can be simulated through constructors and prototypes. Constructors allow you to create objects with specific properties and methods, and you can use prototypes to implement inheritance and shared methods. Every "custom type" can be compared for equality because it inherits from <code>object</code>.</p>
<p>For example, when comparing for equivalence and reference equality in JavaScript:</p>
<pre><code class="language-js">class Point {
    constructor(X, Y) {
        this.X = X;
        this.Y = Y;
    }
    
    equals(other) {
        return this.X === other.X &amp;&amp; this.Y === other.Y;
    }
}

const a = new Point(1, 2);
const b = new Point(1, 2);
const c = a;

console.log(a.equals(b)); // (1) true
console.log(a.equals(new Point(2, 2))); // (1) false
console.log(a === b); // (2) false
console.log(a === c); // (2) true
</code></pre>
<ol>
<li>In JavaScript, classes are used to implement equals methods to compare the equality of values.</li>
<li>For the comparison of reference equality, using the === operator to check if the variable points to the same object in memory.</li>
</ol>
<p>Equivalently in Rust:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
struct Point(i32, i32);

fn main() {
    let a = Point(1, 2);
    let b = Point(1, 2);
    let c = a;
    println!("{}", a == b); // Error: "an implementation of `PartialEq&lt;_&gt;` might be missing for `Point`"
    println!("{}", a.eq(&amp;b));
    println!("{}", a.eq(&amp;Point(2, 2)));
}</code></pre>
<p>The compiler error above illustrates that in Rust equality comparisons are <em>always</em> related to a trait implementation. To support a comparison using <code>==</code>, a type must implement <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>.</p>
<p>Fixing the example above means deriving <code>PartialEq</code> for <code>Point</code>. Per default, deriving <code>PartialEq</code> will compare all fields for equality, which therefore have to implement <code>PartialEq</code> themselves.</p>
<pre><code class="language-rust">#[derive(Copy, Clone, PartialEq)]
struct Point(i32, i32);

fn main() {
    let a = Point(1, 2);
    let b = Point(1, 2);
    let c = a;
    println!("{}", a == b); // true
    println!("{}", a.eq(&amp;b)); // true
    println!("{}", a.eq(&amp;Point(2, 2))); // false
    println!("{}", a.eq(&amp;c)); // true
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a> for a stricter version of <code>PartialEq</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics provide a way to create definitions for types and methods that can be parameterized over other types. This improves code reuse, type-safety and performance (e.g. avoid run-time casts). Consider the following example of a generic type that adds a timestamp to any value. However, JavaScript does not have the concept of generics.</p>
<pre><code class="language-js">class Timestamped {
    constructor(value) {
        this.Timestamp = new Date();
        this.Value = value;
    }
}

</code></pre>
<p>Rust has generics as shown by the equivalent of the above:</p>
<pre><code class="language-rust">use std::time::*;

struct Timestamped&lt;T&gt; { value: T, timestamp: SystemTime }

impl&lt;T&gt; Timestamped&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, timestamp: SystemTime::now() }
    }
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">Generic data types</a></li>
</ul>
<h2 id="generic-type-constraints"><a class="header" href="#generic-type-constraints">Generic type constraints</a></h2>
<p>JavaScript has no concept of generics, and it is a weakly typed scripting language that makes it impossible to add type constraints to it.</p>
<pre><code class="language-js">class Timestamped {
    constructor(value) {
        this.value = value;
        this.timestamp = Date.now();
    }

    equals(other) {
        return this.value === other.value &amp;&amp; this.timestamp === other.timestamp;
    }
}
</code></pre>
<p>The same can be achieved in Rust:</p>
<pre><code class="language-rust">use std::time::*;

struct Timestamped&lt;T&gt; { value: T, timestamp: SystemTime }

impl&lt;T&gt; Timestamped&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, timestamp: SystemTime::now() }
    }
}

impl&lt;T&gt; PartialEq for Timestamped&lt;T&gt;
    where T: PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.value == other.value &amp;&amp; self.timestamp == other.timestamp
    }
}</code></pre>
<p>Generic type constraints are called <a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">bounds</a> in Rust.</p>
<p>In Rust, this is flexible because it <code>Timestamped&lt;T&gt;</code> <em>conditionally implements</em> <code>PartialEq</code>. This means that <code>Timestamped&lt;T&gt;</code> instances can still be created for some non-equatable <code>T</code>, but then <code>Timestamped&lt;T&gt;</code> will not implement equality via <code>PartialEq</code> for such a <code>T</code>.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters">Traits as parameters</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits">Returning types that implement traits</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>Rust does not support classes and sub-classing therefore polymorphism can't be achieved in an identical manner to JavaScript.</p>
<p>See also:</p>
<ul>
<li>Virtual dispatch using <em>trait objects</em>, as explained in the <a href="language/./custom-types/structs.html">Structures</a>
section</li>
<li><a href="language/./generics.html">Generics</a></li>
<li><a href="language/./inheritance.html">Inheritance</a></li>
<li><a href="language/./operator-overloading.html">Operator overloading</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h1>
<p>As explained in <a href="language/./custom-types/structs.html">structures</a> section, Rust does not provide (class-based) inheritance. A way to provide shared behavior between structs is via making use of traits. However, Rust allows to define relationships between traits by using <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait"><em>supertraits</em></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h1>
<p>In JavaScript, an exception should always be an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error"><code>Error</code></a> object or an instance of an <code>Error</code> subclass. Exceptions are thrown if a problem occurs in a code section. A thrown exception is passed up the stack until the application handles it or the program terminates.</p>
<p>Rust does not have exceptions, but distinguishes between <em>recoverable</em> and <em>unrecoverable</em> errors instead. A recoverable error represents a problem that should be reported, but for which the program continues. Results of operations that can fail with recoverable errors are of type <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>, where <code>E</code> is the type of the error variant. The <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> macro stops execution when the program encounters an unrecoverable error. An unrecoverable error is always a symptom of a bug.</p>
<h2 id="custom-error-types"><a class="header" href="#custom-error-types">Custom error types</a></h2>
<p>An example on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error">how to create user-defined exceptions</a>:</p>
<pre><code class="language-js">class EmployeeListNotFoundException extends Error {
    constructor(message) {
        super(message);
        this.name = 'EmployeeListNotFoundException';
    }
}
</code></pre>
<p>In Rust, one can implement the basic expectations for error values by implementing the <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait. The minimal user-defined error implementation in Rust is:</p>
<pre><code class="language-rust">#[derive(Debug)]
pub struct EmployeeListNotFound;

impl std::fmt::Display for EmployeeListNotFound {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_str("Could not find employee list.")
    }
}

impl std::error::Error for EmployeeListNotFound {}</code></pre>
<p>The equivalent to the JavaScript <code>Error.cause</code> property is the <code>Error::source()</code> method in Rust. However, it is not required to provide an implementation for <code>Error::source()</code>, the blanket (default) implementation returns a <code>None</code>.</p>
<h2 id="raising-exceptions"><a class="header" href="#raising-exceptions">Raising exceptions</a></h2>
<p>To raise an error in JavaScript, throw an error:</p>
<pre><code class="language-js">function throwIfNegative(value) {
    if (value &lt; 0) {
        throw new Error('Value cannot be negative');
    }
}

</code></pre>
<p>For recoverable errors in Rust, return an <code>Ok</code> or <code>Err</code> variant from a method:</p>
<pre><code class="language-rust">fn error_if_negative(value: i32) -&gt; Result&lt;(), &amp;'static str&gt; {
    if value &lt; 0 {
        Err("Specified argument was out of the range of valid values. (Parameter 'value')")
    } else {
        Ok(())
    }
}</code></pre>
<p>The <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> macro creates unrecoverable errors:</p>
<pre><code class="language-rust">fn panic_if_negative(value: i32) {
    if value &lt; 0 {
        panic!("Specified argument was out of the range of valid values. (Parameter 'value')")
    }
}</code></pre>
<h2 id="error-propagation"><a class="header" href="#error-propagation">Error propagation</a></h2>
<p>In JavaScript, exceptions are passed up until they are handled or the program terminates. In Rust, unrecoverable errors behave similarly, but handling them is uncommon.</p>
<p>Recoverable errors, however, need to be propagated and handled explicitly. Their presence is always indicated by the Rust function or method signature. Catching an exception allows you to take action based on the presence or absence of an error in JavaScript:</p>
<pre><code class="language-js">//JavaScript doesn't have a file system in it. People often implement file systems using the BrowserFS library that mimic Node.js APIs.
function write() {
    try {
        fs.writeFileSync('file.txt', 'content');
    } catch (error) {
        console.log('Writing to file failed.');
    }
}

</code></pre>
<p>In Rust, this is roughly equivalent to:</p>
<pre><code class="language-rust">fn write() {
    match std::fs::File::create("temp.txt")
        .and_then(|mut file| std::io::Write::write_all(&amp;mut file, b"content"))
    {
        Ok(_) =&gt; {}
        Err(_) =&gt; println!("Writing to file failed."),
    };
}</code></pre>
<p>Frequently, recoverable errors need only be propagated instead of being handled. For this, the method signature needs to be compatible with the types of the propagated error. The <a href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-"><code>?</code> operator</a> propagates errors ergonomically:</p>
<pre><code class="language-rust">fn write() -&gt; Result&lt;(), std::io::Error&gt; {
    let mut file = std::fs::File::create("file.txt")?;
    std::io::Write::write_all(&amp;mut file, b"content")?;
    Ok(())
}</code></pre>
<p><strong>Note</strong>: to propagate an error with the question mark operator the error implementations need to be <em>compatible</em>, as described in <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"><em>a shortcut for propagating errors</em></a>. The most general "compatible" error type is the error <a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait object</a> <code>Box&lt;dyn Error&gt;</code>.</p>
<h2 id="stack-traces"><a class="header" href="#stack-traces">Stack traces</a></h2>
<!--Throwing an unhandled exception in .NET will cause the runtime to print a stack
trace that allows debugging the problem with additional context.-->
<p>For unrecoverable errors in Rust, <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#using-a-panic-backtrace"><code>panic!</code> Backtraces</a> offer a similar behavior.</p>
<p>Recoverable errors in stable Rust do not yet support Backtraces, but it is currently supported in experimental Rust when using the <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.provide">provide method</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullability-and-optionality"><a class="header" href="#nullability-and-optionality">Nullability and Optionality</a></h1>
<p>In JavaScript, <code>null</code> is often used to represent a value that is missing, absent or logically uninitialized. For example:</p>
<pre><code class="language-js">let some = 1;
let none = null;
</code></pre>
<p>Rust has no <code>null</code> and consequently no nullable context to enable. Optional or missing values are instead represented by <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a>. The equivalent of the JavaScript code above in Rust would be:</p>
<pre><code class="language-rust">let some: Option&lt;i32&gt; = Some(1);
let none: Option&lt;i32&gt; = None;</code></pre>
<p><code>Option&lt;T&gt;</code> in Rust is practically identical to <a href="https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-option-1.html"><code>'T option</code></a> from F#.</p>
<h2 id="control-flow-with-optionality"><a class="header" href="#control-flow-with-optionality">Control flow with optionality</a></h2>
<p>In JavaScript, you may have been using <code>if</code>/<code>else</code> statements for controlling the flow when using nullable values.</p>
<pre><code class="language-js">let max = 10;
if (max !== null &amp;&amp; max !== undefined) {
    let someMax = max;
    console.log(`The maximum is ${someMax}.`); // 输出：The maximum is 10.
}
</code></pre>
<p>You can use pattern matching to achieve the same behavior in Rust:</p>
<pre><code class="language-rust">let max = Some(10u32);
match max {
    Some(max) =&gt; println!("The maximum is {}.", max), // The maximum is 10.
    None =&gt; ()
}</code></pre>
<p>It would even be more concise to use <code>if let</code>:</p>
<pre><code class="language-rust">let max = Some(10u32);
if let Some(max) = max {
    println!("The maximum is {}.", max); // The maximum is 10.
}</code></pre>
<h2 id="null-conditional-operators"><a class="header" href="#null-conditional-operators">Null-conditional operators</a></h2>
<p>The null-conditional operators (<code>?.</code>) make dealing with <code>null</code> in JavaScript more ergonomic. In Rust, they are best replaced by using the <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>map</code></a> method. The following snippets show the correspondence:</p>
<pre><code class="language-js">let some = "Hello, World!";
let none = null;
console.log(some?.length); // 13
console.log(none?.length); // undefined
</code></pre>
<pre><code class="language-rust">let some: Option&lt;String&gt; = Some(String::from("Hello, World!"));
let none: Option&lt;String&gt; = None;
println!("{:?}", some.map(|s| s.len())); // Some(13)
println!("{:?}", none.map(|s| s.len())); // None</code></pre>
<h2 id="null-coalescing-operator"><a class="header" href="#null-coalescing-operator">Null-coalescing operator</a></h2>
<p>The null-coalescing operator (<code>??</code>) is typically used to default to another value when a nullable is <code>null</code>:</p>
<pre><code class="language-js">let some = 1;
let none = null;
console.log(some ?? 0); // 1
console.log(none ?? 0); // 0
</code></pre>
<p>In Rust, you can use <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or"><code>unwrap_or</code></a> to get the same behavior:</p>
<pre><code class="language-rust">let some: Option&lt;i32&gt; = Some(1);
let none: Option&lt;i32&gt; = None;
println!("{:?}", some.unwrap_or(0)); // 1
println!("{:?}", none.unwrap_or(0)); // 0</code></pre>
<p><strong>Note</strong>: If the default value is expensive to compute, you can use <code>unwrap_or_else</code> instead. It takes a closure as an argument, which allows you to lazily initialize the default value.</p>
<h2 id="null-forgiving-operator"><a class="header" href="#null-forgiving-operator">Null-forgiving operator</a></h2>
<!--The null-forgiving operator (`!`) does not correspond to an equivalent construct
in Rust, as it only affects the compiler's static flow analysis in C#. -->In Rust,
<p>there is no need to use a substitute for it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discards"><a class="header" href="#discards">Discards</a></h1>
<p>Discards express to the compiler and others to ignore the results (or parts) of an expression.</p>
<p>There are multiple contexts where to apply this, for example as a basic example, to ignore the result of an expression. JavaScript doesn't have discards, but you can call a function without assigning a value to any variable to emulate discards. In JavaScript this looks like:</p>
<pre><code class="language-js">city.getCityInformation(cityName);
</code></pre>
<p>In Rust, <a href="https://doc.rust-lang.org/stable/book/ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">ignoring the result of an expression</a> looks
identical:</p>
<pre><code class="language-rust">_ = city.get_city_information(city_name);</code></pre>
<p>Discards are also applied for deconstructing "tuples" in JavaScript:</p>
<pre><code class="language-js">const [_, second] = ["first", "second"];
</code></pre>
<p>and, identically, in Rust:</p>
<pre><code class="language-rust">let (_, second) = ("first", "second");</code></pre>
<p>In addition to destructuring tuples, Rust offers <a href="https://doc.rust-lang.org/reference/patterns.html#destructuring">destructuring</a> of structs and enums using <code>..</code>, where <code>..</code> stands for the remaining part of a type:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!("x is {}", x), // x is 0
}</code></pre>
<p>When pattern matching, it is often useful to discard or ignore part of a matching expression. But since there are no discards in JavaScript, and the switch statement of js cannot be used in the same way as rust, you have to emulate this feature in an awkward way:</p>
<pre><code class="language-js">const _ = ("first", "second");
const result = (_ =&gt; {
    switch(true) {
        case _.includes("first"):
            return "first element matched";
        default:
            return "first element did not match";
    }
})();

console.log(result);
</code></pre>
<!--
```csharp
_ = ("first", "second") switch
{
    ("first", _) => "first element matched",
    (_, _) => "first element did not match"
};
```
-->
<p>and again, in Rust:</p>
<pre><code class="language-rust">_ = match ("first", "second")
{
    ("first", _) =&gt; "first element matched",
    (_, _) =&gt; "first element did not match"
};</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversion-and-casting"><a class="header" href="#conversion-and-casting">Conversion and Casting</a></h1>
<p>Rust is statically-typed at compile time. Hence, after a variable is declared, assigning a value of a value of a different type (unless it's implicitly convertible to the target type) to the variable is prohibited. There are several ways to convert types in Rust.</p>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>Implicit conversions exist in JavaScript as well as in Rust (called <a href="https://doc.rust-lang.org/reference/type-coercions.html">type coercions</a>).
Consider the following example:</p>
<pre><code class="language-js">let intNumber = 1;
let longNumber = intNumber;
</code></pre>
<p>Rust is much more restrictive with respect to which type coercions are allowed:</p>
<pre><code class="language-rust">let int_number: i32 = 1;
let long_number: i64 = int_number; // error: expected `i64`, found `i32`</code></pre>
<p>An example for a valid implicit conversion using <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md#subtyping">subtyping</a> is:</p>
<pre><code class="language-rust">fn bar&lt;'a&gt;() {
    let s: &amp;'static str = "hi";
    let t: &amp;'a str = s;
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">Deref coercion</a></li>
<li><a href="https://doc.rust-lang.org/reference/subtyping.html#subtyping-and-variance">Subtyping and variance</a></li>
</ul>
<h2 id="explicit-conversions"><a class="header" href="#explicit-conversions">Explicit conversions</a></h2>
<p>If converting could cause a loss of information, JavaScript requires explicit
conversions using a casting expression:</p>
<pre><code class="language-js">let a = 1.2;
let b = parseInt(a);
</code></pre>
<p>Explicit conversions can potentially fail at run-time with exceptions when <em>down-casting</em>.</p>
<p>Rust does not provide coercion between primitive types, but instead uses <a href="https://doc.rust-lang.org/rust-by-example/types/cast.html">explicit conversion</a> using the <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions"><code>as</code></a> keyword (casting). Casting in Rust will not cause a panic.</p>
<pre><code class="language-rust">let int_number: i32 = 1;
let long_number: i64 = int_number as _;</code></pre>
<h2 id="custom-conversion"><a class="header" href="#custom-conversion">Custom conversion</a></h2>
<!--Commonly, .NET types provide user-defined conversion operators to convert one
type to another type. Also, `System.IConvertible` serves the purpose of
converting one type into another.-->
<p>In Rust, the standard library contains an abstraction for converting a value into a different type, in form of the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> trait and its reciprocal, <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>. When implementing <code>From</code> for a type, a default implementation for <code>Into</code> is automatically provided (called <em>blanket implementation</em> in Rust). The following example illustrates two of such type conversions:</p>
<pre><code class="language-rust">fn main() {
    let my_id = MyId("id".into()); // `into()` is implemented automatically due to the `From&lt;&amp;str&gt;` trait implementation for `String`.
    println!("{}", String::from(my_id)); // This uses the `From&lt;MyId&gt;` implementation for `String`.
}

struct MyId(String);

impl From&lt;MyId&gt; for String {
    fn from(MyId(value): MyId) -&gt; Self {
        value
    }
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> for versions of <code>From</code> and <code>Into</code> which can fail.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator overloading</a></h1>
<p>JavaScript doesn't support operator overloading. Consider the following example in JavaScript:</p>
<pre><code class="language-js">class Fraction {
    constructor(numerator, denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
    }

    static add(a, b) {
        return new Fraction(a.numerator * b.denominator + b.numerator * a.denominator, a.denominator * b.denominator);
    }

    toString() {
        return `${this.numerator}/${this.denominator}`;
    }
}

console.log(Fraction.add(new Fraction(5, 4), new Fraction(1, 2)).toString());  // 输出 "14/8"
</code></pre>
<p>In Rust, many operators <a href="https://doc.rust-lang.org/core/ops/">can be overloaded via traits</a>. This is possible because operators are syntactic sugar for method calls. For example, the <code>+</code> operator in <code>a + b</code> calls the <code>add</code> method (see <a href="https://doc.rust-lang.org/rust-by-example/trait/ops.html">operator overloading</a>):</p>
<pre><code class="language-rust">use std::{fmt::{Display, Formatter, Result}, ops::Add};

struct Fraction {
    numerator: i32,
    denominator: i32,
}

impl Display for Fraction {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        f.write_fmt(format_args!("{}/{}", self.numerator, self.denominator))
    }
}

impl Add&lt;Fraction&gt; for Fraction {
    type Output = Fraction;

    fn add(self, rhs: Fraction) -&gt; Fraction {
        Fraction {
            numerator: self.numerator * rhs.denominator + rhs.numerator * self.denominator,
            denominator: self.denominator * rhs.denominator,
        }
    }
}

fn main() {
    println!(
        "{}",
        Fraction { numerator: 5, denominator: 4 } + Fraction { numerator: 1, denominator: 2 }
    ); // 14/8
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-comments"><a class="header" href="#documentation-comments">Documentation Comments</a></h1>
<p>A third-party tool called JSDoc provides a mechanism to document the API for types using a comment syntax. JSDoc includes a Markdown plugin that automatically converts Markdown-formatted text to HTML. The comment contains structured data representing the comments and the API signatures. Other tools can process that output to provide human-readable documentation in a different form. A simple example in JavaScript:</p>
<pre><code class="language-js">public class MyClass {}
/**
 * This is a document comment for `MyClass`.
 * @class
 */
class MyClass {}
</code></pre>
<p>In Rust <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">doc comments</a> provide the equivalent to JSDoc documentation comments. Documentation comments in Rust use Markdown syntax. <a href="https://doc.rust-lang.org/rustdoc/index.html"><code>rustdoc</code></a> is the documentation compiler for Rust code and is usually invoked through <a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html"><code>cargo doc</code></a>, which compiles the comments into documentation. For example:</p>
<pre><code class="language-rust">/// This is a doc comment for `MyStruct`.
struct MyStruct;</code></pre>
<p>In JSDoc, the equivalent to <code>cargo doc</code> is <code>jsdoc</code>.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">How to write documentation</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">Documentation tests</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Rust has <em>memory-safety</em> to avoid a whole class of bugs related to memory access, and which end up being the source of many security vulnerabilities in software. However, Rust can guarantee memory-safety at compile-time; there is no run-time making checks. The one exception here is array bound checks that are done by the compiled code at run-time, be that the Rust compiler. It is <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">possible to write unsafe code in Rust</a>, and in fact, both languages even share the same keyword, <em>literally</em> <code>unsafe</code>, to mark functions and blocks of code where memory-safety is no longer guaranteed.</p>
<p>Rust has no garbage collector (GC). All memory management is entirely the responsibility of the developer. That said, <em>safe Rust</em> has rules around ownership that ensure memory is freed <em>as soon as</em> it's no longer in use (e.g. when leaving the scope of a block or a function). The compiler does a tremendous job, through (compile-time) static analysis, of helping manage that memory through <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">ownership</a> rules. If violated, the compiler rejects the code with a compilation error.</p>
<p>In JavaScript, there is no concept of ownership of memory beyond the GC roots (static fields, local variables on a thread's stack, CPU registers, handles, etc.). It is the GC that walks from the roots during a collection to detemine all memory in use by following references and purging the rest. When designing types and writing code, a JavaScript developer can remain oblivious to ownership, memory management and even how the garbage collector works for the most part, except when performance-sensitive code requires paying attention to the amount and rate at which objects are being allocated on the heap. In contrast, Rust's ownership rules require the developer to explicitly think and express ownership at all times and it impacts everything from the design of functions, types, data structures to how the code is written. On top of that, Rust has strict rules about how data is used such that it can identify at compile-time, data <a href="https://doc.rust-lang.org/nomicon/races.html">race conditions</a> as well as corruption issues (requiring thread-safety) that could potentially occur at run-time. This section will only focus on memory management and ownership.</p>
<p>There can only be one owner of some memory, be that on the stack or heap, backing a structure at any given time in Rust. The compiler assigns <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">lifetimes</a> and tracks ownership. It is possible to pass or yield ownership, which is called <em>moving</em> in Rust. These ideas are briefly illustrated in the example Rust code below:</p>
<pre><code class="language-rust">#![allow(dead_code, unused_variables)]

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let a = Point { x: 12, y: 34 }; // point owned by a
    let b = a;                      // b owns the point now
    println!("{}, {}", a.x, a.y);   // compiler error!
}</code></pre>
<p>The first statement in <code>main</code> will allocate <code>Point</code> and that memory will be owned by <code>a</code>. In the second statement, the ownership is moved from <code>a</code> to <code>b</code> and <code>a</code> can no longer be used because it no longer owns anything or represents valid memory. The last statement that tries to print the fields of the point via <code>a</code> will fail compilation. Suppose <code>main</code> is fixed to read as follows:</p>
<pre><code class="language-rust">fn main() {
    let a = Point { x: 12, y: 34 }; // point owned by a
    let b = a;                      // b owns the point now
    println!("{}, {}", b.x, b.y);   // ok, uses b
}   // point behind b is dropped</code></pre>
<p>Note that when <code>main</code> exits, <code>a</code> and <code>b</code> will go out of scope. The memory behind <code>b</code> will be released by virtue of the stack returning to its state prior to <code>main</code> being called. In Rust, one says that the point behind <code>b</code> was <em>dropped</em>. However, note that since <code>a</code> yielded its ownership of the point to <code>b</code>, there is nothing to drop when <code>a</code> goes out of scope.</p>
<p>A <code>struct</code> in Rust can define code to execute when an instance is dropped by implementing the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait.</p>
<!--The rough equivalent of _dropping_ in C# would be a class [finalizer], but while a finalizer is called _automatically_ by the GC at some future point, dropping in Rust is always instantaneous and deterministic; that is, it happens at the point the compiler has determined that an instance has no owner based on scopes and lifetimes. In .NET, the equivalent of `Drop` would be [`IDisposable`][IDisposable] and is implemented by types to release any unmanaged resources or memory they hold. _Deterministic disposal_ is not enforced or guaranteed, but the `using` statement in C# is typically used to scope an instance of a disposable type such that it gets disposed determinstically, at the end of the `using` statement's block.

  [finalizer]: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers
  [IDisposable]: https://learn.microsoft.com/en-us/dotnet/api/system.idisposable
-->
<p>Rust has the notion of a global lifetime denoted by <code>'static</code>, which is a reserved lifetime specifier. A very rough approximation in C# would be static <em>read-only</em> fields of types.</p>
<p>In JavaScript, references are shared freely without much thought so the idea of a single owner and yielding/moving ownership may seem very limiting in Rust, but it is possible to have <em>shared ownership</em> in Rust using the smart pointer type <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc</code></a>; it adds reference-counting. Each time <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.clone">the smart pointer is cloned</a>, the reference count is incremented. When the clone drops, the reference count is decremented. The actual instance behind the smart pointer is dropped when the reference count reaches zero. These points are illustrated by the following examples that build on the previous:</p>
<pre><code class="language-rust">#![allow(dead_code, unused_variables)]

use std::rc::Rc;

struct Point {
    x: i32,
    y: i32,
}

impl Drop for Point {
    fn drop(&amp;mut self) {
        println!("Point dropped!");
    }
}

fn main() {
    let a = Rc::new(Point { x: 12, y: 34 });
    let b = Rc::clone(&amp;a); // share with b
    println!("a = {}, {}", a.x, a.y); // okay to use a
    println!("b = {}, {}", b.x, b.y);
}

// prints:
// a = 12, 34
// b = 12, 34
// Point dropped!</code></pre>
<p>Note that:</p>
<ul>
<li>
<p><code>Point</code> implements the <code>drop</code> method of the <code>Drop</code> trait and prints a message when an instance of a <code>Point</code> is dropped.</p>
</li>
<li>
<p>The point created in <code>main</code> is wrapped behind the smart pointer <code>Rc</code> and so the smart pointer <em>owns</em> the point and not <code>a</code>.</p>
</li>
<li>
<p><code>b</code> gets a clone of the smart pointer that effectively increments the reference count to 2. Unlike the earlier example, where <code>a</code> transferred its   ownership of point to <code>b</code>, both <code>a</code> and <code>b</code> own their own distinct clones of the smart pointer, so it is okay to continue to use <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>The compiler will have determined that <code>a</code> and <code>b</code> go out of scope at the end of <code>main</code> and therefore injected calls to drop each. The <code>Drop</code> implementation of <code>Rc</code> will decrement the reference count and also drop what it owns if the reference count has reached zero. When that happens, the <code>Drop</code> implementation of <code>Point</code> will print the message, “Point dropped!” The fact that the message is printed once demonstrates that only one point was created, shared and dropped.</p>
</li>
</ul>
<p><code>Rc</code> is not thread-safe. For shared ownership in a multi-threaded program, the Rust standard library offers <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> instead. The Rust language will prevent the use of <code>Rc</code> across threads.</p>
<!--In .NET, value types (like `enum` and `struct` in C#) live on the stack and reference types (`interface`, `record class` and `class` in C#) are heap-allocated. -->In Rust, the kind of type (basically `enum` or `struct` _in Rust_), does not determine where the backing memory will eventually live. By default, it is always on the stack, but just the way .NET and C# have a notion of boxing value types, which copies them to the heap, the way to allocate a type on the heap is to box it using [`Box`][box.rs]:
<pre><code class="language-rust">let stack_point = Point { x: 12, y: 34 };
let heap_point = Box::new(Point { x: 12, y: 34 });</code></pre>
<p>Like <code>Rc</code> and <code>Arc</code>, <code>Box</code> is a smart pointer, but unlike <code>Rc</code> and <code>Arc</code>, it exclusively owns the instance behind it. All of these smart pointers allocate an instance of their type argument <code>T</code> on the heap.</p>
<p>The <code>new</code> keyword in JavaScript creates an instance of a "type", and while members such as <code>Box::new</code> and <code>Rc::new</code> that you see in the examples may seem to have a similar purpose, <code>new</code> has no special designation in Rust. It's merely a <em>coventional name</em> that is meant to denote a factory. In fact they are called <em>associated functions</em> of the type, which is Rust's way of saying static methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h1>
<p>Previous section on <a href="resource-management/../memory-management/index.html">memory management</a> explains the differences between JavaScript and Rust when it comes to GC, ownership and finalizers. It is highly recommended to read it.</p>
<p>This section is limited to providing an example of a fictional <em>database connection</em> involving a SQL connection to be properly closed/disposed/dropped.</p>
<pre><code class="language-js">class DatabaseConnection {
    constructor(connectionString) {
        this.connectionString = connectionString;
    }

    closeConnection() {
        // Implementation to close the connection
    }
}

// ...closing connection...
DatabaseConnection.prototype.close = function() {
    this.closeConnection();
    console.log(`Closing connection: ${this.connectionString}`);
};

// Create instances of DatabaseConnection
const db1 = new DatabaseConnection("Server=A;Database=DB1");
const db2 = new DatabaseConnection("Server=A;Database=DB2");

// ...code for making use of the database connection...
// "Dispose" of "db1" and "db2" when their scope ends
</code></pre>
<pre><code class="language-rust">struct DatabaseConnection(&amp;'static str);

impl DatabaseConnection {
    // ...functions for using the database connection...
}

impl Drop for DatabaseConnection {
    fn drop(&amp;mut self) {
        // ...closing connection...
        self.close_connection();
        // ...printing a message...
        println!("Closing connection: {}", self.0)
    }
}

fn main() {
    let _db1 = DatabaseConnection("Server=A;Database=DB1");
    let _db2 = DatabaseConnection("Server=A;Database=DB2");
    // ...code for making use of the database connection...
} // "Dispose" of "db1" and "db2" called here; when their scope ends</code></pre>
<!--In .NET, attempting to use an object after calling `Dispose` on it will typically cause `ObjectDisposedException` to be thrown at runtime. -->In Rust, the compiler ensures at compile-time that attempting to use an object after disposing it will typically cause errors cannot happen.
<div style="break-before: page; page-break-before: always;"></div><h1 id="threading"><a class="header" href="#threading">Threading</a></h1>
<p>The Rust standard library supports threading, synchronisation and concurrency. Also the language itself and the standard library do have basic support for the concepts, a lot of additional functionality is provided by crates and will not be covered in this document.</p>
<p>JavaScript is a single-threaded scripting language that does not support multithreading.</p>
<!--The following lists approximate mapping of threading types and methods in .NET
to Rust:

| .NET               | Rust                      |
| ------------------ | ------------------------- |
| `Thread`           | `std::thread::thread`     |
| `Thread.Start`     | `std::thread::spawn`      |
| `Thread.Join`      | `std::thread::JoinHandle` |
| `Thread.Sleep`     | `std::thread::sleep`      |
| `ThreadPool`       | -                         |
| `Mutex`            | `std::sync::Mutex`        |
| `Semaphore`        | -                         |
| `Monitor`          | `std::sync::Mutex`        |
| `ReaderWriterLock` | `std::sync::RwLock`       |
| `AutoResetEvent`   | `std::sync::Condvar`      |
| `ManualResetEvent` | `std::sync::Condvar`      |
| `Barrier`          | `std::sync::Barrier`      |
| `CountdownEvent`   | `std::sync::Barrier`      |
| `Interlocked`      | `std::sync::atomic`       |
| `Volatile`         | `std::sync::atomic`       |
| `ThreadLocal`      | `std::thread_local`       |
-->
<p>Below is a simple JavaScript program that creates a thread (where the thread prints some text to standard output) indirectly by using <code>worker</code> and then waits for it to end:</p>
<pre><code class="language-js">// Equivalent JavaScript code using Web Workers
const worker = new Worker(URL.createObjectURL(new Blob([`
    self.onmessage = function(event) {
        console.log(event.data);
    };
`], { type: 'application/javascript' })));

worker.postMessage('Hello from a thread!');
</code></pre>
<p>The same code in Rust would be as follows:</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let thread = thread::spawn(|| println!("Hello from a thread!"));
    thread.join().unwrap(); // wait for thread to finish
}</code></pre>
<p>Creating and initializing a thread object and starting a thread are two different actions in JavaScript whereas in Rust both happen at the same time with <code>thread::spawn</code>.</p>
<p>In JavaScript, it's possible to send data as an argument to a thread:</p>
<pre><code class="language-js">const workerCode = `
self.onmessage = function(e) {
    let eventData = e.data;
    eventData += (" World!");
    console.log("Phrase: " + eventData);
};
`;

const blob = new Blob([workerCode], { type: "application/javascript" });
const worker = new Worker(URL.createObjectURL(blob));

const data = "Hello";
worker.postMessage(data);
</code></pre>
<!--However, a more modern or terser version would use closures:

```csharp
using System;
using System.Text;
using System.Threading;

var data = new StringBuilder("Hello");

var t = new Thread(obj => data.Append(" World!"));

t.Start();
t.Join();

Console.WriteLine($"Phrase: {data}");
```-->
<p>In Rust, there is no variation of <code>thread::spawn</code> that does the same. Instead, the data is passed to the thread via a closure:</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let data = String::from("Hello");
    let handle = thread::spawn(move || {
        let mut data = data;
        data.push_str(" World!");
        data
    });
    println!("Phrase: {}", handle.join().unwrap());
}</code></pre>
<p>A few things to note:</p>
<ul>
<li>
<p>The <code>move</code> keyword is <em>required</em> to <em>move</em> or pass the ownership of <code>data</code> to the closure for the thread. Once this is done, it's no longer legal to continue to use the <code>data</code> variable of <code>main</code>, in <code>main</code>. If that is needed, <code>data</code> must be copied or cloned (depending on what the type of the value supports).</p>
</li>
<li>
<p>Rust thread can return values, which becomes the return value of the <code>join</code> method.</p>
</li>
<li>
<p>It is possible to also pass data to the JavaScript thread via a closure, like the Rust example, but the JavaScript version does not need to worry about ownership since the memory behind the data will be reclaimed by the GC once no one is referencing it anymore.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h1>
<p>When data is shared between threads, one needs to synchronize read-write access to the data in order to avoid corruption. In JavaScript:</p>
<pre><code class="language-js">let data = 0;
let workers = [];
let completedWorkers = 0;

for (let i = 0; i &lt; 10; i++) {
    let worker = new Worker('data:text/javascript,' + encodeURIComponent(`
        let partialData = 0;
        for (let j = 0; j &lt; 1000; j++) {
            partialData++;
        }
        self.postMessage(partialData);
    `));
    
    worker.onmessage = function(event) {
        data += event.data;
        completedWorkers++;
        if (completedWorkers === 10) {
            console.log(data);
            workers.forEach(function(worker) {
                worker.terminate();
            });
        }
    };
    
    workers.push(worker);
    worker.postMessage(null);
}

</code></pre>
<p>In Rust, one must make explicit use of concurrency structures like <code>Mutex</code>:</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let data = Arc::new(Mutex::new(0)); // (1)

    let mut threads = vec![];
    for _ in 0..10 {
        let data = Arc::clone(&amp;data); // (2)
        let thread = thread::spawn(move || { // (3)
            for _ in 0..1000 {
                let mut data = data.lock().unwrap();
                *data += 1; // (4)
            }
        });
        threads.push(thread);
    }

    for thread in threads {
        thread.join().unwrap();
    }

    println!("{}", data.lock().unwrap());
}</code></pre>
<p>A few things to note:</p>
<ul>
<li>Since the ownership of the <code>Mutex</code> instance and in turn the data it guards will be shared by multiple threads, it is wrapped in an <code>Arc</code> (1). <code>Arc</code> provides atomic reference counting, which increments each time it is cloned (2) and decrements each time it is dropped. When the count reaches zero, the mutex and in turn the data it guards are dropped. This is discussed in more detail in <a href="threading/../memory-management/index.html">Memory Management</a>).</li>
<li>The closure instance for each thread receives ownership (3) of the <em>cloned reference</em> (2).  -</li>
<li>The pointer-like code that is <code>*data += 1</code> (4), is not some unsafe pointer access even if it looks like it. It's updating the data <em>wrapped</em> in the <a href="https://doc.rust-lang.org/stable/std/sync/struct.MutexGuard.html">mutex guard</a>.</li>
</ul>
<p>Unlike the C# version, where one can render it thread-unsafe by commenting out the <code>lock</code> statement, the Rust version will refuse to compile if it's changed in any way (e.g. by commenting out parts) that renders it thread-unsafe. This demonstrates that writing thread-safe code is the developer's responsibility in C# and .NET by careful use of synchronized structures whereas in Rust, one can rely on the compiler.
The compiler is able to help because data structures in Rust are marked by special <em>traits</em> (see <a href="threading/../language/custom-types/interfaces.html">Interfaces</a>): <code>Sync</code> and <code>Send</code>. <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a> indicates that references to a type's instances are safe to share between threads. <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> indicates it's safe to instances of a type across thread boundaries. For more information, see the “<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">Fearless Concurrency</a>” chapter of the Rust book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="producer-consumer"><a class="header" href="#producer-consumer">Producer-Consumer</a></h1>
<p>The producer-consumer pattern is very common to distribute work between threads where data is passed from producing threads to consuming threads without the need for sharing or locking.</p>
<pre><code class="language-js">const workerCode = `
    self.onmessage = function() {
        const messages = [];
        for (let n = 1; n &lt; 10; n++) {
            messages.push("Message #" + n);
        }
        self.postMessage(messages);
    };
`;

const blob = new Blob([workerCode], { type: "application/javascript" });
const worker = new Worker(URL.createObjectURL(blob));

// The main thread acts as a consumer here
worker.onmessage = function(event) {
    const messages = event.data;
    messages.forEach(message =&gt; console.log(message));
};

// Start the worker
worker.postMessage(null);

</code></pre>
<p>The same can be done in Rust using <em>channels</em>. The standard library primarily provides <code>mpsc::channel</code>, which is a channel that supports multiple producers and a single consumer. A rough translation of the above C# example in Rust would look as follows:</p>
<p>The same can be done in Rust using <em>channels</em>. The standard library primarily provides <code>mpsc::channel</code>, which is a channel that supports multiple producers and a single consumer. A rough translation of the above C# example in Rust would look as follows:</p>
<pre><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    let producer = thread::spawn(move || {
        for n in 1..10 {
            tx.send(format!("Message #{}", n)).unwrap();
        }
    });

    // main thread is the consumer here
    for received in rx {
        println!("{}", received);
    }

    producer.join().unwrap();
}</code></pre>
<p>The equivalent of the <a href="https://tokio.rs/tokio/tutorial/channels">async-friendly channels in the Rust space is offered by the Tokio runtime</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<h2 id="test-organization"><a class="header" href="#test-organization">Test organization</a></h2>
<p>JavaScript solutions use separate projects to host test code, irrespective of the test framework being used (Jest, Mocha, etc.) and the type of tests (unit or integration) being written. The test code therefore lives in a separate assembly than the application or library code being tested. In Rust, it is a lot more conventional for <em>unit tests</em> to be found in a separate test sub-module (conventionally) named <code>tests</code>, but which is placed in same <em>source file</em> as the application or library module code that is the subject of the tests. This has two benefits:</p>
<ul>
<li>
<p>The code/module and its unit tests live side-by-side.</p>
</li>
<li>
<p>There is no need for a workaround like <code>[InternalsVisibleTo]</code> that exists in JavaScript because the tests have access to internals by virtual of being a sub-module.</p>
</li>
</ul>
<p>The test sub-module is annotated with the <code>#[cfg(test)]</code> attribute, which has the effect that the entire module is (conditionally) compiled and run only when the <code>cargo test</code> command is issued.</p>
<p>Within the test sub-modules, test functions are annotated with the <code>#[test]</code> attribute.</p>
<p>Integration tests are usually in a directory called <code>tests</code> that sits adjacent to the <code>src</code> directory with the unit tests and source. <code>cargo test</code> compiles each file in that directory as a separate crate and run all the methods annotated with <code>#[test]</code> attribute. Since it is understood that integration tests in the <code>tests</code> directory, there is no need to mark the modules in there with the <code>#[cfg(test)]</code> attribute.</p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html">Test Organization</a></p>
</li>
</ul>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<p>As simple as it can be, the equivalent of <code>dotnet test</code> in Rust is <code>cargo test</code>.</p>
<p>The default behavior of <code>cargo test</code> is to run all the tests in parallel, but this can be configured to run consecutively using only a single thread:</p>
<pre><code>cargo test -- --test-threads=1
</code></pre>
<p>For more information, see "<a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-tests-in-parallel-or-consecutively">Running Tests in Parallel or Consecutively</a>".</p>
<h2 id="output-in-tests"><a class="header" href="#output-in-tests">Output in Tests</a></h2>
<p>For very complex integration or end-to-end test, .NET developers sometimes log what's happening during a test. The actual way they do this varies with each test framework. For example, in NUnit, this is as simple as using <code>Console.WriteLine</code>, but in XUnit, one uses <code>ITestOutputHelper</code>. In Rust, it's similar to NUnit; that is, one simply writes to the standard output using <code>println!</code>. The output captured during the running of the tests is not shown by default unless <code>cargo test</code> is run the with <code>--show-output</code> option:</p>
<pre><code>cargo test --show-output
</code></pre>
<p>For more information, see "<a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#showing-function-output">Showing Function Output</a>".</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>JavaScript users have multiple ways to assert, depending on the framework being used. For example, an assertion Jest might look like:</p>
<pre><code class="language-js">test('something has the right length', () =&gt; {
    let value = "something";
    expect(value.length).toBe(9);
});
</code></pre>
<p>An example that only uses vanilla JavaScript:</p>
<pre><code class="language-js">function somethingIsTheRightLength() {
    let value = "something";
    console.assert(value.length === 9);
}

somethingIsTheRightLength();
</code></pre>
<p>Rust does not require a separate framework or crate. The standard library comes with built-in <em>macros</em> that are good enough for most assertions in tests:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.assert.html"><code>assert!</code></a></li>
<li><a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a></li>
<li><a href="https://doc.rust-lang.org/std/macro.assert_ne.html"><code>assert_ne!</code></a></li>
</ul>
<p>Below is an example of <code>assert_eq</code> in action:</p>
<pre><code class="language-rust">#[test]
fn something_is_the_right_length() {
    let value = "something";
    assert_eq!(9, value.len());
}</code></pre>
<p>The standard library does not offer anything in the direction of data-driven tests, such as <code>[Theory]</code> in xUnit.net.</p>
<h2 id="mocking"><a class="header" href="#mocking">Mocking</a></h2>
<!--When writing tests for a .NET application or library, there exist several frameworks, like Moq and NSubstitute, to mock out the dependencies of types.--> There are<!-- similar--> crates for Rust too, like [`mockall`][mockall], that can help with mocking. However, it is also possible to use [conditional compilation] by making use of the [`cfg` attribute][cfg-attribute] as a simple means to mocking without needing to rely on external crates or frameworks. The `cfg` attribute conditionally includes the code it annotates based on a configuration symbol, such as `test` for testing. This is not very different to using `DEBUG` to conditionally compile code specifically for debug builds. One downside of this approach is that you can only have one implementation for all tests of the module. 
<p>When specified, the <code>#[cfg(test)]</code> attribute tells Rust to compile and run the code only when executing the <code>cargo test</code> command, which behind-the-scenes executes the compiler with <code>rustc --test</code>. The opposite is true for the <code>#[cfg(not(test))]</code> attribute; it includes the annotated only when testing with <code>cargo test</code>.</p>
<p>The example below shows mocking of a stand-alone function <code>var_os</code> from the standard that reads and returns the value of an environment variable. It conditionally imports a mocked version of the <code>var_os</code> function used by <code>get_env</code>. When built with <code>cargo build</code> or run with <code>cargo run</code>, the compiled binary will make use of <code>std::env::var_os</code>, but <code>cargo test</code> will instead import <code>tests::var_os_mock</code> as <code>var_os</code>, thus causing <code>get_env</code> to use the mocked version during testing:</p>
<pre><code class="language-rust">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

/// Utility function to read an environmentvariable and return its value If
/// defined. It fails/panics if the valus is not valid Unicode.
pub fn get_env(key: &amp;str) -&gt; Option&lt;String&gt; {
    #[cfg(not(test))]                 // for regular builds...
    use std::env::var_os;             // ...import from the standard library
    #[cfg(test)]                      // for test builds...
    use tests::var_os_mock as var_os; // ...import mock from test sub-module

    let val = var_os(key);
    val.map(|s| s.to_str()     // get string slice
                 .unwrap()     // panic if not valid Unicode
                 .to_owned())  // convert to "String"
}

#[cfg(test)]
mod tests {
    use std::ffi::*;
    use super::*;

    pub(crate) fn var_os_mock(key: &amp;str) -&gt; Option&lt;OsString&gt; {
        match key {
            "FOO" =&gt; Some("BAR".into()),
            _ =&gt; None
        }
    }

    #[test]
    fn get_env_when_var_undefined_returns_none() {
        assert_eq!(None, get_env("???"));
    }

    #[test]
    fn get_env_when_var_defined_returns_some_value() {
        assert_eq!(Some("BAR".to_owned()), get_env("FOO"));
    }
}</code></pre>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code coverage</a></h2>
<p>There is sophisticated tooling for JavaScript when it comes to analyzing test code coverage, such as Jest.</p>
<p>Rust is providing <a href="https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#test-coverage">built-in code coverage implementations</a> for collecting test code coverage.</p>
<p>There are also plug-ins available for Rust to help with code coverage analysis. It's not seamlessly integrated, but with some manual steps, developers can analyze their code in a visual way.</p>
<p>The combination of <a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">Coverage Gutters</a> plug-in for Visual Studio Code and <a href="https://github.com/xd009642/tarpaulin">Tarpaulin</a> allows visual analysis of the code coverage in Visual Studio Code. Coverage Gutters requires an LCOV file. Other tools besides <a href="https://github.com/xd009642/tarpaulin">Tarpaulin</a> can be used to generate that file.
Once setup, run the following command:</p>
<pre><code class="language-bash">cargo tarpaulin --ignore-tests --out Lcov
</code></pre>
<p>This generates an LCOV Code Coverage file. Once <code>Coverage Gutters: Watch</code> is enabled, it will be picked up by the Coverage Gutters plug-in, which will show in-line visual indicators about the line coverage in the source code editor.</p>
<blockquote>
<p>Note: The location of the LCOV file is essential. If a workspace (see <a href="testing/../project-structure/index.html">Project Structure</a>) with multiple packages is present and a LCOV file is generated in the root using <code>--workspace</code>, that is the file that is being used - even if there is a file present directly in the root of the package. It is quicker to isolate to the particular package under test rather than generating the LCOV file in the root.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h1>
<p>Running benchmarks in Rust is done via <a href="https://doc.rust-lang.org/cargo/commands/cargo-bench.html"><code>cargo bench</code></a>, a specific command for <code>cargo</code> which is executing all the methods annotated with the <code>#[bench]</code> attribute. This attribute is currently <a href="https://doc.rust-lang.org/rustc/tests/index.html#test-attributes">unstable</a> and available only for the nightly channel.</p>
<p>.NET users can make use of <code>Benchmark.js</code> library to benchmark methods and track their performance. The equivalent of <code>Benchmark.js</code> is a crate named <code>Criterion</code>.</p>
<p>As per its <a href="https://bheisler.github.io/criterion.rs/book/index.html">documentation</a>, <code>Criterion</code> collects and stores statistical information from run to run and can automatically detect performance regressions as well as measuring optimizations.</p>
<p>Using <code>Criterion</code> is possible to use the <code>#[bench]</code> attribute without moving to the nightly channel.</p>
<!--As in `BenchmarkDotNet`, it is also possible to integrate benchmark results with
the [GitHub Action for Continuous Benchmarking][gh-action-bench]. -->`Criterion`, in fact, supports multiple output formats, amongst which there is also the `bencher` format, mimicking the nightly `libtest` benchmarks and compatible with the above mentioned action.
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-and-tracing"><a class="header" href="#logging-and-tracing">Logging and Tracing</a></h1>
<p>For most cases, <code>console.log()</code> is a good default choice for JavaScript, since it works with a variety of built-in and third-party logging providers. In JavaScript, a minimal example for structured logging could look like:</p>
<pre><code class="language-js">let day = "Thursday";
console.log("Hello ", day); // Hello Thursday.
</code></pre>
<p>In Rust, a lightweight logging facade is provided by <a href="https://crates.io/crates/log">log</a>. It has less features than <code>ILogger</code>, e.g. as it does not yet offer (stable) structured logging or logging scopes.
For something with more feature parity to .NET, Tokio offers <a href="https://crates.io/crates/tracing"><code>tracing</code></a>. <code>tracing</code> is a framework for instrumenting Rust applications to collect structured, event-based diagnostic information. <a href="https://docs.rs/tracing-subscriber/latest/tracing_subscriber/"><code>tracing_subscriber</code></a> can be used to implement and compose <code>tracing</code> subscribers. The same structured logging example from above with <code>tracing</code> and <code>tracing_subscriber</code> looks like:</p>
<pre><code class="language-rust">fn main() {
    // install global default ("console") collector.
    tracing_subscriber::fmt().init();
    tracing::info!("Hello {Day}.", Day = "Thursday"); // Hello Thursday.
}</code></pre>
<p><a href="https://crates.io/crates/opentelemetry">OpenTelemetry</a> offers a collection of tools, APIs, and SDKs used to instrument, generate, collect, and export telemetry data based on the OpenTelemetry specification. At the time of writing, the <a href="https://opentelemetry.io/docs/reference/specification/status/#logging">OpenTelemetry Logging API</a> is not yet stable and the Rust implementation <a href="https://opentelemetry.io/docs/instrumentation/rust/#status-and-releases">does not yet support logging</a>, but the tracing API is supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h1>
<p>Both JavaScript and Rust are providing the possibility for compiling specific code based on external conditions.</p>
<p>JavaScript doesn't support conditional compilation natively. However, it is possible to use some third-party tool like <a href="https://github.com/kaysonwu/babel-plugin-preprocessor"><code>babel-plugin-preprocessor</code></a> in order to control conditional compilation.</p>
<pre><code class="language-js">//#if DEBUG
    console.log("Debug");
//#else
    console.log("Not debug");
//#endif
</code></pre>
<p>An example that uses vanilla JavaScript:</p>
<pre><code class="language-js">let isDebug = true;

if(isDebug)
{
    window.eval(`
    console.log("Debug");
    `);
} else {
    window.eval(`
    console.log("Not debug");
    `);
}
</code></pre>
<p>In addition to predefined symbols, it is also possible to use the compiler option <em><a href="https://github.com/kaysonwu/babel-plugin-preprocessor?tab=readme-ov-file#usage">DefineConstants</a></em> to define symbols that can be used with <code>#if</code>, <code>#else</code>, <code>#elif</code> and <code>#endif</code> to compile source files conditionally.</p>
<p>In Rust it is possible to use the <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute"><code>cfg attribute</code></a>, the <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr attribute</code></a> or the <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-macro"><code>cfg macro</code></a> to control conditional compilation</p>
<p>The <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute"><code>cfg attribute</code></a> is requiring and evaluating a <code>ConfigurationPredicate</code></p>
<pre><code class="language-rust">use std::fmt::{Display, Formatter};

struct MyStruct;

// This implementation of Display is only included when the OS is unix but foo is not equal to bar
// You can compile an executable for this version, on linux, with 'rustc main.rs --cfg foo=\"baz\"'
#[cfg(all(unix, not(foo = "bar")))]
impl Display for MyStruct {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_str("Running without foo=bar configuration")
    }
}

// This function is only included when both unix and foo=bar are defined
// You can compile an executable for this version, on linux, with 'rustc main.rs --cfg foo=\"bar\"'
#[cfg(all(unix, foo = "bar"))]
impl Display for MyStruct {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_str("Running with foo=bar configuration")
    }
}

// This function is panicking when not compiled for unix
// You can compile an executable for this version, on windows, with 'rustc main.rs'
#[cfg(not(unix))]
impl Display for MyStruct {
    fn fmt(&amp;self, _f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        panic!()
    }
}

fn main() {
    println!("{}", MyStruct);
}</code></pre>
<p>The <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr attribute</code></a> conditionally includes attributes based on a configuration predicate.</p>
<pre><code class="language-rust">#[cfg_attr(feature = "serialization_support", derive(Serialize, Deserialize))]
pub struct MaybeSerializableStruct;

// When the `serialization_support` feature flag is enabled, the above will expand to:
// #[derive(Serialize, Deserialize)]
// pub struct MaybeSerializableStruct;</code></pre>
<p>The built-in <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-macro"><code>cfg macro</code></a> takes in a single configuration predicate and evaluates to the true literal when the predicate is true and the false literal when it is false.</p>
<pre><code class="language-rust">if cfg!(unix) {
  println!("I'm running on a unix machine!");
}</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/conditional-compilation.html#conditional-compilation">Conditional compilation</a></li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>Conditional compilation is also helpful when there is a need for providing optional dependencies. With cargo "features", a package defines a set of named features in the <code>[features]</code> table of Cargo.toml, and each feature can either be enabled or disabled. Features for the package being built can be enabled on the command-line with flags such as <code>--features</code>. Features for dependencies can be enabled in the dependency declaration in Cargo.toml.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/features.html">Features</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-and-configuration"><a class="header" href="#environment-and-configuration">Environment and Configuration</a></h1>
<h2 id="accessing-environment-variables"><a class="header" href="#accessing-environment-variables">Accessing environment variables</a></h2>
<p>JavaScript doesn't provide access to environment variables natively. However, some non-browser JavaScript runtimes, such as Node.js and Node provides access to environment variables.</p>
<p>In Node.js:</p>
<pre><code class="language-js">const name = "EXAMPLE_VARIABLE";

let value = process.env[name];
if (!value) {
    console.log(`Variable '${name}' not set.`);
} else {
    console.log(`Variable '${name}' set to '${value}'.`);
}
</code></pre>
<p>In Deno:</p>
<pre><code class="language-js">const name = "EXAMPLE_VARIABLE";

let value = Deno.env.get(name);
if (!value) {
    console.log(`Variable '${name}' not set.`);
} else {
    console.log(`Variable '${name}' set to '${value}'.`);
}
</code></pre>
<p>Rust is providing the same functionality of accessing an environment variable at runtime via the <code>var</code> and <code>var_os</code> functions from the <code>std::env</code> module.</p>
<p><code>var</code> function is returning a <code>Result&lt;String, VarError&gt;</code>, either returning the variable if set or returning an error if the variable is not set or it is not valid Unicode.</p>
<p><code>var_os</code> has a different signature giving back an <code>Option&lt;OsString&gt;</code>, either returning some value if the variable is set, or returning None if the variable is not set. An <code>OsString</code> is not required to be valid Unicode.</p>
<pre><code class="language-rust">use std::env;


fn main() {
    let key = "ExampleVariable";
    match env::var(key) {
        Ok(val) =&gt; println!("{key}: {val:?}"),
        Err(e) =&gt; println!("couldn't interpret {key}: {e}"),
    }
}</code></pre>
<pre><code class="language-rust">use std::env;

fn main() {
    let key = "ExampleVariable";
    match env::var_os(key) {
        Some(val) =&gt; println!("{key}: {val:?}"),
        None =&gt; println!("{key} not defined in the enviroment"),
    }
}</code></pre>
<p>Rust is also providing the functionality of accessing an environment variable at compile time. The <code>env!</code> macro from <code>std::env</code> expands the value of the variable at compile time, returning a <code>&amp;'static str</code>. If the variable is not set, an error is emitted.</p>
<pre><code class="language-rust">use std::env;

fn main() {
    let example = env!("ExampleVariable");
    println!("{example}");
}</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>JavaScript doesn't support configurations.</p>
<!--Configuration in .NET is possible with configuration providers. The framework is
providing several provider implementations via
`Microsoft.Extensions.Configuration` namespace and NuGet packages.

Configuration providers read configuration data from key-value pairs using
different sources and provide a unified view of the configuration via the
`IConfiguration` type.

```csharp
using Microsoft.Extensions.Configuration;

class Example {
    static void Main()
    {
        IConfiguration configuration = new ConfigurationBuilder()
            .AddEnvironmentVariables()
            .Build();

        var example = configuration.GetValue<string>("ExampleVar");

        Console.WriteLine(example);
    }
}
```

Other providers examples can be found in the official documentation
[Configurations provider in .NET][conf-net].

A similar configuration experience in Rust is available via use of third-party
crates such as [figment] or [config].
-->
<p>In Rust it is available via use of third-party crates such as <a href="https://crates.io/crates/figment">figment</a> or <a href="https://crates.io/crates/config">config</a>. See the following example making use of <a href="https://crates.io/crates/config">config</a> crate:</p>
<pre><code class="language-rust">use config::{Config, Environment};

fn main() {
    let builder = Config::builder().add_source(Environment::default());

    match builder.build() {
        Ok(config) =&gt; {
            match config.get_string("examplevar") {
                Ok(v) =&gt; println!("{v}"),
                Err(e) =&gt; println!("{e}")
            }
        },
        Err(_) =&gt; {
            // something went wrong
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linq"><a class="header" href="#linq">LINQ</a></h1>
<p>This section discusses LINQ within the context and for the purpose of querying or transforming sequences and typically collections like lists, sets and dictionaries.</p>
<h2 id="enumerable-items"><a class="header" href="#enumerable-items">Enumerable items</a></h2>
<p>The equivalent of enumerable items in Rust is <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>. An implementation of <code>IntoIterator::into_iter</code> returns an <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>. However, when it's time to iterate over the items of a container advertising iteration support through the said types, both languages offer syntactic sugar in the form of looping constructs for iteratables. In JavaScript, there is <code>forEach</code>:</p>
<pre><code class="language-js">let values = [1, 2, 3, 4, 5];
let output = '';

values.forEach((value, index) =&gt; {
    if (index &gt; 0)
        output += ', ';
    output += value;
});

console.log(output); // Outputs: 1, 2, 3, 4, 5
</code></pre>
<p>In Rust, the equivalent is simply <code>for</code>:</p>
<pre><code class="language-rust">use std::fmt::Write;

fn main() {
    let values = [1, 2, 3, 4, 5];
    let mut output = String::new();

    for value in values {
        if output.len() &gt; 0 {
            output.push_str(", ");
        }
        // ! discard/ignore any write error
        _ = write!(output, "{value}");
    }

    println!("{output}");  // Prints: 1, 2, 3, 4, 5
}</code></pre>
<p>The <code>for</code> loop over an iterable essentially gets desuraged to the following:</p>
<pre><code class="language-rust">use std::fmt::Write;

fn main() {
    let values = [1, 2, 3, 4, 5];
    let mut output = String::new();

    let mut iter = values.into_iter();      // get iterator
    while let Some(value) = iter.next() {   // loop as long as there are more items
        if output.len() &gt; 0 {
            output.push_str(", ");
        }
        _ = write!(output, "{value}");
    }

    println!("{output}");
}</code></pre>
<p>Rust's ownership and data race condition rules apply to all instances and data, and iteration is no exception. So while looping over an array might look straightforward, one has to be mindful about ownership when needing to iterate the same collection/iterable more than once. The following example iteraters the list of integers twice, once to print their sum and another time to determine and print the maximum integer:</p>
<pre><code class="language-rust">fn main() {
    let values = vec![1, 2, 3, 4, 5];

    // sum all values

    let mut sum = 0;
    for value in values {
        sum += value;
    }
    println!("sum = {sum}");

    // determine maximum value

    let mut max = None;
    for value in values {
        if let Some(some_max) = max { // if max is defined
            if value &gt; some_max {     // and value is greater
                max = Some(value)     // then note that new max
            }
        } else {                      // max is undefined when iteration starts
            max = Some(value)         // so set it to the first value
        }
    }
    println!("max = {max:?}");
}</code></pre>
<p>However, the code above is rejected by the compiler due to a subtle difference: <code>values</code> has been changed from an array to a <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec&lt;int&gt;</code></a>, a <em>vector</em>, which is Rust's type for growable arrays. The first iteration of <code>values</code> ends up <em>consuming</em> each value as the integers are summed up. In other words, the ownership of <em>each item</em> in the vector passes to the iteration variable of the loop: <code>value</code>. Since <code>value</code> goes out of scope at the end of each iteration of the loop, the instance it owns is dropped. Had <code>values</code> been a vector of heap-allocated data, the heap memory backing each item would get freed as the loop moved to the next item. To fix the problem, one has to request iteration over <em>shared</em> references via <code>&amp;values</code> in the <code>for</code> loop. As a result, <code>value</code> ends up being a shared reference to an item as opposed to taking its ownership.</p>
<p>Below is the updated version of the previous example that compiles. The fix is to simply replace <code>values</code> with <code>&amp;values</code> in each of the <code>for</code> loops.</p>
<pre><code class="language-rust">fn main() {
    let values = vec![1, 2, 3, 4, 5];

    // sum all values

    let mut sum = 0;
    for value in &amp;values {
        sum += value;
    }
    println!("sum = {sum}");

    // determine maximum value

    let mut max = None;
    for value in &amp;values {
        if let Some(some_max) = max { // if max is defined
            if value &gt; some_max {     // and value is greater
                max = Some(value)     // then note that new max
            }
        } else {                      // max is undefined when iteration starts
            max = Some(value)         // so set it to the first value
        }
    }
    println!("max = {max:?}");
}</code></pre>
<p>The ownership and dropping can be seen in action even with <code>values</code> being an array instead of a vector. Consider just the summing loop from the above example over an array of a structure that wraps an integer:</p>
<pre><code class="language-rust">struct Int(i32);

impl Drop for Int {
    fn drop(&amp;mut self) {
        println!("{} dropped", self.0)
    }
}

fn main() {
    let values = [Int(1), Int(2), Int(3), Int(4), Int(5)];
    let mut sum = 0;

    for value in values {
        sum += value.0;
    }

    println!("sum = {sum}");
}</code></pre>
<p><code>Int</code> implements <code>Drop</code> so that a message is printed when an instance get dropped. Running the above code will print:</p>
<pre><code>value = Int(1)
Int(1) dropped
value = Int(2)
Int(2) dropped
value = Int(3)
Int(3) dropped
value = Int(4)
Int(4) dropped
value = Int(5)
Int(5) dropped
sum = 15
</code></pre>
<p>It's clear that each value is acquired and dropped while the loop is running. Once the loop is complete, the sum is printed. If <code>values</code> in the <code>for</code> loop is changed to <code>&amp;values</code> instead, like this:</p>
<pre><code class="language-rust">for value in &amp;values {
    // ...
}</code></pre>
<p>then the output of the program will change radically:</p>
<pre><code>value = Int(1)
value = Int(2)
value = Int(3)
value = Int(4)
value = Int(5)
sum = 15
Int(1) dropped
Int(2) dropped
Int(3) dropped
Int(4) dropped
Int(5) dropped
</code></pre>
<p>This time, values are acquired but not dropped while looping because each item doesn't get owned by the interation loop's variable. The sum is printed once the loop is done. Finally, when the <code>values</code> array that still owns all the the <code>Int</code> instances goes out of scope at the end of <code>main</code>, its dropping in turn drops all the <code>Int</code> instances.</p>
<p>These examples demonstrate that while iterating collection types may seem to have a lot of parallels between Rust and JavaScript, from the looping constructs to the iteration abstractions, there are still subtle differences with respect to ownership that can lead to the compiler rejecting the code in some instances.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/index.html">Iterator</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/index.html#iterating-by-reference">Iterating by reference</a></li>
</ul>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>JavaScript doesn't natively support LINQ, but there is a project called <a href="https://github.com/mihaifm/linq">LINQ.js</a> that implements LINQ in C# for JavaScript.</p>
<p><em>Operators</em> in LINQ are implemented in the form of LINQ.js extension methods that can be chained together to form a set of operations, with the most common forming a query over some sort of data source. LINQ.js also offers a SQL-inspired <em>query syntax</em> with clauses like <code>from</code>, <code>where</code>, <code>select</code>, <code>join</code> and others that can serve as an alternative or a companion to method chaining. Many imperative loops can be re-written as much more expressive and composable queries in LINQ.</p>
<p>Rust does not offer anything like LINQ.js's query syntax. It has methods, called <em><a href="https://doc.rust-lang.org/std/iter/index.html#adapters">adapters</a></em> in Rust terms, over iterable types and therefore directly comparable to chaining of methods in LINQ.js. However, whlie rewriting an imperative loop as LINQ code in LINQ.js is often beneficial in expressivity, robustness and composability, there is a trade-off with performance. Compute-bound imperative loops <em>usually</em> run faster because they can be optimised by the JIT compiler and there are fewer virtual dispatches or indirect function invocations incurred. The surprising part in Rust is that there is no performance trade-off between choosing to use method chains on an abstraction like an iterator over writing an imperative loop by hand. It's therefore far more common to see the former in code.</p>
<p>The following table lists the most common LINQ methods and their approximate counterparts in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>LINQ.js</th><th>Rust</th><th>Note</th></tr></thead><tbody>
<tr><td><code>aggregate</code></td><td><code>reduce</code></td><td>See note 1.</td></tr>
<tr><td><code>aggregate</code></td><td><code>fold</code></td><td>See note 1.</td></tr>
<tr><td><code>all</code></td><td><code>all</code></td><td></td></tr>
<tr><td><code>any</code></td><td><code>any</code></td><td></td></tr>
<tr><td><code>concat</code></td><td><code>chain</code></td><td></td></tr>
<tr><td><code>count</code></td><td><code>count</code></td><td></td></tr>
<tr><td><code>elementAt</code></td><td><code>nth</code></td><td></td></tr>
<tr><td><code>groupBy</code></td><td>-</td><td></td></tr>
<tr><td><code>last</code></td><td><code>last</code></td><td></td></tr>
<tr><td><code>max</code></td><td><code>max</code></td><td></td></tr>
<tr><td><code>max</code></td><td><code>max_by</code></td><td></td></tr>
<tr><td><code>maxBy</code></td><td><code>max_by_key</code></td><td></td></tr>
<tr><td><code>min</code></td><td><code>min</code></td><td></td></tr>
<tr><td><code>min</code></td><td><code>min_by</code></td><td></td></tr>
<tr><td><code>minBy</code></td><td><code>min_by_key</code></td><td></td></tr>
<tr><td><code>reverse</code></td><td><code>rev</code></td><td></td></tr>
<tr><td><code>select</code></td><td><code>map</code></td><td></td></tr>
<tr><td><code>select</code></td><td><code>enumerate</code></td><td></td></tr>
<tr><td><code>selectMany</code></td><td><code>flat_map</code></td><td></td></tr>
<tr><td><code>selectMany</code></td><td><code>flatten</code></td><td></td></tr>
<tr><td><code>sequenceEqual</code></td><td><code>eq</code></td><td></td></tr>
<tr><td><code>single</code></td><td><code>find</code></td><td></td></tr>
<tr><td><code>singleOrDefault</code></td><td><code>try_find</code></td><td></td></tr>
<tr><td><code>skip</code></td><td><code>skip</code></td><td></td></tr>
<tr><td><code>skipWhile</code></td><td><code>skip_while</code></td><td></td></tr>
<tr><td><code>sum</code></td><td><code>sum</code></td><td></td></tr>
<tr><td><code>take</code></td><td><code>take</code></td><td></td></tr>
<tr><td><code>takeWhile</code></td><td><code>take_while</code></td><td></td></tr>
<tr><td><code>toArray</code></td><td><code>collect</code></td><td>See note 2.</td></tr>
<tr><td><code>toDictionary</code></td><td><code>collect</code></td><td>See note 2.</td></tr>
<tr><td><code>toList</code></td><td><code>collect</code></td><td>See note 2.</td></tr>
<tr><td><code>where</code></td><td><code>filter</code></td><td></td></tr>
<tr><td><code>zip</code></td><td><code>zip</code></td><td></td></tr>
</tbody></table>
</div>
<ol>
<li>
<p>The <code>Aggregate</code> overload not accepting a seed value is equivalent to <code>reduce</code>, while the <code>Aggregate</code> overload accepting a seed value corresponds to <code>fold</code>.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> in Rust generally works for any collectible type,    which is defined as <a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html">a type that can initialize itself from an iterator    (see <code>FromIterator</code>)</a>. <code>collect</code> needs a target type, which    the compiler sometimes has trouble inferring so the <em>turbofish</em> (<code>::&lt;&gt;</code>) is    often used in conjunction with it, as in <code>collect::&lt;Vec&lt;_&gt;&gt;()</code>. This is why    <code>collect</code> appears next to a number of LINQ extension methods that convert    an enumerable/iterable source to some collection type instance.</p>
</li>
</ol>
<p>The following example shows how similar transforming sequences in LINQ.js is to doing the same in Rust. First in LINQ.js:</p>
<pre><code class="language-js">let result = Enumerable.range(0, 10)
    .where(x =&gt; x % 2 === 0)
    .selectMany(x =&gt; Enumerable.Range(0, x))
    .aggregate(0, (acc, x) =&gt; acc + x);

console.log(result); // Output: 50
</code></pre>
<p>And in Rust:</p>
<pre><code class="language-rust">let result = (0..10)
    .filter(|x| x % 2 == 0)
    .flat_map(|x| (0..x))
    .fold(0, |acc, x| acc + x);

println!("{result}"); // 50</code></pre>
<h2 id="deferred-execution-laziness"><a class="header" href="#deferred-execution-laziness">Deferred execution (laziness)</a></h2>
<p>Many operators in LINQ are designed to be lazy such that they only do work when absolutely required. This enables composition or chaining of several operations/methods without causing any side-effects. <!--For example, a LINQ operator can return an `IEnumerable<T>` that is initialized, but does not produce, compute or materialize any items of `T` until iterated. The operator is said to have _deferred execution_ semantics. If each `T` is computed as iteration reaches it (as opposed to when iteration begins) then the operator is said to _stream_ the results.--></p>
<p>Rust iterators have the same concept of <a href="https://doc.rust-lang.org/std/iter/index.html#laziness"><em>laziness</em></a> and streaming.</p>
<p>In both cases, this allows <em>infinite sequences</em> to be represented, where the underlying sequence is infinite, but the developer decides how the sequence should be terminated. The following example shows this in JavaScript:</p>
<pre><code class="language-js">function* infiniteRange() {
    for (let i = 0; ; ++i) {
        yield i;
    }
}

for (let x of infiniteRange()) {
    if (x &lt; 5) {
        console.log(x); // Prints "0 1 2 3 4"
    } else {
        break;
    }
}
</code></pre>
<p>Rust supports the same concept through infinite ranges:</p>
<pre><code class="language-rust">// Generators and yield in Rust are unstable at the moment, so
// instead, this sample uses Range:
// https://doc.rust-lang.org/std/ops/struct.Range.html

for value in (0..).take(5) {
    print!("{value} "); // Prints "0 1 2 3 4"
}</code></pre>
<h2 id="iterator-methods-yield"><a class="header" href="#iterator-methods-yield">Iterator Methods (<code>yield</code>)</a></h2>
<p>JavaScript has the <code>yield</code> keword that enables the developer to quickly write an <em>iterator method</em>. <!--The return type of an iterator method can be an `IEnumerable<T>` or an `IEnumerator<T>`. The compiler then converts the body of the method into a concrete implementation of the return type, instead of the developer having to write a full-blown class each time.--> <em><a href="https://doc.rust-lang.org/unstable-book/language-features/coroutines.html">Coroutines</a></em>, as they're called in Rust, are still considered an unstable feature at the time of this writing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meta-programming"><a class="header" href="#meta-programming">Meta Programming</a></h1>
<p>Metaprogramming can be seen as a way of writing code that writes/generates other code.</p>
<p>JavaScript has the concept of metaprogramming, but it refers to intercepting and defining basic language operations, which is different from metaprogramming in C# or Rust. There is a JavaScript source generator called <a href="https://github.com/jondot/hygen">hygen</a>, but it does not call itself a "metaprogramming tool".</p>
<p>Rust is also providing a feature for metaprogramming: <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macros</a>. There are <code>declarative macros</code> and <code>procedural macros</code>.</p>
<p>Declarative macros allow you to write control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern.</p>
<p>The following example is the definition of the <code>println!</code> macro that it is possible to call for printing some text <code>println!("Some text")</code></p>
<pre><code class="language-rust">macro_rules! println {
    () =&gt; {
        $crate::print!("\n")
    };
    ($($arg:tt)*) =&gt; {{
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    }};
}</code></pre>
<p>To learn more about writing declarative macros, refer to the Rust reference chapter <a href="https://doc.rust-lang.org/reference/macros-by-example.html">macros by example</a> or <a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a>.</p>
<p><a href="https://doc.rust-lang.org/reference/procedural-macros.html">Procedural macros</a> are different than declarative macros. Those accept some code as an input, operate on that code, and produce some code as an output.</p>
<p>Rust does not support reflection.</p>
<h2 id="function-like-macros"><a class="header" href="#function-like-macros">Function-like macros</a></h2>
<p>Function-like macros are in the following form: <code>function!(...)</code></p>
<p>The following code snippet defines a function-like macro named <code>print_something</code>, which is generating a <code>print_it</code> method for printing the "Something" string.</p>
<p>In the lib.rs:</p>
<pre><code class="language-rust">extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn print_something(_item: TokenStream) -&gt; TokenStream {
    "fn print_it() { println!(\"Something\") }".parse().unwrap()
}</code></pre>
<p>In the main.rs:</p>
<pre><code class="language-rust">use replace_crate_name_here::print_something;
print_something!();

fn main() {
    print_it();
}</code></pre>
<h2 id="derive-macros"><a class="header" href="#derive-macros">Derive macros</a></h2>
<p>Derive macros can create new items given the token stream of a struct, enum, or union. An example of a derive macro is the <code>#[derive(Clone)]</code> one, which is generating the needed code for making the input struct/enum/union implement the <code>Clone</code> trait.</p>
<p>In order to understand how to define a custom derive macro, it is possible to read the rust reference for <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros">derive macros</a></p>
<h2 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute macros</a></h2>
<p>Attribute macros define new attributes which can be attached to rust items. While working with asynchronous code, if making use of Tokio, the first step will be to decorate the new asynchronous main with an attribute macro like the following example:</p>
<pre><code class="language-rust">#[tokio::main]
async fn main() {
    println!("Hello world");
}</code></pre>
<p>In order to understand how to define a custom derive macro, it is possible to read the rust reference for <a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">attribute macros</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h1>
<p>Both JavaScript and Rust support asynchronous programming models, which look similar to each other with respect to their usage. The following example shows, on a very high level, how async code looks like in JavaScript:</p>
<pre><code class="language-js">async function printDelayed(message, cancellationToken) {
    await new Promise(resolve =&gt; setTimeout(resolve, 1000));
    return `Message: ${message}`;
}
</code></pre>
<p>Rust code is structured similarly. The following sample relies on <a href="https://docs.rs/async-std/latest/async_std/">async-std</a> for the implementation of <code>sleep</code>:</p>
<pre><code class="language-rust">use std::time::Duration;
use async_std::task::sleep;

async fn format_delayed(message: &amp;str) -&gt; String {
    sleep(Duration::from_secs(1)).await;
    format!("Message: {}", message)
}</code></pre>
<ol>
<li>
<p>The Rust <a href="https://doc.rust-lang.org/std/keyword.async.html"><code>async</code></a> keyword transforms a block of code into a state machine that implements a trait called <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>. In both languages, this allows for writing asynchronous code sequentially.</p>
</li>
<li>
<p>Note that for both Rust and JavaScript, asynchronous methods/functions are prefixed with the async keyword, but the return types are different. Asynchronous methods in JavaScript indicate the full and actual return type because it can vary. In Rust, it is enough to specify the <em>inner type</em> <code>String</code> because it's <em>always some future</em>; that is, a type that implements the <code>Future</code> trait.</p>
</li>
<li>
<p>The <code>await</code> keywords are in different positions in JavaScript and Rust. In C#, <code>Promise</code> is awaited by prefixing the expression with <code>await</code>. In Rust,
suffixing the expression with the <code>.await</code> keyword allows for <em>method
chaining</em>, even though <code>await</code> is not a method.</p>
</li>
</ol>
<p>See also:</p>
<ul>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous programming in Rust</a></li>
</ul>
<h2 id="executing-tasks"><a class="header" href="#executing-tasks">Executing tasks</a></h2>
<p>From the following example the <code>PrintDelayed</code> method executes, even though it is not awaited:</p>
<pre><code class="language-js">let cancellationToken = undefined; 
printDelayed("message", cancellationToken); // Prints "message" after a second.
await new Promise(resolve =&gt; setTimeout(resolve, 2000));

async function printDelayed(message, cancellationToken) {
    await new Promise(resolve =&gt; setTimeout(resolve, 1000));
    console.log(message);
}
</code></pre>
<p>In Rust, the same function invocation does not print anything.</p>
<pre><code class="language-rust">use async_std::task::sleep;
use std::time::Duration;

#[tokio::main] // used to support an asynchronous main method
async fn main() {
    print_delayed("message"); // Prints nothing.
    sleep(Duration::from_secs(2)).await;
}

async fn print_delayed(message: &amp;str) {
    sleep(Duration::from_secs(1)).await;
    println!("{}", message);
}</code></pre>
<p>This is because futures are lazy: they do nothing until they are run. The most common way to run a <code>Future</code> is to <code>.await</code> it. When <code>.await</code> is called on a <code>Future</code>, it will attempt to run it to completion. If the <code>Future</code> is blocked, it will yield control of the current thread. When more progress can be made, the <code>Future</code> will be picked up by the executor and will resume running, allowing the <code>.await</code> to resolve (see <a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html#asyncawait"><code>async/.await</code></a>).</p>
<p>While awaiting a function works from within other <code>async</code> functions, <code>main</code> <a href="https://doc.rust-lang.org/error-index.html#E0752">is not allowed to be <code>async</code></a>. This is a consequence of the fact that Rust itself does not provide a runtime for executing asynchronous code. Hence, there are libraries for executing asynchronous code, called <a href="https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html#async-runtimes">async runtimes</a>. <a href="https://crates.io/crates/tokio">Tokio</a> is such an async runtime, and it is frequently used. <a href="https://docs.rs/tokio/latest/tokio/attr.main.html"><code>tokio::main</code></a> from the above example marks the <code>async main</code> function as entry point to be executed by a runtime, which is set up automatically when using the macro.</p>
<h2 id="task-cancellation"><a class="header" href="#task-cancellation">Task cancellation</a></h2>
<p>The previous JavaScript examples included passing a <code>CancellationToken</code> to asynchronous methods, as is considered best practice in JavaScript. <code>CancellationToken</code>s can be used to abort an asynchronous operation.</p>
<p>Because futures are inert in Rust (they make progress only when polled), cancellation works differently in Rust. When dropping a <code>Future</code>, the <code>Future</code> will make no further progress. It will also drop all instantiated values up to the point where the future is suspended due to some outstanding asynchronous operation. This is why most asynchronous functions in Rust don't take an argument to signal cancellation, and is why dropping a future is sometimes being referred to as <em>cancellation</em>.</p>
<p><a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"><code>tokio_util::sync::CancellationToken</code></a> offers an equivalent to the .NET <code>CancellationToken</code> to signal and react to cancellation, for cases where implementing the <code>Drop</code> trait on a <code>Future</code> is unfeasible.</p>
<h2 id="executing-multiple-tasks"><a class="header" href="#executing-multiple-tasks">Executing multiple Tasks</a></h2>
<p>In JavaScript, <code>Promise.race</code> and <code>Task.WhenAll</code> are frequently used to handle the execution of multiple tasks.</p>
<p><code>Promise.race</code> completes as soon as any task completes. Tokio, for example, provides the <a href="https://docs.rs/tokio/latest/tokio/macro.select.html"><code>tokio::select!</code></a> macro as an alternative for <code>Promise.race</code>, which means to wait on multiple concurrent branches.</p>
<pre><code class="language-js">const delay = (ms) =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));

const delayMessage = async (delayTime) =&gt; {
    await delay(delayTime);
    return `Waited ${delayTime / 1000} second(s).`;
};

const delay1 = delayMessage(1000);
const delay2 = delayMessage(2000);

Promise.race([delay1, delay2]).then(result =&gt; {
    console.log(result); // Output: Waited 1 second(s).
});
</code></pre>
<p>The same example for Rust:</p>
<pre><code class="language-rust">use std::time::Duration;
use tokio::{select, time::sleep};

#[tokio::main]
async fn main() {
    let result = select! {
        result = delay(Duration::from_secs(2)) =&gt; result,
        result = delay(Duration::from_secs(1)) =&gt; result,
    };

    println!("{}", result); // Waited 1 second(s).
}

async fn delay(delay: Duration) -&gt; String {
    sleep(delay).await;
    format!("Waited {} second(s).", delay.as_secs())
}</code></pre>
<p>Again, there are crucial differences in semantics between the two examples. Most importantly, <code>tokio::select!</code> will cancel all remaining branches, while <code>Promise.race</code> leaves it up to the user to cancel any in-flight tasks.</p>
<p>Similarly, <code>Promise.all</code> can be replaced with <a href="https://docs.rs/tokio/latest/tokio/macro.join.html"><code>tokio::join!</code></a>.</p>
<h2 id="multiple-consumers"><a class="header" href="#multiple-consumers">Multiple consumers</a></h2>
<p>In JavaScript a <code>Promise</code> can be used across multiple consumers. All of them can await the task and get notified when the task is completed or failed. In Rust, the <code>Future</code> can not be cloned or copied, and <code>await</code>ing will move the ownership. The <code>futures::FutureExt::shared</code> extension creates a cloneable handle to a <code>Future</code>, which then can be distributed across multiple consumers.</p>
<pre><code class="language-rust">use futures::FutureExt;
use std::time::Duration;
use tokio::{select, time::sleep, signal};
use tokio_util::sync::CancellationToken;

#[tokio::main]
async fn main() {
    let token = CancellationToken::new();
    let child_token = token.child_token();

    let bg_operation = background_operation(child_token);

    let bg_operation_done = bg_operation.shared();
    let bg_operation_final = bg_operation_done.clone();

    select! {
        _ = bg_operation_done =&gt; {},
        _ = signal::ctrl_c() =&gt; {
            token.cancel();
        },
    }

    bg_operation_final.await;
}

async fn background_operation(cancellation_token: CancellationToken) {
    select! {
        _ = sleep(Duration::from_secs(2)) =&gt; println!("Background operation completed."),
        _ = cancellation_token.cancelled() =&gt; println!("Background operation cancelled."),
    }
}</code></pre>
<h2 id="asynchronous-iteration"><a class="header" href="#asynchronous-iteration">Asynchronous iteration</a></h2>
<p>Rust does not yet have an API for asynchronous iteration in the standard library. To support asynchronous iteration, the <a href="https://rust-lang.github.io/async-book/05_streams/01_chapter.html"><code>Stream</code></a> trait from <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>futures</code></a> offers a comparable set of functionality.</p>
<p>In JavaScript, writing async iterators has comparable syntax to when writing synchronous iterators:</p>
<pre><code class="language-js">async function* RangeAsync(start, count) {
    for (let i = 0; i &lt; count; i++) {
        await new Promise(resolve =&gt; setTimeout(resolve, i * 1000));
        yield start + i;
    }
}

(async () =&gt; {
    for await (const item of RangeAsync(10, 3)) {
        console.log(item + " "); // Prints "10 11 12".
    }
})();
</code></pre>
<p>In Rust, there are several types that implement the <code>Stream</code> trait, and hence can be used for creating streams, e.g. <code>futures::channel::mpsc</code>. <a href="https://github.com/tokio-rs/async-stream"><code>async-stream</code></a> offers a set of macros that can be used to generate streams succinctly.</p>
<pre><code class="language-rust">use async_stream::stream;
use futures_core::stream::Stream;
use futures_util::{pin_mut, stream::StreamExt};
use std::{
    io::{stdout, Write},
    time::Duration,
};
use tokio::time::sleep;

#[tokio::main]
async fn main() {
    let stream = range(10, 3);
    pin_mut!(stream); // needed for iteration
    while let Some(result) = stream.next().await {
        print!("{} ", result); // Prints "10 11 12".
        stdout().flush().unwrap();
    }
}

fn range(start: i32, count: i32) -&gt; impl Stream&lt;Item = i32&gt; {
    stream! {
        for i in 0..count {
            sleep(Duration::from_secs(i as _)).await;
            yield start + i;
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>The JavaScript standard does not specify a specification for the structure of the project. Generally speaking, all the files in a JavaScript library are usually placed in a folder named after the library. The following is a common JavaScript project specification:</p>
<pre><code>.
+-- src/
|   +-- project1.js
+-- styles/
|   +-- style1.js
+-- examples/
|   +-- some-example.js
+-- tests/
    +-- some-integration-test.js
</code></pre>
<p>Cargo uses the following conventions for the <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">package layout</a> to make it easy to dive into a new Cargo <a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">package</a>:</p>
<pre><code>.
+-- Cargo.lock
+-- Cargo.toml
+-- src/
|   +-- lib.rs
|   +-- main.rs
+-- benches/
|   +-- some-bench.rs
+-- examples/
|   +-- some-example.rs
+-- tests/
    +-- some-integration-test.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of the package.</li>
<li><code>src/lib.rs</code> is the default library file, and <code>src/main.rs</code> is the default executable file (see <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery">target auto-discovery</a>).</li>
<li>Benchmarks go in the <code>benches</code> directory, integration tests go in the <code>tests</code> directory (see <a href="project-structure/../testing/index.html">testing</a>, <a href="project-structure/../benchmarking/index.html">benchmarking</a>).</li>
<li>Examples go in the <code>examples</code> directory.</li>
<li>There is no separate crate for unit tests, unit tests live in the same file as the code (see <a href="project-structure/../testing/index.html">testing</a>).</li>
</ul>
<h2 id="managing-large-projects"><a class="header" href="#managing-large-projects">Managing large projects</a></h2>
<p>For very large projects in Rust, Cargo offers <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">workspaces</a> to organize the project. A workspace can help manage multiple related packages that are developed in tandem. Some projects use <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace"><em>virtual manifests</em></a>, especially when there is no primary package.</p>
<h2 id="managing-dependency-versions"><a class="header" href="#managing-dependency-versions">Managing dependency versions</a></h2>
<p>There is no concept of dependency in the JavaScript standard. However, some JavaScript runtimes, such as Node.js and Deno, have the concept of dependencies.
When managing larger projects in Node.js, it may be appropriate to manage the versions of dependencies centrally, using strategies such as [nvm]. Deno uses [dvm].  Cargo introduced [workspace inheritance] to manage dependencies centrally.
[nvm]: https://github.com/nvm-sh/nvm
[dvm]: https://github.com/justjavac/dvm
[workspace inheritance]: https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation-and-building"><a class="header" href="#compilation-and-building">Compilation and Building</a></h1>
<h2 id="javascript-cli"><a class="header" href="#javascript-cli">JavaScript CLI</a></h2>
<p>There is no concept of CLI in the JavaScript standard. People often use non-browser runtimes such as Node.js and Deno to act as CLIs.The equivalent of the JavaScript CLIs in Rust is <a href="https://doc.rust-lang.org/cargo/">Cargo</a> (<code>cargo</code>). Both tools are entry-point wrappers that simplify use of other low-level tools. For example, although you could invoke the JavaScript engines, developers tend to use third-party tools such as <code>webpack</code> and <code>vite</code> to build their solution. Similarly in Rust, while you could use the Rust compiler (<code>rustc</code>) directly, using <code>cargo build</code> is generally far simpler.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>When building JavaScript, the scripts coming from dependent packages are generally co-located with the project's output assembly. <a href="https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo-build1"><code>cargo build</code></a> in Rust compiles the project sources, except the Rust compiler statically links (although there exist other <a href="https://doc.rust-lang.org/reference/linkage.html">linking options</a>) all code into a single, platform-dependent, binary.</p>
<p>Developers use different ways to prepare a JavaScript executable for distribution, either as a <em>framework-dependent deployment</em> (FDD) or <em>self-contained deployment</em> (SCD). In Rust, there is no way to let the build output already contains a single, platform-dependent binary for each target.</p>
<p>In Rust, the build output is, again, a platform-dependent, compiled library for each library target.</p>
<p>See also:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">Crate</a></li>
</ul>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>There is no concept of dependency in the JavaScript standard. However, some JavaScript runtimes, such as Node.js and Deno, have the concept of dependencies. In Node.js and Deno, the contents of a project file (<code>package.json</code>) define the build options and dependencies. In Rust, when using Cargo, a <code>Cargo.toml</code> declares the dependencies for a package. A typical project file will look like:</p>
<pre><code class="language-json">{
  "name": "your-project-name",
  "version": "1.0.0",
  "description": "Your project description",
  "dependencies": {
    "linq": "4.0.3"
  }
}
</code></pre>
<p>The equivalent <code>Cargo.toml</code> in Rust is defined as:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
tokio = "1.0.0"
</code></pre>
<p>Cargo follows a convention that <code>src/main.rs</code> is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains <code>src/lib.rs</code>, the package contains a library crate with the same name as the package.</p>
<h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<p>There is no concept of packages in the JavaScript standard. However, some JavaScript runtimes, such as Node.js, have the concept of packages. NPM is most commonly used to install packages for Node.js, and various tools supported it.
For example, adding a Node.js package reference with the Node,js CLI will add the
dependency to the project file:</p>
<p>npm install linq</p>
<p>In Rust this works almost the same if using Cargo to add packages.</p>
<p>cargo add tokio</p>
<p>The most common package registry for Node.js is [npmjs.com] whereas Rust packages are usually shared via <a href="https://crates.io">crates.io</a>.</p>
<h2 id="static-code-analysis"><a class="header" href="#static-code-analysis">Static code analysis</a></h2>
<p>ESLint is an analyzer that provide code quality as well as code-style analysis. The equivalent linting tool in Rust
is <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>.</p>
<p>Clippy can fail if the compiler or Clippy emits warnings (<code>cargo clippy -- -D warnings</code>).</p>
<p>There are further static checks to consider adding to a Rust CI pipeline:</p>
<ul>
<li>Run <a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html"><code>cargo doc</code></a> to ensure that documentation is correct.</li>
<li>Run <a href="https://doc.rust-lang.org/cargo/commands/cargo-check.html#manifest-options"><code>cargo check --locked</code></a> to enforce that the <code>Cargo.lock</code> file is up-to-date.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
