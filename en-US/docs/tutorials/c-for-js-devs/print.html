<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C for JavaScript Developers</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="license.html">License</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/scalar-types.html"><strong aria-hidden="true">2.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="language/strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="language/structured-types.html"><strong aria-hidden="true">2.3.</strong> Structured Types</a></li><li class="chapter-item expanded "><a href="language/custom-types/index.html"><strong aria-hidden="true">2.4.</strong> Custom Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/custom-types/classes.html"><strong aria-hidden="true">2.4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="language/custom-types/records.html"><strong aria-hidden="true">2.4.2.</strong> Records</a></li><li class="chapter-item expanded "><a href="language/custom-types/structs.html"><strong aria-hidden="true">2.4.3.</strong> Structures</a></li><li class="chapter-item expanded "><a href="language/custom-types/interfaces.html"><strong aria-hidden="true">2.4.4.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="language/custom-types/enums.html"><strong aria-hidden="true">2.4.5.</strong> Enumeration Types</a></li><li class="chapter-item expanded "><a href="language/custom-types/members.html"><strong aria-hidden="true">2.4.6.</strong> Members</a></li></ol></li><li class="chapter-item expanded "><a href="language/local-functions.html"><strong aria-hidden="true">2.5.</strong> Local Functions</a></li><li class="chapter-item expanded "><a href="language/lambda-and-closures.html"><strong aria-hidden="true">2.6.</strong> Lambda and Closures</a></li><li class="chapter-item expanded "><a href="language/variables.html"><strong aria-hidden="true">2.7.</strong> Variables</a></li><li class="chapter-item expanded "><a href="language/namespaces.html"><strong aria-hidden="true">2.8.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="language/equality.html"><strong aria-hidden="true">2.9.</strong> Equality</a></li><li class="chapter-item expanded "><a href="language/generics.html"><strong aria-hidden="true">2.10.</strong> Generics</a></li><li class="chapter-item expanded "><a href="language/polymorphism.html"><strong aria-hidden="true">2.11.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="language/inheritance.html"><strong aria-hidden="true">2.12.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="language/exception-handling.html"><strong aria-hidden="true">2.13.</strong> Exception Handling</a></li><li class="chapter-item expanded "><a href="language/nullability-and-optionality.html"><strong aria-hidden="true">2.14.</strong> Nullability and Optionality</a></li><li class="chapter-item expanded "><a href="language/discards.html"><strong aria-hidden="true">2.15.</strong> Discards</a></li><li class="chapter-item expanded "><a href="language/conversion-and-casting.html"><strong aria-hidden="true">2.16.</strong> Conversion and Casting</a></li><li class="chapter-item expanded "><a href="language/operator-overloading.html"><strong aria-hidden="true">2.17.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="language/documentation-comments.html"><strong aria-hidden="true">2.18.</strong> Documentation Comments</a></li></ol></li><li class="chapter-item expanded "><a href="memory-management/index.html"><strong aria-hidden="true">3.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="resource-management/index.html"><strong aria-hidden="true">4.</strong> Resource Management</a></li><li class="chapter-item expanded "><a href="threading/index.html"><strong aria-hidden="true">5.</strong> Threading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threading/synchronization.html"><strong aria-hidden="true">5.1.</strong> Synchronization</a></li><li class="chapter-item expanded "><a href="threading/producer-consumer.html"><strong aria-hidden="true">5.2.</strong> Producer-Consumer</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="benchmarking/index.html"><strong aria-hidden="true">7.</strong> Benchmarking</a></li><li class="chapter-item expanded "><a href="logging-and-tracing/index.html"><strong aria-hidden="true">8.</strong> Logging and Tracing</a></li><li class="chapter-item expanded "><a href="conditional-compilation/index.html"><strong aria-hidden="true">9.</strong> Conditional Compilation</a></li><li class="chapter-item expanded "><a href="environment-and-configuration/index.html"><strong aria-hidden="true">10.</strong> Environment and Configuration</a></li><li class="chapter-item expanded "><a href="linq/index.html"><strong aria-hidden="true">11.</strong> LINQ</a></li><li class="chapter-item expanded "><a href="meta-programming/index.html"><strong aria-hidden="true">12.</strong> Meta Programming</a></li><li class="chapter-item expanded "><a href="asynchronous-programming/index.html"><strong aria-hidden="true">13.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="project-structure/index.html"><strong aria-hidden="true">14.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="compilation-and-building/index.html"><strong aria-hidden="true">15.</strong> Compilation and Building</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C for JavaScript Developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a (non-comprehensive) guide for JavaScript developers that are completely new to the C programming language. Some concepts and constructs translate fairly well between JavaScript and C, but which may be expressed differently, whereas others are a radical departure, like memory management. This guide provides a brief comparison and mapping of those constructs and concepts with concise examples.</p>
<p>The original authors<sup class="footnote-reference"><a href="#authors">1</a></sup> of this guide were themselves JavaScript developers who were completely new to C. <!--This guide is the compilation of the knowledge acquired by the authors writing Rust code over the course of several months. -->It is the guide the authors wish they had when they started on their C journey. That said, the authors would encourage you to read books and other material available on the Web to embrace C and its idioms rather than attempting to learn it exclusively through the lens of JavaScript. Meanwhile, this guide can help answers some question quickly, like: <em>Does C support inheritance, threading, asynchronous programming, etc.?</em>
Assumptions:</p>
<ul>
<li>Reader is a seasoned JavaScript developer.</li>
<li>Reader is completely new to C.</li>
</ul>
<p>Goals:</p>
<ul>
<li>Provide a brief comparison and mapping of various JavaScript topics to their counterparts in C.</li>
<li>Provide links to C reference, book and articles for further reading on topics.</li>
</ul>
<p>Non-goals:</p>
<ul>
<li>Discussion of design patterns and architectures.</li>
<li>Tutorial on the C language.</li>
<li>Reader is proficient in C after reading this guide.</li>
<li>While there are short examples that contrast JavaScript and C code for some topics, this guide is not meant to be a cookbook of coding recipes in the two languages.</li>
</ul>
<hr />
<div class="footnote-definition" id="authors"><sup class="footnote-definition-label">1</sup>
<p>The original authors of Microsoft's Rust for C#/.NET Developers were (in alphabetical order):
<a href="https://github.com/atifaziz">Atif Aziz</a>, <a href="https://github.com/bastbu">Bastian Burger</a>, <a href="https://github.com/danigian">Daniele Antonio Maggio</a>, <a href="https://github.com/dariuszparys">Dariusz Parys</a> and
<a href="https://github.com/p-schuler">Patrick Schuler</a>.</p>
</div>
<p>The adaption work is done by @<a href="https://github.com/DevScholar">DevScholar</a> on GitHub.</p>
<p>This book contains artificial intelligence generated content, and the content is audited.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<blockquote>
MIT License
<p>Copyright (c) Contributors.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
</blockquote>
<p>This book is adapted from Microsoft's <a href="https://github.com/microsoft/rust-for-dotnet-devs">Rust for C#/.NET Developers</a>.</p>
<blockquote>
MIT License
<p>Copyright (c) Microsoft Corporation.
Portions Copyright (c) 2010 The Rust Project Developers</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>You are invited to contribute üíñ to this guide by opening issues and submitting pull requests!</p>
<p>Here are some ideas üí° for how and where you can help most with contributions:</p>
<ul>
<li>
<p>Fix any spelling or grammatical mistakes you see as you read.</p>
</li>
<li>
<p>Fix technical inaccuracies.</p>
</li>
<li>
<p>Fix logical or compilation errors in code examples.</p>
</li>
<li>
<p>Improve the English, especially if it's your native tongue or you have excellent proficiency in the language.</p>
</li>
<li>
<p>Expand an explanation to provide more context or improve the clarity of some topic or concept.</p>
</li>
<li>
<p>Keep it fresh with changes in JavaScript and C. For example, if there is a change in JavaScript or C that brings the two languages closer together then some parts, including sample code, may need revision.</p>
</li>
</ul>
<p>If you're making a small to modest correction, such fixing a spelling error or a syntax error in a code example, then feel free to submit a pull request directly. For changes that may require a large effort on your part (and reviewers as a result), it is strongly recommended that you submit an issue and seek approval of the maintainers/editors before investing your time. It will avoid heartbreak üíî if the pull request is rejected for various reasons.</p>
<p>Making quick contributions has been made super simple. If you see an error on a page and happen to be online, you can click edit icon üìù in the corner of the page to edit the Markdown source of the content and submit a change.</p>
<h2 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h2>
<ul>
<li>
<p>Stick to the goals of this guide laid out in the <a href="introduction.html">introduction</a>; put another way, avoid the non-goals!</p>
</li>
<li>
<p>Prefer to keep text short and use short, concise and realistic code examples to illustrate a point.</p>
</li>
<li>
<p>As much as it is possible, always provide and compare examples in C and JavaScript.</p>
</li>
<li>
<p>Feel free to use latest JavaScript/C language features if it makes an example simpler, concise and alike across the two languages.</p>
</li>
<li>
<p>Avoid using community packages in JavaScript examples. Stick to the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">Global Objects</a> as much as possible. Since the <a href="https://en.cppreference.com/w/c/header">C Standard Library</a> has a much smaller API surface, it is more acceptable to call out libraries for some functionality, should it be necessary for illustration (like <a href="https://en.cppreference.com/w/c/numeric/random/rand"><code>rand</code></a> for random number generation), but make sure they are mature, popular.</p>
</li>
<li>
<p>Make example code as self-contained as possible and runnable (unless the idea is to illustrate a compile-time or run-time error).</p>
</li>
<li>
<p>Maintain the general style of this guide, which is to avoid using <em>you</em> as if the reader is being told or instructed; use the third-person voice instead. For example, instead of saying, ‚ÄúYou represent optional data in C with the pointers‚Äù, write instead, ‚ÄúC has the pointers that is used to represent optional data‚Äù.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="online-c-compilers"><a class="header" href="#online-c-compilers">Online C Compilers</a></h2>
<p>The easiest way to get started with C without needing any local installation is to use online C compilers. They are minimal development front-ends that runs in the Web browser and allows writing and running C code.</p>
<h2 id="dev-container"><a class="header" href="#dev-container">Dev Container</a></h2>
<p>The execution environment of the online C compilers has some limitations, such as total compilation/execution time, memory and networking so another option that does not require installing C would be to use a <em>dev container</em>. Like online C compilers, the dev container can be run directly in a Web browser using <a href="https://github.com/features/codespaces">GitHub Codespaces</a> or <a href="https://code.visualstudio.com/docs/devcontainers/containers">locally using Visual Studio Code</a>.</p>
<h2 id="local-install"><a class="header" href="#local-install">Local Install</a></h2>
<p>For a complete local installation of C compiler and its development tools, see the installation page on websites of different compilers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language"><a class="header" href="#language">Language</a></h1>
<p>This sections compares JavaScript and C language features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h1>
<p>The following table lists the primitive types in C and their equivalent in JavaScript:</p>
<div class="table-wrapper"><table><thead><tr><th>C</th><th>JavaScript</th><th>Note</th></tr></thead><tbody>
<tr><td><code>bool (stdbool.h)</code></td><td><code>boolean</code></td><td></td></tr>
<tr><td><code>char</code></td><td><code>string</code></td><td>See note 1.</td></tr>
<tr><td><code>char / signed char</code></td><td><code>number</code></td><td>See note 2.</td></tr>
<tr><td><code>short int</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>int / signed int</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>long long int</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>unsigned long long int</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>LONG_LONG_MAX (limits.h)</code></td><td><code>Number.MAX_SAFE_INTEGER</code></td><td></td></tr>
<tr><td><code>unsigned char</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>unsigned short int</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>unsigned int</code></td><td><code>number</code></td><td></td></tr>
<tr><td><code>unsigned long long int</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>unsigned long long int</code></td><td><code>number</code>/<code>bigint</code></td><td></td></tr>
<tr><td><code>LONG_LONG_MAX (limits.h)</code></td><td><code>Number.MAX_SAFE_INTEGER</code></td><td></td></tr>
<tr><td><code>float</code></td><td><code>number</code>/<code>bigdecimal</code></td><td></td></tr>
<tr><td><code>double</code></td><td><code>number</code>/<code>bigdecimal</code></td><td></td></tr>
<tr><td></td><td><code>number</code></td><td></td></tr>
<tr><td><code>null</code></td><td><code>null</code></td><td></td></tr>
<tr><td></td><td><code>undefined</code></td><td></td></tr>
<tr><td></td><td></td><td>See note 3.</td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ol>
<li><a href="https://en.cppreference.com/w/c/keyword/char"><code>char</code></a> in C and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#string_type"><code>string</code></a> in JavaScript have different definitions. In C, a <code>char</code> is 1 bytes wide, but in JavaScript, a character is 2 bytes wide and stores the character using the UTF-16 encoding. There is no <code>char</code> type equivalent in JavaScript, only <code>string</code>. For more information, see the <a href="https://en.cppreference.com/w/c/keyword/char">C <code>char</code> documentation</a>.</li>
<li>There are only three number data type in JavaScript, <code>number</code>, which is essentially a floating point number. And the <code>bigint</code> type for storing numbers that exceed the range -(2<sup>53</sup> - 1) (<code>Number.MIN_SAFE_INTEGER</code>) to 2<sup>53</sup> - 1 (<code>Number.MAX_SAFE_INTEGER</code>). and the <code>bigdecimal</code> type for storing high-precision decimals.</li>
<li>For historical reasons, JavaScript has two empty data types: <code>null</code> and <code>undefined</code>. <code>undefined</code> denotes a value that was never created, and null denotes a value that was created but intentionally left empty.
See also:</li>
</ol>
<ul>
<li><a href="https://en.cppreference.com/w/c/keyword">Keywords (C Reference)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<h2 id="encoding-issues-with-c-language-strings"><a class="header" href="#encoding-issues-with-c-language-strings">Encoding issues with C language strings</a></h2>
<p>In computers, characters are stored in binary encoding. A character set is a standard collection of encoded characters. In 1967, the American National Standards Institute (ANSI) released the ASCII character set that only supported the English alphabet, and then various countries and regions created various ASCII-compatible but incompatible character sets based on ASCII. These character sets are collectively known as multi-byte character sets (MBCS). In the 1990s, MBCS was the default standard for C character types and their associated functions. In 1991, the Unicode Consortium was formed to address the incompatibility of character sets, with the aim of creating a unified international character set standard. Initially, Unicode released the UTF-16 encoding standard, which is not ASCII compatible, and it has gradually and slowly gained support from the industry. Microsoft didn't release Windows 2000 with Unicode support until 2000.</p>
<p>However, on the Windows operating system platform, where compatibility is emphasized, the default standard for C character types and their associated functions is still the outdated MBCS (also known as narrow characters, functions end in A in the Windows API) rather than Unicode (at Microsoft, the word Unicode sometimes refers to UTF-16LE in code) (LE stands for Little Endian, which refers to the lower bytes first, The order in which the high-digit bytes are encoded after (also known as wide characters, functions end with W in the Windows API). For compatibility, Windows additionally defines the C character type 'wchar' and its associated functions for UTF-16LE strings, as well as the character type 'TCHAR' for both Unicode and non-Unicode compatibility (functions do not end with a capital A or W in the Windows API) and its related functions. This makes it difficult for Windows programmers.
Later, more advanced UTF-8 encoding was released. Unix-like operating systems (e.g., Linux, FreeBSD), who is not very compatible, changed the default standard for C character types and their associated functions to UTF-8. Due to compatibility, and a lack of emphasis on UTF-8, Windows does not support UTF-8 as a standard for encoding programs internally. Windows programmers are still miserable.</p>
<p>The turning point came in 2015, when Microsoft's new CEO, Satya Nadella, took office, and he launched a strategy to embrace open source software. In the open-source world, people generally use Linux. At this point, character encoding becomes a big problem. So, in 2019, starting with Windows version 1903 (May 2019 Update), you can use manifests to have processes use UTF-8 as process code pages. In order to avoid conflicts with UTF-16LE, Microsoft has modified the MBCS related APIs to do this. But for compatibility reasons, the preferred program internal encoding on Windows is still UTF-16LE. In addition, Microsoft began to develop a terminal "Windows Terminal" that supports Unicode (including UTF-16LE, UTF-8, etc.) to solve this problem. Previously, Windows Terminal did not support Unicode characters.
Now, Windows programmers can finally use UTF-8 as the default standard for C character types and their associated functions, as well as for the internal encoding of programs, by <a href="https://learn.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page">adding a manifest</a>.</p>
<p>There is a character type in C: <code>char</code>.</p>
<p>The mapping of those to JavaScript is shown in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>C</th><th>JavaScript</th><th>Note</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>string</code></td><td>see Note 1.</td></tr>
</tbody></table>
</div>
<p>There are differences in working with strings in C and JavaScript, but the equivalents above should be a good starting point. One of the differences is that C characters are using different encodes, but JavaScript strings are UTF-16 encoded.</p>
<p>Notes:</p>
<ol>
<li>JavaScript has only one string type, <code>string</code>. JavaScript has no pointer types.</li>
</ol>
<p>JavaScript:</p>
<pre><code class="language-js">let str = "Hello, World!"; 
let str = new String("Hello, World!")
</code></pre>
<p>C:</p>
<pre><code class="language-c">char str[]= "Hello, World!"; 
</code></pre>
<h2 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h2>
<p>String literals in JavaScript <code>String</code> types and allocated on the heap. In Rust, they are <code>char</code>, has a global lifetime and does not get allocated on the heap; they're embedded in the compiled binary.
JavaScript:</p>
<pre><code class="language-js">let str = "Hello, World!";
</code></pre>
<p>C:</p>
<pre><code class="language-c">char str[]= "Hello, World!"
</code></pre>
<p>JavaScript verbatim string literals are equivalent to Rust raw string literals.</p>
<p>JavaScript</p>
<pre><code class="language-js">let str = `Hello, \World/!`;
</code></pre>
<p>C</p>
<pre><code class="language-c">char *str = R"(Hello, \World/!)";
</code></pre>
<p>C UTF-8 string literals:</p>
<pre><code class="language-c">char str[] = u8"hello";
</code></pre>
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h2>
<p>JavaScript has a built-in string interpolation feature that allows you to embed expressions inside a string literal. The following example shows how to use string interpolation in JavaScript:</p>
<pre><code class="language-javascript">let name = "John";
let age = 42;
let str = `Person Name: ${name}, Age: ${age} `;
</code></pre>
<p>C does not have a built-in string interpolation feature. Instead, the <code>printf</code> function is used to format a string. The following example shows how to use string interpolation in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char name[] = "John";
    int age = 42;
    printf("Person Name: %s, Age: %d", name, age);
    return 0;
}
</code></pre>
<p>Custom classes and structs can also be interpolated in JavaScript due to the fact that the <code>toString()</code> method is available for each type as it inherits from <code>object</code>.</p>
<pre><code class="language-js">class Person {
    constructor({
        name,
        age
    }) {
        this.name = name;
        this.age = age;
        this.toString = function() {
            return `Person Name: ${name}, Age: ${age}`;
        }
    }

}
let person = new Person({
    name: "John",
    age: 42
});
console.log(person);
</code></pre>
<p>In C, there is no default formatting implemented/inherited for each type. We use structs instead of classes, and function pointers to simulate methods in classes.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    char *name;
    int age;
    char* (*toString)(void);
} Person;

char* Person_toString() {
    return "Person Name: %s, Age: %d";
}

Person* new_Person(char* name, int age) {
    Person* person = (Person*)malloc(sizeof(Person));
    person-&gt;name = name;
    person-&gt;age = age;
    person-&gt;toString = Person_toString;
    return person;
}

int main() {
    Person* person = new_Person("John", 42);
    printf(person-&gt;toString(), person-&gt;name, person-&gt;age);
    free(person);
    return 0;
}

</code></pre>
<h2 id="text-replacing"><a class="header" href="#text-replacing">Text Replacing</a></h2>
<p>C doesn't have a built-in string replacement feature, so replacing strings is very complex in C. Here's the code for a C function to replace a string:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

/**
 * @brief Replace a substring in a string with another substring.
 * @param str The original string.
 * @param find The substring to find.
 * @param replace The substring to replace.
 * @param case_sensitive Flag to indicate case sensitivity (1 for case-sensitive, 0 for case-insensitive).
 * @param global_replace Flag to enable global replacement (1 for global, 0 for first occurrence only).
 * @return The modified string after replacement.
 */
char* replace_str(const char* str, const char* find, const char* replace, int case_sensitive, int global_replace) {
    char* result;
    int i, count = 0;
    int find_len = strlen(find);
    int replace_len = strlen(replace);

    for (i = 0; str[i] != '\0';) {
        if ((case_sensitive ? strncmp(&amp;str[i], find, find_len) : strncasecmp(&amp;str[i], find, find_len)) == 0) {
            count++;
            if (!global_replace) break;
            i += find_len;
        } else {
            i++;
        }
    }

    result = (char*)malloc(strlen(str) + count * (replace_len - find_len) + 1);

    i = 0;
    while (*str) {
        if ((case_sensitive ? strncmp(str, find, find_len) : strncasecmp(str, find, find_len)) == 0) {
            strcpy(&amp;result[i], replace);
            i += replace_len;
            str += find_len;
            if (!global_replace) break;
        } else {
            result[i++] = *str++;
        }
    }
    result[i] = '\0';
    return result;
}

int main() {
    const char* original_str = "Hello, World!";
    const char* find_str = "World";
    const char* replacement_str = "C Language";

    char* new_str = replace_str(original_str, find_str, replacement_str, 0, 1); // Case-insensitive, global replacement
    printf("Original String: %s\n", original_str);
    printf("New String: %s\n", new_str);

    free(new_str);
    return 0;
}
</code></pre>
<!--
Another option is to use the `std::fmt::Debug` trait. The `Debug` trait is implemented for all standard types and can be used to print the internal representation of a type. The following example shows how to use the `derive` attribute to print the internal representation of a custom struct using the `Debug` macro. This declaration is used to automatically implement the `Debug` trait for the `Person` struct:

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: i32,
}

let person = Person {
    name: "John".to_owned(),
    age: 42,
};

println!("{person:?}");
```

> Note: Using the :? format specifier will use the `Debug` trait to print the struct, where leaving it out will use the `Display` trait.

See also:

- [Rust by Example - Debug](https://doc.rust-lang.org/stable/rust-by-example/hello/print/print_debug.html?highlight=derive#debug)
--><div style="break-before: page; page-break-before: always;"></div><h1 id="structured-types"><a class="header" href="#structured-types">Structured Types</a></h1>
<p>Commonly used object and collection types in JavaScript and their mapping to C.</p>
<div class="table-wrapper"><table><thead><tr><th>JavaScript</th><th>C</th></tr></thead><tbody>
<tr><td><code>array</code></td><td>(The type of an array varies with types)</td></tr>
</tbody></table>
</div>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>Fixed arrays are supported the same way in C as in JavaScript.</p>
<p>JavaScript:</p>
<pre><code class="language-js">let someArray = [1,2];
</code></pre>
<p>C:</p>
<pre><code class="language-c">int someArray[2] = {1, 2};
</code></pre>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p>In C the equivalent of a <code>array</code> is an array.</p>
<p>JavaScript:</p>
<pre><code class="language-js">let something = ["a", "b"];
something.push("c");
</code></pre>
<p>c:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
    char **something = malloc(2 * sizeof(char*));
    something[0] = "a";
    something[1] = "b";
    int size = 2;
    
    // Before adding an element
    for (int i = 0; i &lt; size; i++) {
        printf("%s ", something[i]);
    }
    
    // Adding an element
    char *new_element = "c";
    size++;
    char **temp = realloc(something, size * sizeof(char*));
    if (temp != NULL) {
        something = temp;
        something[size - 1] = new_element;
    }
    
    // After adding an element
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%s ", something[i]);
    }
    
    // Release the memory.
    free(something);
    
    return 0;
}
</code></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>JavaScript:</p>
<pre><code class="language-js">const let something = [1, 2];
console.log(`a = ${something[0]} b = ${something[1]}`);
</code></pre>
<p>In C, arrays are used to simulate the concept of tuples:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int something[] = {1, 2};
    printf("a = %d b = %d", something[0], something[1]);
    return 0;
}

// deconstruction supported
#include &lt;stdio.h&gt;

int main() {
    // Define a tuple
    struct Tuple {
        int a;
        int b;
    };

    // Initialize the tuple
    struct Tuple something = {1, 2};

    // Deconstruct tuples
    int a = something.a;
    int b = something.b;
    printf("a = %d b = %d\n", a, b);

    return 0;
}

</code></pre>
<blockquote>
<p><strong>NOTE</strong>: C tuple elements cannot be named. The only way to access a tuple element is by using the index of the element or deconstructing the tuple.</p>
</blockquote>
<h2 id="dictionary"><a class="header" href="#dictionary">Dictionary</a></h2>
<p>In C the equivalent of a <code>Dictionary</code> is a <code>object</code>.</p>
<p>JavaScript:</p>
<pre><code class="language-js">var something = {
    "Foo": "Bar",
    "Baz": "Qux"
};

something["hi"] = "there";
</code></pre>
<p>C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define INITIAL_CAPACITY 2

typedef struct {
    char* key;
    char* value;
} Entry;

typedef struct {
    Entry* entries;
    int capacity;
    int size;
} HashMap;

void insert(HashMap* map, char* key, char* value) {
    if (map-&gt;size &gt;= map-&gt;capacity) {
        map-&gt;capacity *= 2;
        map-&gt;entries = realloc(map-&gt;entries, map-&gt;capacity * sizeof(Entry));
    }
    map-&gt;entries[map-&gt;size].key = strdup(key);
    map-&gt;entries[map-&gt;size].value = strdup(value);
    map-&gt;size++;
}

void printHashMap(HashMap* map) {
    printf("HashMap Contents:\n");
    for (int i = 0; i &lt; map-&gt;size; i++) {
        printf("Key: %s, Value: %s\n", map-&gt;entries[i].key, map-&gt;entries[i].value);
    }
}


int main() {
    HashMap something;
    something.entries = malloc(INITIAL_CAPACITY * sizeof(Entry));
    something.capacity = INITIAL_CAPACITY;
    something.size = 0;

    insert(&amp;something, "Foo", "Bar");
    insert(&amp;something, "Baz", "Qux");
    insert(&amp;something, "hi", "there");

    // Add any other actions here or print the code for the HashMap
    printHashMap(&amp;something); 
    return 0;
}


</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://en.cppreference.com/w/c/language/struct">Struct declaration - C Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<p>The following sections discuss various topics and constructs related to developing custom types:</p>
<ul>
<li><a href="language/custom-types/classes.html">Classes</a></li>
<li><a href="language/custom-types/records.html">Records</a></li>
<li><a href="language/custom-types/structs.html">Structures</a></li>
<li><a href="language/custom-types/interfaces.html">Interfaces</a></li>
<li><a href="language/custom-types/enums.html">Enumeration Types</a></li>
<li><a href="language/custom-types/members.html">Members</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>C doesn't have classes. It only has <a href="language/custom-types/structs.html"><code>struct</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>C doesn't have any construct for authoring records.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures-struct"><a class="header" href="#structures-struct">Structures (<code>struct</code>)</a></h1>
<p>In JavaScript, there is no direct concept of a structure, but you can use objects to model similar structures.
Structures in C:</p>
<ul>
<li>
<p>In C, <code>struct</code> simply defines the data/fields. Developers can encapsulate data by defining structs and manipulating that data with functions, which is similar to impl in rust.</p>
</li>
<li>
<p>They cannot be sub-classed.</p>
</li>
<li>
<p>They are allocated on stack by default.</p>
</li>
</ul>
<p>In C, a <code>struct</code> is the primary construct for modeling any data structure (the other being an <code>enum</code>).</p>
<p>In C, structs do not need to implement traits, as C does not support the concept of traits in object-oriented programming.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Point {
    int x;
    int y;
};

int main() {
    struct Point p;
    p.x = 10;
    p.y = 20;

    printf("Point coordinates: (%d, %d)\n", p.x, p.y);

    return 0;
}
</code></pre>
<p>Value types in JavaScript are usually designed by a developer to be mutable. It's considered best practice speaking semantically, but the language does not prevent designing a <code>struct</code> that makes destructive or in-place modifications.</p>
<p>Since C doesn't have classes and consequently type hierarchies based on sub-classing, shared behaviour is achieved via traits and generics and polymorphism via virtual dispatch using <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a>.</p>
<p>In JavaScript:</p>
<pre><code class="language-js">class Rectangle {
    constructor(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }

    length() {
        return this.y2 - this.y1;
    }

    width() {
        return this.x2 - this.x1;
    }

    top_left() {
        return [this.x1, this.y1];
    }

    bottom_right() {
        return [this.x2, this.y2];
    }

    area() {
        return this.length() * this.width();
    }

    is_square() {
        return this.width() === this.length();
    }

    toString() {
        return `(${this.x1}, ${this.y1}), (${this.x2}, ${this.y2})`;
    }
}

const rect = new Rectangle(0, 0, 4, 4);
console.log(rect.area());
console.log(rect.toString());
</code></pre>
<p>The equivalent in C would be:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x1, y1, x2, y2;
} Rectangle;

int length(Rectangle rect) {
    return rect.y2 - rect.y1;
}

int width(Rectangle rect) {
    return rect.x2 - rect.x1;
}

int area(Rectangle rect) {
    return length(rect) * width(rect);
}

int is_square(Rectangle rect) {
    return width(rect) == length(rect);
}

void display(Rectangle rect) {
    printf("(%d, %d), (%d, %d)\n", rect.x1, rect.y1, rect.x2, rect.y2);
}

int main() {
    Rectangle rect = {0, 0, 4, 4};
    
    printf("Length: %d\n", length(rect));
    printf("Width: %d\n", width(rect));
    printf("Area: %d\n", area(rect));
    printf("Is Square: %s\n", is_square(rect) ? "Yes" : "No");
    
    display(rect);
    
    return 0;
}
</code></pre>
<p>Since there is no inheritance in C, the way a type advertises support for some <em>formatted</em> representation is by defining a struct for Rectangle and a function to print its contents.:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x;
    int y;
    int width;
    int height;
} Rectangle;

void displayRectangle(Rectangle rect) {
    printf("Rectangle = { x: %d, y: %d, width: %d, height: %d }\n", rect.x, rect.y, rect.width, rect.height);
}

int main() {
    Rectangle rect = {12, 34, 56, 78};
    displayRectangle(rect);
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>When creating an interface in C, developers often rely on structures to define the interface's layout. By encapsulating related data fields and function pointers within a structure, C programmers can simulate an interface-like behavior.</p>
<p>Here's a simple example to illustrate how an interface can be introduced in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// Define the interface structure
struct Interface {
    int (*getData)();  // Function pointer for getting data
    void (*displayData)();  // Function pointer for displaying data
};

// Implement functions for the interface
int getDataImplementation() {
    return 42;
}

void displayDataImplementation() {
    printf("Data: %d\n", getDataImplementation());
}

int main() {
    // Create an instance of the interface
    struct Interface myInterface = {getDataImplementation, displayDataImplementation};

    // Utilize the interface functions
    myInterface.displayData();

    return 0;
}
</code></pre>
<p>In this example, the Interface structure defines the layout of the interface with function pointers for getData and displayData. The getDataImplementation and displayDataImplementation functions serve as the concrete implementations of these interface functions.</p>
<p>By instantiating the Interface structure and assigning the appropriate function implementations, developers can achieve a form of interface-like behavior in C. This approach allows for abstraction and modularity in C programming, enabling better code organization and reusability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumeration-types-enum"><a class="header" href="#enumeration-types-enum">Enumeration types (<code>enum</code>)</a></h1>
<p>To convert a C enum to JavaScript, you can represent it using an object with key-value pairs.</p>
<pre><code class="language-js">const DayOfWeek = {
    Sunday: 0,
    Monday: 1,
    Tuesday: 2,
    Wednesday: 3,
    Thursday: 4,
    Friday: 5,
    Saturday: 6
};
</code></pre>
<p>C syntax for doing the same:</p>
<pre><code class="language-c">enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
};
</code></pre>
<p>When dealing with an enum type in C, there is no inherent behavior or predefined functionality associated with instances of the enum.</p>
<p>In C, enums do not have built-in support for coercion to integral values. Developers need to manually implement functions to achieve this behavior. Here is an example of how to achieve similar functionality in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef enum {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6
} DayOfWeek;

int main() {
    DayOfWeek dow = Wednesday;
    printf("Day of week = %d\n", dow);

    if (dow == Friday) {
        printf("Yay! It's the weekend!\n");
    }

    // Coerce to integer
    int dowInt = (int)dow;
    printf("Day of week = %d\n", dowInt);

    // Manually coerce back to DayOfWeek
    DayOfWeek newDow = (DayOfWeek)dowInt;
    printf("Day of week = %d\n", newDow);

    return 0;
}
</code></pre>
<p>In C, enums can be casted manually to integral types and vice versa. This approach gives developers control over the conversion process, similar to the Rust example provided.</p>
<p>In C, to convert an integral type to an enum, one can create a function that maps integral values to an enum:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef enum {
    Sunday = 0,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
} DayOfWeek;

DayOfWeek try_from_i32(int n) {
    if (n &gt;= 0 &amp;&amp; n &lt;= 6) {
        return (DayOfWeek)n;
    } else {
        return -1; // Or any other error code indicating failure
    }
}

int main() {
    DayOfWeek dow = try_from_i32(5);
    if (dow != -1) {
        printf("Day of the week: %d\n", dow);
    } else {
        printf("Error: Invalid day\n");
    }

    dow = try_from_i32(50);
    if (dow != -1) {
        printf("Day of the week: %d\n", dow);
    } else {
        printf("Error: Invalid day\n");
    }

    return 0;
}
</code></pre>
<p>In this C code snippet, the try_from_i32 function maps the integer input to the corresponding DayOfWeek enum value if valid. It handles out-of-range values by returning an error code.</p>
<p>In C, enum types can be utilized to create union types, allowing for different variants to store variant-specific data. This concept is similar to Rust's discriminated union types. Below is an example illustrating the use of enum for union types in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

enum IpAddrTag {
    V4,
    V6
};

struct IpAddrV4 {
    uint8_t octet1;
    uint8_t octet2;
    uint8_t octet3;
    uint8_t octet4;
};

struct IpAddrV6 {
    char address[40]; // Assuming a maximum IPv6 address length
};

union IpAddr {
    struct IpAddrV4 v4;
    struct IpAddrV6 v6;
};

int main() {
    union IpAddr home;
    home.v4.octet1 = 127;
    home.v4.octet2 = 0;
    home.v4.octet3 = 0;
    home.v4.octet4 = 1;

    union IpAddr loopback;
    strcpy(loopback.v6.address, "::1");

    return 0;
}
</code></pre>
<p>This form of <code>enum</code> declaration does not exist in JavaScript, but it can be emulated with classes:</p>
<pre><code class="language-js">class IpAddr {
    constructor(v4, v6) {
        this.v4 = v4;
        this.v6 = v6;
    }
}

const home = new IpAddr([127, 0, 0, 1], null);
const loopback = new IpAddr(null, "::1");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="members"><a class="header" href="#members">Members</a></h1>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>In C programming, constructors are not explicitly defined. Instead, you can achieve similar functionality by using factory functions that create and initialize instances of a struct. These factory functions can be standalone functions or associated functions of the struct. Conventionally, if there is only one factory function for a struct, it is commonly named new.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x1, y1, x2, y2;
} Rectangle;

Rectangle newRectangle(int x1, int y1, int x2, int y2) {
    Rectangle rect;
    rect.x1 = x1;
    rect.y1 = y1;
    rect.x2 = x2;
    rect.y2 = y2;
    return rect;
}

int main() {
    Rectangle myRect = newRectangle(0, 0, 100, 100);
    printf("Rectangle coordinates: (%d, %d), (%d, %d)\n", myRect.x1, myRect.y1, myRect.x2, myRect.y2);
    return 0;
}
</code></pre>
<!--
Since Rust functions (associated or otherwise) do not support overloading; the factory functions have to be named uniquely. For example, below are some examples of so-called constructors or factory functions available on `String`:

- `String::new`: creates an empty string.
- `String::with_capacity`: creates a string with an initial buffer capacity.
- `String::from_utf8`: creates a string from bytes of UTF-8 encoded text.
- `String::from_utf16`: creates a string from bytes of UTF-16 encoded text.

In the case of an `enum` type in Rust, the variants act as the constructors. See [the section on enumeration types][enums] for more.

See also:

- [Constructors are static, inherent methods (C-CTOR)][rs-api-C-CTOR]

  [enums]: enums.md
  [rs-api-C-CTOR]: https://rust-lang.github.io/api-guidelines/predictability.html?highlight=new#constructors-are-static-inherent-methods-c-ctor
-->
<h2 id="methods-static--instance-based"><a class="header" href="#methods-static--instance-based">Methods (static &amp; instance-based)</a></h2>
<p>C types (both <code>enum</code> and <code>struct</code>), can have static and instance-based methods. <!--In Rust-speak, a _method_ is always instance-based and is identified by the fact that its first parameter is named `self`. The `self` parameter has no type annotation since it's always the type to which the method belongs. A static method is called an _associated function_. In the example below, `new` is an associated function and the rest (`length`, `width` and `area`) are methods of the type:--></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x1, y1, x2, y2;
} Rectangle;

Rectangle new_rectangle(int x1, int y1, int x2, int y2) {
    Rectangle rect;
    rect.x1 = x1;
    rect.y1 = y1;
    rect.x2 = x2;
    rect.y2 = y2;
    return rect;
}

int length(Rectangle *rect) {
    return rect-&gt;y2 - rect-&gt;y1;
}

int width(Rectangle *rect) {
    return rect-&gt;x2 - rect-&gt;x1;
}

int area(Rectangle *rect) {
    return length(rect) * width(rect);
}

int main() {
    Rectangle rect = new_rectangle(0, 0, 4, 3);
    printf("Length: %d\n", length(&amp;rect));
    printf("Width: %d\n", width(&amp;rect));
    printf("Area: %d\n", area(&amp;rect));
    return 0;
}
</code></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>A type in C can have constants. However, the most interesting aspect to note is that C allows a type instance to be defined as a constant too:</p>
<pre><code class="language-c">struct Point {
    int x;
    int y;
};

const struct Point ZERO = {0, 0};
</code></pre>
<p>In JavaScript, you need to define a Point class, and then, simulate the construction behavior in Rust by setting a static property ZERO directly on the Point class.</p>
<pre><code class="language-js">class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

Point.ZERO = new Point(0, 0);
</code></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>C has no built-in support for type members to adverstise and fire events.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>In C, there are no built-in properties. To mimic property-like behavior, the user can use getter and setter functions.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x1, y1, x2, y2;
} Rectangle;

Rectangle newRectangle(int x1, int y1, int x2, int y2) {
    Rectangle rect = {x1, y1, x2, y2};
    return rect;
}

// Getter functions
int getX1(Rectangle *rect) { return rect-&gt;x1; }
int getY1(Rectangle *rect) { return rect-&gt;y1; }
int getX2(Rectangle *rect) { return rect-&gt;x2; }
int getY2(Rectangle *rect) { return rect-&gt;y2; }

// Setter functions
void setX1(Rectangle *rect, int val) { rect-&gt;x1 = val; }
void setY1(Rectangle *rect, int val) { rect-&gt;y1 = val; }
void setX2(Rectangle *rect, int val) { rect-&gt;x2 = val; }
void setY2(Rectangle *rect, int val) { rect-&gt;y2 = val; }

// Computed properties
int length(Rectangle *rect) { return rect-&gt;y2 - rect-&gt;y1; }
int width(Rectangle *rect) { return rect-&gt;x2 - rect-&gt;x1; }
int area(Rectangle *rect) { return length(rect) * width(rect); }

int main() {
    Rectangle rect = newRectangle(0, 0, 10, 20);
    printf("Area of the rectangle: %d\n", area(&amp;rect));
    return 0;
}
</code></pre>
<h2 id="extension-methods"><a class="header" href="#extension-methods">Extension Methods</a></h2>
<p>In JavaScript, you can use prototype to add new methods to existing classes. This approach allows you to add new behavior to an existing class without changing the existing class definition:</p>
<pre><code class="language-js">//JavaScript doesn't have a StringBuilder class. This code is only used to demonstrate adding a new method to an existing class.
class StringBuilder {
    constructor(initialString) {
        this.value = initialString;
    }

    toString() {
        return this.value;
    }
}
StringBuilder.prototype.wrap = function (left, right) {
        this.value = left + this.value + right;
    }
const sb = new StringBuilder("Hello, World!");
sb.wrap("&gt;&gt;&gt; ", " &lt;&lt;&lt;");
console.log(sb.toString()); 
</code></pre>
<p>C does not have built-in support for extension methods or traits. To achieve similar functionality in C, one can use function pointers or structures to mimic extension methods. Here's a simplified example in C to demonstrate extending a type with a method:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// Define the StringExt structure before using it.
typedef struct StringExt {
    char* data;
    // The wrap function should take a pointer to StringExt to modify the original structure.
    void (*wrap)(struct StringExt*, const char*, const char*);
} StringExt;

// The wrap function now correctly takes a pointer to a StringExt structure.
void wrap(struct StringExt* self, const char* left, const char* right) {
    if (self == NULL || self-&gt;data == NULL || left == NULL || right == NULL) {
        return; // Safety check to avoid dereferencing NULL pointers.
    }
    // Allocate memory for the new string, including space for the null terminator.
    char* temp = malloc(strlen(left) + strlen(self-&gt;data) + strlen(right) + 1);
    if (temp == NULL) {
        return; // Check for failed memory allocation.
    }
    // Concatenate the strings in the correct order.
    strcpy(temp, left);
    strcat(temp, self-&gt;data);
    strcat(temp, right);
    // Free the old data and update the StringExt structure with the new data.
    free(self-&gt;data);
    self-&gt;data = temp;
}

int main() {
    // Declare the StringExt variable as an actual structure, not just a type.
    StringExt s = { .data = strdup("Hello, World!"), .wrap = wrap };

    // Call the wrap function with the address of the StringExt structure.
    s.wrap(&amp;s, "&gt;&gt;&gt; ", " &lt;&lt;&lt;");
    printf("%s\n", s.data); // Should now print: &gt;&gt;&gt; Hello, World! &lt;&lt;&lt;

    free(s.data); // Free the allocated memory for the data string.
    return 0;
}
</code></pre>
<!--Just like in C#, for the method in the extension trait to become available
(2), the extension trait must be imported (1). Also note, the extension trait identifier `StrWrapExt` can itself be discarded via `_` at the time of import without affecting the availability of `wrap` for `String`.-->
<h2 id="visibilityaccess-modifiers"><a class="header" href="#visibilityaccess-modifiers">Visibility/Access modifiers</a></h2>
<p>In JavaScript, there is no explicit visibility modifiers, but similar functionality can be achieved with some conventions.</p>
<p>In C, visibility and access control are primarily achieved through the use of header files and the concept of translation units. By declaring functions and variables in header files and including them in source files, C provides a way to control visibility. To mimic private members, one can use static variables or functions within a source file, limiting their scope to that file. For public visibility, declaring functions and variables in header files and including those headers in multiple source files allows for shared access. While C lacks explicit modifiers like pub in Rust, the structuring of code using header files and source files provides a similar level of control over visibility and access.</p>
<!--
For more details, see the [Visibility and Privacy][privis] section of The Rust
Reference.

  [privis]: https://doc.rust-lang.org/reference/visibility-and-privacy.html

  <!--

The table below is an approximation of the mapping of C# and Rust modifiers:

| C#                            | Rust         | Note        |
| ----------------------------- | ------------ | ----------- |
| `private`                     | (default)    | See note 1. |
| `protected`                   | N/A          | See note 2. |
| `internal`                    | `pub(crate)` |             |
| `protected internal` (family) | N/A          | See note 2. |
| `public`                      | `pub`        |             |

1. There is no keyword to denote private visibility; it's the default in Rust.

2. Since there are no class-based type hierarchies in Rust, there is no
   equivalent of `protected`.
-->
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>When designing a type in JavaScript, it is not the responsiblity of the developer to decide whether the a type is mutable or immutable; whether it supports destructive or non-destructive mutations. In C, mutability is expressed on methods through the type of the parameters as shown in the example below:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Point {
    int x;
    int y;
};

struct Point new_point(int x, int y) {
    struct Point p;
    p.x = x;
    p.y = y;
    return p;
}

int get_x(struct Point *p) {
    return p-&gt;x;
}

int get_y(struct Point *p) {
    return p-&gt;y;
}

void set_x(struct Point *p, int val) {
    p-&gt;x = val;
}

void set_y(struct Point *p, int val) {
    p-&gt;y = val;
}

int main() {
    struct Point p = new_point(3, 4);
    printf("Point coordinates: (%d, %d)\n", get_x(&amp;p), get_y(&amp;p));
    set_x(&amp;p, 7);
    set_y(&amp;p, 8);
    printf("Updated point coordinates: (%d, %d)\n", get_x(&amp;p), get_y(&amp;p));
    return 0;
}

</code></pre>
<p>In JavaScript, use ES6's destructuring assignment and object extension syntax to implement non-destructive mutation:</p>
<pre><code class="language-js">class Point {
    constructor(X, Y) {
        this.X = X;
        this.Y = Y;
    }
}

let pt = new Point(123, 456);
pt = { ...pt, X: 789 };
console.log(pt); // prints: Point { X = 789, Y = 456 }
</code></pre>
<p>There is no <code>with</code> in C, but to emulate something similar in C, it has to be baked into the type's design:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x;
    int y;
} Point;

Point new_point(int x, int y) {
    Point p;
    p.x = x;
    p.y = y;
    return p;
}

int get_x(Point p) {
    return p.x;
}

int get_y(Point p) {
    return p.y;
}

Point set_x(Point p, int val) {
    p.x = val;
    return p;
}

Point set_y(Point p, int val) {
    p.y = val;
    return p;
}

int main() {
    Point p = new_point(3, 4);
    printf("Initial Point: x=%d, y=%d\n", get_x(p), get_y(p));

    p = set_x(p, 7);
    p = set_y(p, 9);
    printf("Modified Point: x=%d, y=%d\n", get_x(p), get_y(p));

    return 0;
}
</code></pre>
<p>In JavaScript, classes are used to simulate structs, and destructuring objects is assigned to implement something like <code>with</code>.</p>
<pre><code class="language-js">class Point {
    constructor(x, y) {
        this.X = x;
        this.Y = y;
    }

    toString() {
        return `(${this.X}, ${this.Y})`;
    }
}

let pt = new Point(123, 456);
console.log(pt.toString()); // prints: (123, 456)
pt = { ...pt, X: 789 };
console.log(pt.toString()); // prints: (789, 456)

</code></pre>
<p>C has another syntax that may seem similar:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x;
    int y;
} Point;

Point createPoint(int x, int y) {
    Point pt;
    pt.x = x;
    pt.y = y;
    return pt;
}

void printPoint(Point pt) {
    printf("Point { x: %d, y: %d }\n", pt.x, pt.y);
}

Point set_x(Point p, int val) {
    p.x = val;
    return p;
}

Point set_y(Point p, int val) {
    p.y = val;
    return p;
}

int get_x(Point p) {
    return p.x;
}

int get_y(Point p) {
    return p.y;
}

int main() {
    Point p = createPoint(3, 4);
    printf("Initial Point: x=%d, y=%d\n", get_x(p), get_y(p));

    p = set_x(p, 7);
    p = set_y(p, 9);
    printf("Modified Point: x=%d, y=%d\n", get_x(p), get_y(p));

    return 0;
}
</code></pre>
<!--However, while `with` in C# does a non-destructive mutation (copy then update), the [struct update syntax] does (partial) _moves_ and works with fields only. Since the syntax requires access to the type's fields, it is generally more common to use it within the Rust module that has access to private details of its types.

  [struct update syntax]: https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
--><div style="break-before: page; page-break-before: always;"></div><h1 id="local-functions"><a class="header" href="#local-functions">Local Functions</a></h1>
<p>C offer local functions,but C functions cannot use variables from their surrounding lexical scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-and-closures"><a class="header" href="#lambda-and-closures">Lambda and Closures</a></h1>
<p>C does not directly support higher-order functions. However, function pointers in C can be used to achieve similar behavior.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef int (*func_ptr)(int);

int do_twice(func_ptr f, int arg) {
    return f(arg) + f(arg);
}

int add_one(int x) {
    return x + 1;
}

int main() {
    int answer = do_twice(add_one, 5);
    printf("The answer is: %d\n", answer); // Prints: The answer is: 12
    return 0;
}
</code></pre>
<p>In JavaScript:</p>
<pre><code class="language-js">function doTwice(f, arg) {
    return f(arg) + f(arg);
}

function main() {
    const answer = doTwice(x =&gt; x + 1, 5);
    console.log(`The answer is: ${answer}`); // Prints: The answer is: 12
}

main();

</code></pre>
<p>In C programming, closures can be simulated using function pointers and structures. By encapsulating data and functions within a structure, C can achieve a form of closures. This approach allows functions to access variables from their enclosing scope even after the scope has exited. The structure holds the data and function pointers, enabling the functions to operate on the enclosed data. While C does not have native closure support like some other languages, this workaround provides a mechanism for achieving similar functionality. By leveraging function pointers and structures, C programmers can implement closures effectively within their code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Consider the following example around variable assignment in JavaScript:</p>
<pre><code class="language-js">let x = 5;
</code></pre>
<p>And the same in C:</p>
<pre><code class="language-c">int x = 5;
</code></pre>
<p>C is not type-safe: the compiler guarantees that the value stored in a variable is always of the designated type. The example can be simplified by using the compiler's ability to automatically infer the types of the variable. In JavaScript:</p>
<pre><code class="language-js">let x = 5;
</code></pre>
<p>In C:</p>
<pre><code class="language-c">auto x = 5;
</code></pre>
<p>When expanding the first example to update the value of the variable (reassignment), the behavior of JavaScript and Rust differ:</p>
<pre><code class="language-js">let x = 5;
x = 6;
console.log(x); // 6
</code></pre>
<p>In C, the identical statement will compile:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int x = 5;
    x = 6; // Variable 'x' is mutable in C
    printf("%d", x);
    return 0;
}
</code></pre>
<p>In C, variables are <em>mutable</em> by default. Once a value is bound to a name, the variable's value can be changed:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int x = 5;
    x = 6;
    printf("%d", x);
    return 0;
}
</code></pre>
<p>In C, the concept of variable shadowing is not directly supported. However, a similar effect can be achieved by declaring a new variable with the same name in a nested scope:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int x = 5;
    {
        int x = 6;
        printf("%d", x); // Output: 6
    }
    return 0;
}
</code></pre>
<p>JavaScript also supports shadowing, e.g. locals can shadow fields and type members can shadow members from the base type. In Rust, the above example demonstrates that shadowing also allows to change the type of a variable without changing the name, which is useful if one wants to transform the data into different types and shapes without having to come up with a distinct name each time.</p>
<p>See also:</p>
<ul>
<li><a href="https://stanford-cs242.github.io/f18/lectures/06-2-concurrency.html">Data races and race conditions</a> for more information around the implications
of mutability</li>
<li>[Scope and shadowing]</li>
<li><a href="language/../memory-management/index.html">Memory management</a> for explanations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>In JavaScript, there is no such thing as a namespace. Instead, JavaScript developers use sub-objects or conventions to implement namespace-like functionality.</p>
<p>In C, there is no direct support for namespaces like in C++. However, it is possible to achieve a similar effect by using a naming convention to simulate namespaces. One common approach is to prefix your functions and variables with a unique identifier to mimic the behavior of namespaces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality"><a class="header" href="#equality">Equality</a></h1>
<p>When comparing for equality in JavaScript, this refers to testing for <em>equivalence</em> insome cases (also known as <em>value equality</em>), and in other cases it refers to testing for <em>reference equality</em>, which tests whether two variables refer to the same underlying object in memory. In JavaScript, while there is no syntax for explicitly custom types, custom types can be simulated through constructors and prototypes. Constructors allow you to create objects with specific properties and methods, and you can use prototypes to implement inheritance and shared methods. Every "custom type" can be compared for equality because it inherits from <code>object</code>.</p>
<p>For example, when comparing for equivalence and reference equality in JavaScript:</p>
<pre><code class="language-js">class Point {
    constructor(X, Y) {
        this.X = X;
        this.Y = Y;
    }
    
    equals(other) {
        return this.X === other.X &amp;&amp; this.Y === other.Y;
    }
}

const a = new Point(1, 2);
const b = new Point(1, 2);
const c = a;

console.log(a.equals(b)); // (1) true
console.log(a.equals(new Point(2, 2))); // (1) false
console.log(a === b); // (2) false
console.log(a === c); // (2) true
</code></pre>
<ol>
<li>In JavaScript, classes are used to implement equals methods to compare the equality of values.</li>
<li>For the comparison of reference equality, using the === operator to check if the variable points to the same object in memory.</li>
</ol>
<p>Equivalently in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x;
    int y;
} Point;

int point_equals(Point a, Point b) {
    return a.x == b.x &amp;&amp; a.y == b.y;
}

int main() {
    Point a = {1, 2};
    Point b = {1, 2};
    Point c = a;

    printf("%d\n", point_equals(a, b)); // true
    printf("%d\n", point_equals(a, b)); // true
    printf("%d\n", point_equals(a, (Point){2, 2})); // false
    printf("%d\n", point_equals(a, c)); // true

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics provide a way to create definitions for types and methods that can be parameterized over other types. This improves code reuse, type-safety and performance (e.g. avoid run-time casts). Consider the following example of a generic type that adds a timestamp to any value. However, JavaScript does not have the concept of generics.</p>
<pre><code class="language-js">class Timestamped {
    constructor(value) {
        this.Timestamp = new Date();
        this.Value = value;
    }
}

</code></pre>
<p>C does not have built-in support for generics. In C, preprocessor macros or void pointers are typically used to achieve a similar effect.</p>
<p>Here's a simplified example in C that mimics the Rust code using a void pointer to achieve a generic-like behavior:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

typedef struct {
    void* value;
    time_t timestamp;
} Timestamped;

Timestamped new(void* value) {
    Timestamped ts;
    ts.value = value;
    ts.timestamp = time(NULL);
    return ts;
}

int main() {
    int intValue = 42;
    Timestamped intTimestamped = new(&amp;intValue);

    char charValue = 'A';
    Timestamped charTimestamped = new(&amp;charValue);

    return 0;
}
</code></pre>
<h2 id="generic-type-constraints"><a class="header" href="#generic-type-constraints">Generic type constraints</a></h2>
<p>JavaScript has no concept of generics, and it is a weakly typed scripting language that makes it impossible to add type constraints to it.</p>
<pre><code class="language-js">class Timestamped {
    constructor(value) {
        this.value = value;
        this.timestamp = Date.now();
    }

    equals(other) {
        return this.value === other.value &amp;&amp; this.timestamp === other.timestamp;
    }
}
</code></pre>
<p>The same can be achieved in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

typedef struct {
    void* value;
    time_t timestamp;
} Timestamped;

Timestamped new(void* value) {
    Timestamped ts;
    ts.value = value;
    ts.timestamp = time(NULL);
    return ts;
}

int equal(Timestamped* ts1, Timestamped* ts2) {
    return ts1-&gt;value == ts2-&gt;value &amp;&amp; ts1-&gt;timestamp == ts2-&gt;timestamp;
}

int main() {
    void* val = NULL;
    Timestamped ts1 = new(val);
    Timestamped ts2 = new(val);

    if (equal(&amp;ts1, &amp;ts2)) {
        printf("Timestamped values are equal.\n");
    } else {
        printf("Timestamped values are not equal.\n");
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>C does not support classes and sub-classing therefore polymorphism can't be achieved in an identical manner to JavaScript.</p>
<p>See also:</p>
<ul>
<li>Virtual dispatch using <em>trait objects</em>, as explained in the <a href="language/./custom-types/structs.html">Structures</a>
section</li>
<li><a href="language/./generics.html">Generics</a></li>
<li><a href="language/./inheritance.html">Inheritance</a></li>
<li><a href="language/./operator-overloading.html">Operator overloading</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h1>
<p>As explained in <a href="language/./custom-types/structs.html">structures</a> section, C does not provide (class-based) inheritance. In C, there is no direct support for traits or supertraits. To achieve similar functionality in C, one can use structures and function pointers. By defining a structure that holds function pointers to shared behaviors and then implementing those behaviors in separate functions, one can simulate trait-like behavior in C. This approach allows for defining relationships between different structs by sharing common behavior through function pointers within the structs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h1>
<p>In JavaScript, an exception should always be an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error"><code>Error</code></a> object or an instance of an <code>Error</code> subclass. Exceptions are thrown if a problem occurs in a code section. A thrown exception is passed up the stack until the application handles it or the program terminates.</p>
<p>In C, error handling is typically done using return values or error codes. To convert the Rust code snippet provided to C, one would need to implement error handling using return values or custom error structures.</p>
<h2 id="custom-error-types"><a class="header" href="#custom-error-types">Custom error types</a></h2>
<p>An example on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error">how to create user-defined exceptions</a>:</p>
<pre><code class="language-js">class EmployeeListNotFoundException extends Error {
    constructor(message) {
        super(message);
        this.name = 'EmployeeListNotFoundException';
    }
}
</code></pre>
<p>In C, one can achieve similar error handling by defining custom error structures and functions.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    const char* message;
} EmployeeListNotFound;

const char* EmployeeListNotFound_message(EmployeeListNotFound* err) {
    return err-&gt;message;
}

void EmployeeListNotFound_free(EmployeeListNotFound* err) {
    free(err);
}

int main() {
    EmployeeListNotFound* err = (EmployeeListNotFound*)malloc(sizeof(EmployeeListNotFound));
    err-&gt;message = "Could not find employee list.";

    // Example usage
    printf("%s\n", EmployeeListNotFound_message(err));

    EmployeeListNotFound_free(err);

    return 0;
}
</code></pre>
<p>In C, the equivalent of the JavaScript <code>Error.cause</code> property can be achieved by defining a custom error structure that includes a field to store the error cause or source. Here is a simplified example:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    const char* cause; // Field to store the error cause/source
} Error;

int main() {
    Error customError;
    customError.cause = "Custom error message";
    
    printf("Error Cause: %s\n", customError.cause);
    
    return 0;
}
</code></pre>
<h2 id="raising-exceptions"><a class="header" href="#raising-exceptions">Raising exceptions</a></h2>
<p>To raise an error in JavaScript, throw an error:</p>
<pre><code class="language-js">function throwIfNegative(value) {
    if (value &lt; 0) {
        throw new Error('Value cannot be negative');
    }
}

</code></pre>
<p>To mimic recoverable errors in C, an enum is used to define custom result types. The function error_if_negative checks if the input value is negative and returns the appropriate result. The main function demonstrates how to use this error handling mechanism in C.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef enum {
    OK,
    ERR
} Result;

Result error_if_negative(int value) {
    if (value &lt; 0) {
        return ERR;
    } else {
        return OK;
    }
}

int main() {
    int input = -5;
    Result result = error_if_negative(input);

    if (result == ERR) {
        printf("Error: Specified argument was out of the range of valid values. (Parameter 'value')\n");
    } else {
        printf("No error. Value is non-negative.\n");
    }

    return 0;
}
</code></pre>
<p>In C, a way to handle unrecoverable errors is typically achieved using the abort() function from the <code>&lt;stdlib.h&gt;</code> library.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void panic_if_negative(int value) {
    if (value &lt; 0) {
        fprintf(stderr, "Specified argument was out of the range of valid values. (Parameter 'value')\n");
        abort();
    }
}

int main() {
    //Main code logic here
    return 0;
}
</code></pre>
<h2 id="error-propagation"><a class="header" href="#error-propagation">Error propagation</a></h2>
<p>In JavaScript, exceptions are passed up until they are handled or the program terminates. In Rust, unrecoverable errors behave similarly, but handling them is uncommon.</p>
<p>Recoverable errors, however, need to be propagated and handled explicitly. Their presence is always indicated by the Rust function or method signature. Catching an exception allows you to take action based on the presence or absence of an error in JavaScript:</p>
<pre><code class="language-js">//JavaScript doesn't have a file system in it. People often implement file systems using the BrowserFS library that mimic Node.js APIs.
function write() {
    try {
        fs.writeFileSync('file.txt', 'content');
    } catch (error) {
        console.log('Writing to file failed.');
    }
}

</code></pre>
<p>In C, error handling is typically done using return values rather than exceptions. One would need to use functions that return error codes to indicate success or failure instead of throwing exceptions.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int write() {
    FILE *file = fopen("file.txt", "w");
    if (file == NULL) {
        printf("Error opening file.\n");
        return -1; // Return an error code
    }

    if (fprintf(file, "content") &lt; 0) {
        printf("Error writing to file.\n");
        fclose(file);
        return -2; // Return a different error code
    }

    fclose(file);
    return 0; // Return 0 for success
}

int main() {
    int result = write();
    if (result != 0) {
        printf("Writing to file failed.\n");
    }
    return 0;
}
</code></pre>
<p>C does not have a built-in operator like Rust's ? for error propagation. In C, error handling is typically done using return values or error codes.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    FILE *file = fopen("file.txt", "w");
    if (file == NULL) {
        perror("Error opening file");
        return -1; // Error code for file opening failure
    }

    if (fwrite("content", sizeof(char), 7, file) != 7) {
        perror("Error writing to file");
        fclose(file);
        return -2; // Error code for incomplete write
    }

    fclose(file);
    return 0; // Success
}
</code></pre>
<h2 id="stack-traces"><a class="header" href="#stack-traces">Stack traces</a></h2>
<!--Throwing an unhandled exception in .NET will cause the runtime to print a stack
trace that allows debugging the problem with additional context.-->
<p>In C, handling unrecoverable errors can be achieved using the abort() function, which terminates the program immediately. For recoverable errors, C does not have built-in support for backtraces. However, it is possible to implement a basic form of error handling using return codes or custom error structures to indicate and handle errors in a recoverable manner. To backtrace, developers often resort to manual logging or stack tracing techniques in C.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullability-and-optionality"><a class="header" href="#nullability-and-optionality">Nullability and Optionality</a></h1>
<p>In JavaScript, <code>null</code> is often used to represent a value that is missing, absent or logically uninitialized. For example:</p>
<pre><code class="language-js">let some = 1;
let none = null;
</code></pre>
<p>Rust has no <code>null</code> and consequently no nullable context to enable. Optional or missing values are instead represented by [<code>Option&lt;T&gt;</code>][option]. The equivalent of the JavaScript code above in Rust would be:</p>
<pre><code class="language-c">#include &lt;stddef.h&gt;
//...
int some = 1;
int *none = NULL;
</code></pre>
<h2 id="control-flow-with-optionality"><a class="header" href="#control-flow-with-optionality">Control flow with optionality</a></h2>
<p>In JavaScript, you may have been using <code>if</code>/<code>else</code> statements for controlling the flow when using nullable values.</p>
<pre><code class="language-js">let max = 10;
if (max !== null &amp;&amp; max !== undefined) {
    let someMax = max;
    console.log(`The maximum is ${someMax}.`); // OutputÔºöThe maximum is 10.
}
</code></pre>
<p>C does not have built-in support for null or undefined values like JavaScript. Instead, it typically uses specific values or flags to indicate absence or special conditions:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int max = 10;
    if (max != 0) {
        int someMax = max;
        printf("The maximum is %d.\n", someMax); // Output: The maximum is 10.
    }
    return 0;
}
</code></pre>
<h2 id="null-conditional-operators"><a class="header" href="#null-conditional-operators">Null-conditional operators</a></h2>
<p>The null-conditional operators (<code>?.</code>) make dealing with <code>null</code> in JavaScript more ergonomic.</p>
<p>In C language, there is no direct equivalent to the null-conditional operator ?. found in JavaScript. To handle similar scenarios in C, one can use conditional statements to check for null pointers before accessing members.</p>
<pre><code class="language-js">let some = "Hello, World!";
let none = null;
console.log(some?.length); // 13
console.log(none?.length); // undefined
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char* some = "Hello, World!";
    char* none = NULL;

    printf("%d\n", (some != NULL) ? (int)strlen(some) : -1);
    printf("%d\n", (none != NULL) ? (int)strlen(none) : -1);

    return 0;
}
</code></pre>
<h2 id="null-coalescing-operator"><a class="header" href="#null-coalescing-operator">Null-coalescing operator</a></h2>
<p>The null-coalescing operator (<code>??</code>) is typically used to default to another value when a nullable is <code>null</code>:</p>
<pre><code class="language-js">let some = 1;
let none = null;
console.log(some ?? 0); // 1
console.log(none ?? 0); // 0
</code></pre>
<p>In C, there is no direct equivalent to the null-coalescing operator (??) as in JavaScript. However, it is possible to achieve similar functionality using conditional operators.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int some = 1;
    int *none = NULL;
    
    printf("%d\n", some); // 1
    printf("%d\n", none != NULL ? *none : 0); // 0
    
    return 0;
}
</code></pre>
<h2 id="null-forgiving-operator"><a class="header" href="#null-forgiving-operator">Null-forgiving operator</a></h2>
<p>In C, there is no direct equivalent to the null-forgiving operator (!) found in languages like C# or Rust. To handle null pointers or avoid null references, C programmers typically use conditional statements or pointer checks to ensure safe memory access. Unlike Rust, C does not have built-in mechanisms for static flow analysis to handle null values implicitly. Therefore, developers need to implement explicit null checks and error handling in C code to manage potential null pointer exceptions effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discards"><a class="header" href="#discards">Discards</a></h1>
<p>Discards express to the compiler and others to ignore the results (or parts) of an expression.</p>
<p>There are multiple contexts where to apply this, for example as a basic example, to ignore the result of an expression. JavaScript doesn't have discards, but you can call a function without assigning a value to any variable to emulate discards. In JavaScript this looks like:</p>
<pre><code class="language-js">city.getCityInformation(cityName);
</code></pre>
<p>In C, discarding the result of a function call is typically achieved by assigning the result to a variable and not using that variable further. In C, casting the result to (void) indicates to the compiler that the return value is intentionally being ignored.</p>
<pre><code class="language-c">(void)city_get_city_information(city_name);
</code></pre>
<p>Discards are also applied for deconstructing "tuples" in JavaScript:</p>
<pre><code class="language-js">const [_, second] = ["first", "second"];
</code></pre>
<p>In C, tuple deconstruction like in JavaScript can be achieved using a similar approach. However, C does not have built-in tuple types like JavaScript. To mimic tuple deconstruction, one can use arrays or structures:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char* values[] = {"first", "second"};
    char* second = values[1];

    printf("Second value: %s\n", second);

    return 0;
}
</code></pre>
<p>To achieve struct destructuring similar to Rust in C, one can use a similar approach by defining a struct and then accessing its members selectively.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Point {
    int x;
    int y;
    int z;
};

int main() {
    struct Point origin = {0, 0, 0};

    switch (origin.x) {
        case 0:
            printf("x is %d\n", origin.x);
            break;
    }

    return 0;
}
</code></pre>
<p>When pattern matching, it is often useful to discard or ignore part of a matching expression. But since there are no discards in JavaScript, and the switch statement of js cannot be used in the same way as rust, you have to emulate this feature in an awkward way:</p>
<pre><code class="language-js">const _ = ("first", "second");
const result = (_ =&gt; {
    switch(true) {
        case _.includes("first"):
            return "first element matched";
        default:
            return "first element did not match";
    }
})();

console.log(result);
</code></pre>
<p>and again, in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    const char* first = "first";
    const char* second = "second";
    const char* result;

    if (strcmp(first, "first") == 0) {
        result = "first element matched";
    } else {
        result = "first element did not match";
    }

    printf("%s\n", result);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversion-and-casting"><a class="header" href="#conversion-and-casting">Conversion and Casting</a></h1>
<p>C is statically-typed at compile time. Hence, after a variable is declared, assigning a value of a value of a different type (unless it's implicitly convertible to the target type) to the variable is prohibited. There are several ways to convert types in C.</p>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>Implicit conversions exist in JavaScript as well as in C (called <a href="https://www.geeksforgeeks.org/type-conversion-c/">type coercions</a>).
Consider the following example:</p>
<pre><code class="language-js">let intNumber = 1;
let longNumber = intNumber;
</code></pre>
<p>In C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int int_number = 1;
    long long_number = int_number; // No error in C
    printf("int_number: %d, long_number: %ld\n", int_number, long_number);
    return 0;
}
</code></pre>
<p>By assigning the address of s to t, it is possible to achieve a similar implicit conversion in C:</p>
<pre><code class="language-rust">void bar() {
    const char *s = "hi";
    const char *t = s;
}</code></pre>
<p>See also:</p>
<ul>
<li>[Deref coercion]</li>
</ul>
<h2 id="explicit-conversions"><a class="header" href="#explicit-conversions">Explicit conversions</a></h2>
<p>If converting could cause a loss of information, JavaScript requires explicit
conversions using a casting expression:</p>
<pre><code class="language-js">let a = 1.2;
let b = parseInt(a);
</code></pre>
<p>C does not handle exceptions during conversions:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int int_number = 1;
    long long_number = (long)int_number;
    
    // Additional code for demonstration
    printf("Integer: %d\n", int_number);
    printf("Long: %ld\n", long_number);
    
    return 0;
}
</code></pre>
<h2 id="custom-conversion"><a class="header" href="#custom-conversion">Custom conversion</a></h2>
<p>In C, type conversion is typically achieved through explicit casting:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

typedef struct {
    char value[100];
} MyId;

void fromMyIdToString(MyId myId, char* result) {
    strcpy(result, myId.value);
}

int main() {
    MyId myId;
    strcpy(myId.value, "id");

    char result[100];
    fromMyIdToString(myId, result);

    printf("%s\n", result);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator overloading</a></h1>
<p>JavaScript doesn't support operator overloading. Consider the following example in JavaScript:</p>
<pre><code class="language-js">class Fraction {
    constructor(numerator, denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
    }

    static add(a, b) {
        return new Fraction(a.numerator * b.denominator + b.numerator * a.denominator, a.denominator * b.denominator);
    }

    toString() {
        return `${this.numerator}/${this.denominator}`;
    }
}

console.log(Fraction.add(new Fraction(5, 4), new Fraction(1, 2)).toString());  // Output "14/8"
</code></pre>
<p>In C, operator overloading is not directly supported. However, it is possible to achieve similar functionality by defining functions that mimic operator behavior.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int numerator;
    int denominator;
} Fraction;

Fraction addFractions(Fraction f1, Fraction f2) {
    Fraction result;
    result.numerator = f1.numerator * f2.denominator + f2.numerator * f1.denominator;
    result.denominator = f1.denominator * f2.denominator;
    return result;
}

int main() {
    Fraction f1 = {5, 4};
    Fraction f2 = {1, 2};
    
    Fraction result = addFractions(f1, f2);
    
    printf("%d/%d\n", result.numerator, result.denominator); // Output: 14/8
    
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-comments"><a class="header" href="#documentation-comments">Documentation Comments</a></h1>
<p>A third-party tool called JSDoc provides a mechanism to document the API for types using a comment syntax. JSDoc includes a Markdown plugin that automatically converts Markdown-formatted text to HTML. The comment contains structured data representing the comments and the API signatures. Other tools can process that output to provide human-readable documentation in a different form. A simple example in JavaScript:</p>
<pre><code class="language-js">public class MyClass {}
/**
 * This is a document comment for `MyClass`.
 * @class
 */
class MyClass {}
</code></pre>
<p>C lacks a standardized way to generate documentation from comments like JSDoc, developers can adopt tools like Doxygen to extract structured comments and generate documentation from C code. Doxygen interprets specially formatted comments to produce documentation.Doxygen serves as the tool for generating documentation. In C, Doxygen uses a specific syntax to create documentation comments. For instance, in C using Doxygen:</p>
<pre><code class="language-c">/* 
 * This is a comment for the MyStruct struct.
 */
struct MyStruct {
    // Members of the struct
};
</code></pre>
<p>In JSDoc, the equivalent to Doxygen is <code>jsdoc</code>.</p>
<p>See also:</p>
<ul>
<li><a href="https://www.doxygen.nl/manual/docblocks.html">How to write documentation</a></li>
<li>[Documentation tests]</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>In C, memory management is a crucial aspect of programming as it allows developers to allocate and deallocate memory dynamically. Unlike high-level languages with built-in garbage collection mechanisms, C requires manual memory management.</p>
<p>In JavaScript, there is no concept of ownership of memory beyond the GC roots (static fields, local variables on a thread's stack, CPU registers, handles, etc.). It is the GC that walks from the roots during a collection to detemine all memory in use by following references and purging the rest. When designing types and writing code, a JavaScript developer can remain oblivious to ownership, memory management and even how the garbage collector works for the most part, except when performance-sensitive code requires paying attention to the amount and rate at which objects are being allocated on the heap. In contrast, Rust's ownership rules require the developer to explicitly think and express ownership at all times and it impacts everything from the design of functions, types, data structures to how the code is written. On top of that, Rust has strict rules about how data is used such that it can identify at compile-time, data [race conditions] as well as corruption issues (requiring thread-safety) that could potentially occur at run-time. This section will only focus on memory management and ownership.</p>
<p>In C, developers need to manage memory explicitly.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Point {
    int x;
    int y;
};

int main() {
    struct Point* a = (struct Point*)malloc(sizeof(struct Point));
    a-&gt;x = 12;
    a-&gt;y = 34;

    struct Point* b = a; // b now points to the same memory as a

    printf("%d, %d\n", a-&gt;x, a-&gt;y);

    free(a); // Freeing the memory explicitly

    return 0;
}
</code></pre>
<p>In C, there is no explicit concept of ownership. When a is assigned to b, a copy of the Point struct is made, and both a and b can be used independently. Memory management in C is manual, and there is no automatic dropping of resources like in Rust. Therefore, in the C version, the point behind b is not explicitly dropped as in Rust.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x;
    int y;
} Point;

int main() {
    Point a = {12, 34}; // point owned by a
    Point b = a;        // b owns the point now
    printf("%d, %d\n", b.x, b.y); // ok, uses b
    return 0;
} // point behind b is not explicitly dropped in C
</code></pre>
<p>In C, the equivalent concept to execute code when an instance is dropped is typically achieved using a combination of a struct and functions.</p>
<p>In C, the concept of dropping an object, can be achieved through manual memory management.</p>
<p>In C, a static variable retains its value throughout the program's execution.</p>
<p>In JavaScript, references are shared freely without much thought.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Point {
    int x;
    int y;
};

void point_drop(struct Point* self) {
    printf("Point dropped!\n");
    free(self);
}

int main() {
    struct Point* a = (struct Point*)malloc(sizeof(struct Point));
    a-&gt;x = 12;
    a-&gt;y = 34;

    struct Point* b = a; // share with b
    printf("a = %d, %d\n", a-&gt;x, a-&gt;y); // okay to use a
    printf("b = %d, %d\n", b-&gt;x, b-&gt;y);

    point_drop(a);
    return 0;
}

// prints:
// a = 12, 34
// b = 12, 34
// Point dropped!
</code></pre>
<p>In C, there are no smart pointers. The equivalent concept in C would involve manual memory management using functions like malloc and free.</p>
<pre><code class="language-c">struct Point {
    int x;
    int y;
};

struct Point* stack_point = (struct Point*)malloc(sizeof(struct Point));
stack_point-&gt;x = 12;
stack_point-&gt;y = 34;

struct Point* heap_point = (struct Point*)malloc(sizeof(struct Point));
heap_point-&gt;x = 12;
heap_point-&gt;y = 34;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h1>
<p>Previous section on <a href="resource-management/../memory-management/index.html">memory management</a> explains the differences between JavaScript and C when it comes to GC. It is highly recommended to read it.</p>
<p>This section is limited to providing an example of a fictional <em>database connection</em> involving a SQL connection to be properly closed/disposed/dropped.</p>
<pre><code class="language-js">class DatabaseConnection {
    constructor(connectionString) {
        this.connectionString = connectionString;
    }

    closeConnection() {
        // Implementation to close the connection
    }
}

// ...closing connection...
DatabaseConnection.prototype.close = function() {
    this.closeConnection();
    console.log(`Closing connection: ${this.connectionString}`);
};

// Create instances of DatabaseConnection
const db1 = new DatabaseConnection("Server=A;Database=DB1");
const db2 = new DatabaseConnection("Server=A;Database=DB2");

// ...code for making use of the database connection...
// "Dispose" of "db1" and "db2" when their scope ends
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Define a structure to represent DatabaseConnection
typedef struct {
    char* connectionString;
} DatabaseConnection;

// Function to create a new DatabaseConnection instance
DatabaseConnection* createDatabaseConnection(const char* connectionString) {
    DatabaseConnection* db = (DatabaseConnection*)malloc(sizeof(DatabaseConnection));
    db-&gt;connectionString = strdup(connectionString);
    return db;
}

// Function to close the connection
void closeConnection(DatabaseConnection* db) {
    // Implementation to close the connection
    printf("Closing connection: %s\n", db-&gt;connectionString);
    free(db-&gt;connectionString);
    free(db);
}

int main() {
    // Create instances of DatabaseConnection
    DatabaseConnection* db1 = createDatabaseConnection("Server=A;Database=DB1");
    DatabaseConnection* db2 = createDatabaseConnection("Server=A;Database=DB2");

    // ...code for making use of the database connection...

    // "Dispose" of "db1" and "db2" when their scope ends
    closeConnection(db1);
    closeConnection(db2);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threading"><a class="header" href="#threading">Threading</a></h1>
<p>The C standard library supports threading, synchronisation and concurrency. Also the language itself and the standard library do have basic support for the concepts, a lot of additional functionality is provided by third party libraries and will not be covered in this document.</p>
<p>For threading in C, the pthread library is commonly used:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt; // Requires GCC

void *thread_function(void *arg) {
    // Thread logic here
    return NULL;
}

int main() {
    pthread_t thread_id;
    pthread_create(&amp;thread_id, NULL, thread_function, NULL);
    
    // Main program logic here
    
    pthread_join(thread_id, NULL);
    
    return 0;
}
</code></pre>
<p>For synchronization and concurrency in C, mechanisms like mutexes and semaphores can be utilized. Here is a basic example using a mutex for synchronization:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt; // Requires GCC

pthread_mutex_t mutex;

void *thread_function(void *arg) {
    pthread_mutex_lock(&amp;mutex);
    
    // Critical section
    
    pthread_mutex_unlock(&amp;mutex);
    return NULL;
}

int main() {
    pthread_t thread_id;
    pthread_mutex_init(&amp;mutex, NULL);
    
    pthread_create(&amp;thread_id, NULL, thread_function, NULL);
    
    // Main program logic here
    
    pthread_join(thread_id, NULL);
    
    pthread_mutex_destroy(&amp;mutex);
    
    return 0;
}
</code></pre>
<p>To compile the code, use the -pthread flag with gcc:
<code>gcc -pthread main.c -o main</code></p>
<p>JavaScript is a single-threaded scripting language that does not support multithreading.</p>
<!--The following lists approximate mapping of threading types and methods in .NET
to Rust:

| .NET               | Rust                      |
| ------------------ | ------------------------- |
| `Thread`           | `std::thread::thread`     |
| `Thread.Start`     | `std::thread::spawn`      |
| `Thread.Join`      | `std::thread::JoinHandle` |
| `Thread.Sleep`     | `std::thread::sleep`      |
| `ThreadPool`       | -                         |
| `Mutex`            | `std::sync::Mutex`        |
| `Semaphore`        | -                         |
| `Monitor`          | `std::sync::Mutex`        |
| `ReaderWriterLock` | `std::sync::RwLock`       |
| `AutoResetEvent`   | `std::sync::Condvar`      |
| `ManualResetEvent` | `std::sync::Condvar`      |
| `Barrier`          | `std::sync::Barrier`      |
| `CountdownEvent`   | `std::sync::Barrier`      |
| `Interlocked`      | `std::sync::atomic`       |
| `Volatile`         | `std::sync::atomic`       |
| `ThreadLocal`      | `std::thread_local`       |
-->
<p>Below is a simple JavaScript program that creates a thread (where the thread prints some text to standard output) indirectly by using <code>worker</code> and then waits for it to end:</p>
<pre><code class="language-js">// Equivalent JavaScript code using Web Workers
const worker = new Worker(URL.createObjectURL(new Blob([`
    self.onmessage = function(event) {
        console.log(event.data);
    };
`], { type: 'application/javascript' })));

worker.postMessage('Hello from a thread!');
</code></pre>
<p>The same code in C would be as follows:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;// Requires GCC

void *thread_function(void *arg) {
    printf("Hello from a thread!\n");
    return NULL;
}

int main() {
    pthread_t thread;
    pthread_create(&amp;thread, NULL, thread_function, NULL);
    pthread_join(thread, NULL); // wait for thread to finish
    return 0;
}
</code></pre>
<p>In JavaScript, it's possible to send data as an argument to a thread:</p>
<pre><code class="language-js">const workerCode = `
self.onmessage = function(e) {
    let eventData = e.data;
    eventData += (" World!");
    console.log("Phrase: " + eventData);
};
`;

const blob = new Blob([workerCode], { type: "application/javascript" });
const worker = new Worker(URL.createObjectURL(blob));

const data = "Hello";
worker.postMessage(data);
</code></pre>
<p>In C, the data is passed to the thread:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;// Requires GCC
#include &lt;string.h&gt;

void* thread_function(void* arg) {
    char* data = (char*)arg;
    strcat(data, " World!");
    return data;
}

int main() {
    char data[20] = "Hello";
    pthread_t thread;
    pthread_create(&amp;thread, NULL, thread_function, (void*)data);
    void* result;
    pthread_join(thread, &amp;result);
    printf("Phrase: %s\n", (char*)result);
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h1>
<p>When data is shared between threads, one needs to synchronize read-write access to the data in order to avoid corruption. In JavaScript:</p>
<pre><code class="language-js">let data = 0;
let workers = [];
let completedWorkers = 0;

for (let i = 0; i &lt; 10; i++) {
    let worker = new Worker('data:text/javascript,' + encodeURIComponent(`
        let partialData = 0;
        for (let j = 0; j &lt; 1000; j++) {
            partialData++;
        }
        self.postMessage(partialData);
    `));
    
    worker.onmessage = function(event) {
        data += event.data;
        completedWorkers++;
        if (completedWorkers === 10) {
            console.log(data);
            workers.forEach(function(worker) {
                worker.terminate();
            });
        }
    };
    
    workers.push(worker);
    worker.postMessage(null);
}

</code></pre>
<p>Using threading and synchronization mechanisms available in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt; // Requires GCC

#define NUM_THREADS 10
#define NUM_INCREMENTS 1000

int data = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* thread_function(void* arg) {
    for (int i = 0; i &lt; NUM_INCREMENTS; i++) {
        pthread_mutex_lock(&amp;mutex);
        data++;
        pthread_mutex_unlock(&amp;mutex);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];

    for (int i = 0; i &lt; NUM_THREADS; i++) {
        pthread_create(&amp;threads[i], NULL, thread_function, NULL);
    }

    for (int i = 0; i &lt; NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("%d\n", data);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="producer-consumer"><a class="header" href="#producer-consumer">Producer-Consumer</a></h1>
<p>The producer-consumer pattern is very common to distribute work between threads where data is passed from producing threads to consuming threads without the need for sharing or locking.</p>
<pre><code class="language-js">const workerCode = `
    self.onmessage = function() {
        const messages = [];
        for (let n = 1; n &lt; 10; n++) {
            messages.push("Message #" + n);
        }
        self.postMessage(messages);
    };
`;

const blob = new Blob([workerCode], { type: "application/javascript" });
const worker = new Worker(URL.createObjectURL(blob));

// The main thread acts as a consumer here
worker.onmessage = function(event) {
    const messages = event.data;
    messages.forEach(message =&gt; console.log(message));
};

// Start the worker
worker.postMessage(null);

</code></pre>
<p>A rough translation of the above JavaScript example in C would look as follows:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt; // Requires GCC

#define BUFFER_SIZE 10

void* producer(void* arg) {
    for (int n = 1; n &lt; 10; n++) {
        printf("Message #%d\n", n);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t tid;
    pthread_create(&amp;tid, NULL, producer, NULL);

    // main thread acts as the consumer
    pthread_join(tid, NULL);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<h2 id="test-organization"><a class="header" href="#test-organization">Test organization</a></h2>
<p>JavaScript solutions use separate projects to host test code, irrespective of the test framework being used (Jest, Mocha, etc.) and the type of tests (unit or integration) being written. The test code therefore lives in a separate assembly than the application or library code being tested. In C, developers use a third party tool called CUnit for testing.</p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://cunit.sourceforge.net/doc/managing_tests.html">Test Organization</a></p>
</li>
</ul>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<p>CUnit supports running all tests in all registered suites, but individual tests or suites can also be run. During each run, the framework keeps track of the number of suites, tests, and assertions run, passed, and failed. Note that the results are cleared each time a test run is initiated (even if it fails).</p>
<p>For more information, see "<a href="https://cunit.sourceforge.net/doc/running_tests.html">Running Tests in CUnit</a>".</p>
<h2 id="output-in-tests"><a class="header" href="#output-in-tests">Output in Tests</a></h2>
<p>For very complex integration or end-to-end test, developers sometimes log what's happening during a test. The actual way they do this varies with each test framework in C.</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>JavaScript users have multiple ways to assert, depending on the framework being used. For example, an assertion in Jest might look like:</p>
<pre><code class="language-js">test('something has the right length', () =&gt; {
    let value = "something";
    expect(value.length).toBe(9);
});
</code></pre>
<p>An example that only uses vanilla JavaScript:</p>
<pre><code class="language-js">function somethingIsTheRightLength() {
    let value = "something";
    console.assert(value.length === 9);
}

somethingIsTheRightLength();
</code></pre>
<p>C does not require a separate framework like CUnit for asserting.</p>
<p>Below is an example:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;string.h&gt;

int main() {
    void test_something_is_the_right_length() {
        const char *value = "something";
        assert(strlen(value) == 9);
    }

    test_something_is_the_right_length(); // Call the test function
    return 0;
}
</code></pre>
<p>The standard library does not offer anything in the direction of data-driven tests.</p>
<h2 id="mocking"><a class="header" href="#mocking">Mocking</a></h2>
<p>There are libraries for C too, like <a href="https://github.com/Azure/umock-c"><code>umock_c</code></a>, that can help with mocking. However, it is also possible to use <a href="testing/../conditional-compilation/index.html">conditional compilation</a>.</p>
<p>The example below shows mocking of a stand-alone function <code>var_os</code> and returns the value of an environment variable. It conditionally imports a mocked version of the <code>var_os</code> function:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#ifdef TEST
    #define var_os var_os_mock
    char* var_os_mock() {
        return "Mocked Value";
    }
#else
    char* var_os() {
        return "Actual Value";
    }
#endif

void get_env() {
    char* value = var_os();
    printf("Environment Variable Value: %s\n", value);
}

int main() {
    #ifndef TEST
        get_env();
    #endif

    return 0;
}
</code></pre>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code coverage</a></h2>
<p>There is sophisticated tooling for JavaScript when it comes to analyzing test code coverage, such as Jest.</p>
<p>In C, one can implement code coverage functionalities by utilizing tools like gcov or LLVM's coverage tools. These tools can help collect test code coverage data in C programs. By incorporating these tools into the C codebase, developers can achieve code coverage analysis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h1>
<p>Running benchmarks in C is done via third party tools.</p>
<p>JavaScript users can make use of <code>Benchmark.js</code> library to benchmark methods and track their performance. The equivalent of <code>Benchmark.js</code> in C is a tool named <code>ansibench</code>.</p>
<p>As per its <a href="https://github.com/nfinit/ansibench">documentation</a>, <code>ansibench</code> collects and stores statistical information from run to run and can automatically detect performance regressions as well as measuring optimizations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-and-tracing"><a class="header" href="#logging-and-tracing">Logging and Tracing</a></h1>
<p>For most cases, <code>console.log()</code> is a good default choice for JavaScript, since it works with a variety of built-in and third-party logging providers. In JavaScript, a minimal example for structured logging could look like:</p>
<pre><code class="language-js">let day = "Thursday";
console.log("Hello ", day); // Hello Thursday.
</code></pre>
<p>In C, there are no built-in loggers. Developers use <code>printf</code> based methods to log.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h1>
<p>Both JavaScript and C are providing the possibility for compiling specific code based on external conditions.</p>
<p>JavaScript doesn't support conditional compilation natively. However, it is possible to use some third-party tool like <code>babel-plugin-preprocessor</code> in order to control conditional compilation.</p>
<pre><code class="language-js">//#if DEBUG
    console.log("Debug");
//#else
    console.log("Not debug");
//#endif
</code></pre>
<p>An example that uses vanilla JavaScript:</p>
<pre><code class="language-js">let isDebug = true;

if(isDebug)
{
    window.eval(`
    console.log("Debug");
    `);
} else {
    window.eval(`
    console.log("Not debug");
    `);
}
</code></pre>
<p>Conditional compilation in C allows developers to include or exclude sections of code during the compilation process based on certain conditions. This feature is particularly useful when different versions of a program need to be generated for various platforms or configurations without modifying the source code.</p>
<p>In C, conditional compilation is achieved using preprocessor directives, which are processed before the actual compilation of the code. The #ifdef, #ifndef, #else, #elif, and #endif directives are commonly used for conditional compilation.</p>
<p>Here is a simple example to illustrate conditional compilation in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define DEBUG 1

int main() {
    #ifdef DEBUG
        printf("Debug mode is enabled.\n");
    #else
        printf("Debug mode is disabled.\n");
    #endif

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-and-configuration"><a class="header" href="#environment-and-configuration">Environment and Configuration</a></h1>
<h2 id="accessing-environment-variables"><a class="header" href="#accessing-environment-variables">Accessing environment variables</a></h2>
<p>JavaScript doesn't provide access to environment variables natively. However, some non-browser JavaScript runtimes, such as Node.js and Node provides access to environment variables.</p>
<p>In Node.js:</p>
<pre><code class="language-js">const name = "EXAMPLE_VARIABLE";

let value = process.env[name];
if (!value) {
    console.log(`Variable '${name}' not set.`);
} else {
    console.log(`Variable '${name}' set to '${value}'.`);
}
</code></pre>
<p>In Deno:</p>
<pre><code class="language-js">const name = "EXAMPLE_VARIABLE";

let value = Deno.env.get(name);
if (!value) {
    console.log(`Variable '${name}' not set.`);
} else {
    console.log(`Variable '${name}' set to '${value}'.`);
}
</code></pre>
<p>In C programming, environmental variables can be accessed using the getenv() function provided by the standard library &lt;stdlib.h&gt;. This function allows a program to retrieve the value of a specific environmental variable by providing its name as an argument.</p>
<p>Here is a simple example demonstrating how to retrieve the value of an environmental variable named PATH:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    char *path_value = getenv("PATH");

    if (path_value != NULL) {
        printf("The value of PATH is: %s\n", path_value);
    } else {
        printf("PATH is not set.\n");
    }

    return 0;
}
</code></pre>
<p>In C, accessing environment variables at compile time involves utilizing preprocessor directives and macros to incorporate the values of environment variables during the compilation phase. This process allows for the configuration of the program based on the environment where it will run without the need for runtime modifications.</p>
<p>One common approach to achieve this functionality is by using the -D flag in the compiler command to define a macro with the value of the desired environment variable. For instance, consider an environment variable MY_ENV_VAR that you want to access at compile time. You can pass this variable's value to the compiler using the -D flag as follows:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#ifndef MY_ENV_VAR
    #define MY_ENV_VAR "default_value"
#endif

int main() {
    printf("Value of MY_ENV_VAR: %s\n", MY_ENV_VAR);
    return 0;
}
</code></pre>
<p>When compiling the program, it is possible to set the value of MY_ENV_VAR by defining it during compilation:</p>
<pre><code class="language-bash">gcc -o myprogram myprogram.c -DMY_ENV_VAR='"custom_value"'
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>JavaScript doesn't support configurations, neither nor C.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linq"><a class="header" href="#linq">LINQ</a></h1>
<p>This section discusses LINQ within the context and for the purpose of querying or transforming sequences and typically collections like lists, sets and dictionaries.</p>
<h2 id="enumerable-items"><a class="header" href="#enumerable-items">Enumerable items</a></h2>
<p>The equivalent of enumerable items in C is <code>enum</code>. In JavaScript, there is <code>forEach</code>:</p>
<pre><code class="language-js">let values = [1, 2, 3, 4, 5];
let output = '';

values.forEach((value, index) =&gt; {
    if (index &gt; 0)
        output += ', ';
    output += value;
});

console.log(output); // Outputs: 1, 2, 3, 4, 5
</code></pre>
<p>In C, the equivalent is simply <code>for</code>:</p>
<pre><code class="language-c">u#include &lt;stdio.h&gt;
#include &lt;string.h&gt; // Include the string.h header file

int main() {
    int values[] = {1, 2, 3, 4, 5};
    char output[50] = "";
    
    for (int i = 0; i &lt; 5; i++) {
        if (i &gt; 0)
            sprintf(output + strlen(output), ", ");
        sprintf(output + strlen(output), "%d", values[i]);
    }

    printf("%s\n", output); // Outputs: 1, 2, 3, 4, 5

    return 0;
}
</code></pre>
<p>The <code>for</code> loop over an iterable essentially gets desuraged to the following:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
    int values[] = {1, 2, 3, 4, 5};
    char output[50] = "";
    int i;

    for (i = 0; i &lt; sizeof(values) / sizeof(values[0]); i++) {
        if (i &gt; 0) {
            sprintf(output + strlen(output), ", ");
        }
        sprintf(output + strlen(output), "%d", values[i]);
    }

    printf("%s\n", output);
    return 0;
}
</code></pre>
<!--

Rust's ownership and data race condition rules apply to all instances and data, and iteration is no exception. So while looping over an array might look straightforward, one has to be mindful about ownership when needing to iterate the same collection/iterable more than once. The following example iteraters the list of integers twice, once to print their sum and another time to determine and print the maximum integer: 

```rust
fn main() {
    let values = vec![1, 2, 3, 4, 5];

    // sum all values

    let mut sum = 0;
    for value in values {
        sum += value;
    }
    println!("sum = {sum}");

    // determine maximum value

    let mut max = None;
    for value in values {
        if let Some(some_max) = max { // if max is defined
            if value > some_max {     // and value is greater
                max = Some(value)     // then note that new max
            }
        } else {                      // max is undefined when iteration starts
            max = Some(value)         // so set it to the first value
        }
    }
    println!("max = {max:?}");
}
```

However, the code above is rejected by the compiler due to a subtle difference: `values` has been changed from an array to a [`Vec<int>`][vec.rs], a _vector_, which is Rust's type for growable arrays. The first iteration of `values` ends up _consuming_ each value as the integers are summed up. In other words, the ownership of _each item_ in the vector passes to the iteration variable of the loop: `value`. Since `value` goes out of scope at the end of each iteration of the loop, the instance it owns is dropped. Had `values` been a vector of heap-allocated data, the heap memory backing each item would get freed as the loop moved to the next item. To fix the problem, one has to request iteration over _shared_ references via `&values` in the `for` loop. As a result, `value` ends up being a shared reference to an item as opposed to taking its ownership.

  [vec.rs]: https://doc.rust-lang.org/stable/std/vec/struct.Vec.html

Below is the updated version of the previous example that compiles. The fix is to simply replace `values` with `&values` in each of the `for` loops.

```rust
fn main() {
    let values = vec![1, 2, 3, 4, 5];

    // sum all values

    let mut sum = 0;
    for value in &values {
        sum += value;
    }
    println!("sum = {sum}");

    // determine maximum value

    let mut max = None;
    for value in &values {
        if let Some(some_max) = max { // if max is defined
            if value > some_max {     // and value is greater
                max = Some(value)     // then note that new max
            }
        } else {                      // max is undefined when iteration starts
            max = Some(value)         // so set it to the first value
        }
    }
    println!("max = {max:?}");
}
```

The ownership and dropping can be seen in action even with `values` being an array instead of a vector. Consider just the summing loop from the above example over an array of a structure that wraps an integer:

```rust
struct Int(i32);

impl Drop for Int {
    fn drop(&mut self) {
        println!("{} dropped", self.0)
    }
}

fn main() {
    let values = [Int(1), Int(2), Int(3), Int(4), Int(5)];
    let mut sum = 0;

    for value in values {
        sum += value.0;
    }

    println!("sum = {sum}");
}
```

`Int` implements `Drop` so that a message is printed when an instance get dropped. Running the above code will print:

    value = Int(1)
    Int(1) dropped
    value = Int(2)
    Int(2) dropped
    value = Int(3)
    Int(3) dropped
    value = Int(4)
    Int(4) dropped
    value = Int(5)
    Int(5) dropped
    sum = 15

It's clear that each value is acquired and dropped while the loop is running. Once the loop is complete, the sum is printed. If `values` in the `for` loop is changed to `&values` instead, like this:

```rust
for value in &values {
    // ...
}
```

then the output of the program will change radically:

    value = Int(1)
    value = Int(2)
    value = Int(3)
    value = Int(4)
    value = Int(5)
    sum = 15
    Int(1) dropped
    Int(2) dropped
    Int(3) dropped
    Int(4) dropped
    Int(5) dropped

This time, values are acquired but not dropped while looping because each item doesn't get owned by the interation loop's variable. The sum is printed once the loop is done. Finally, when the `values` array that still owns all the the `Int` instances goes out of scope at the end of `main`, its dropping in turn drops all the `Int` instances.

These examples demonstrate that while iterating collection types may seem to have a lot of parallels between Rust and JavaScript, from the looping constructs to the iteration abstractions, there are still subtle differences with respect to ownership that can lead to the compiler rejecting the code in some instances.

See also:

- [Iterator][iter-mod]
- [Iterating by reference]

[into-iter.rs]: https://doc.rust-lang.org/std/iter/trait.IntoIterator.html
[iter.rs]: https://doc.rust-lang.org/core/iter/trait.Iterator.html
[iter-mod]: https://doc.rust-lang.org/std/iter/index.html
[iterating by reference]: https://doc.rust-lang.org/std/iter/index.html#iterating-by-reference
-->
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>JavaScript and C don't natively support LINQ, but there is a project called <a href="https://github.com/mihaifm/linq">LINQ.js</a> that implements LINQ in C# for JavaScript, and a project called <a href="https://github.com/haifenghuang/linq4c">linq4c</a> that implements LINQ in C# for C.</p>
<p><em>Operators</em> in LINQ are implemented in the form of LINQ.js extension methods that can be chained together to form a set of operations, with the most common forming a query over some sort of data source. LINQ.js also offers a SQL-inspired <em>query syntax</em> with clauses like <code>from</code>, <code>where</code>, <code>select</code>, <code>join</code> and others that can serve as an alternative or a companion to method chaining. Many imperative loops can be re-written as much more expressive and composable queries in LINQ.</p>
<h2 id="deferred-execution-laziness"><a class="header" href="#deferred-execution-laziness">Deferred execution (laziness)</a></h2>
<p>Many operators in LINQ are designed to be lazy such that they only do work when absolutely required. This enables composition or chaining of several operations/methods without causing any side-effects.</p>
<p>In both cases, this allows <em>infinite sequences</em> to be represented, where the underlying sequence is infinite, but the developer decides how the sequence should be terminated. The following example shows this in JavaScript:</p>
<pre><code class="language-js">function* infiniteRange() {
    for (let i = 0; ; ++i) {
        yield i;
    }
}

for (let x of infiniteRange()) {
    if (x &lt; 5) {
        console.log(x); // Prints "0 1 2 3 4"
    } else {
        break;
    }
}
</code></pre>
<p>C supports the same concept through <code>for</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int value;
    for (value = 0; value &lt; 5; value++) {
        printf("%d ", value); // Prints "0 1 2 3 4"
    }
    return 0;
}
</code></pre>
<h2 id="iterator-methods-yield"><a class="header" href="#iterator-methods-yield">Iterator Methods (<code>yield</code>)</a></h2>
<p>JavaScript has the <code>yield</code> keword that enables the developer to quickly write an <em>iterator method</em>. C doesn't support coroutines natively, but there is a <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">tutorial of implementing coroutines in C</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meta-programming"><a class="header" href="#meta-programming">Meta Programming</a></h1>
<p>Metaprogramming can be seen as a way of writing code that writes/generates other code.</p>
<p>JavaScript has the concept of metaprogramming, but it refers to intercepting and defining basic language operations, which is different from metaprogramming in C, C# or Rust. There is a JavaScript source generator called <a href="https://github.com/jondot/hygen">hygen</a>, but it does not call itself a "metaprogramming tool".</p>
<p>C does not support metaprogramming natively, however, third party tools, like <a href="https://github.com/Hirrolot/metalang99">metalang99</a>, exists.</p>
<p>C does not support reflection.</p>
<h2 id="function-like-macros"><a class="header" href="#function-like-macros">Function-like macros</a></h2>
<p>Function-like macros in C are in the following form: <code>#define</code></p>
<p>The following code snippet defines a function-like macro named <code>print_something</code>, which is generating a <code>print_it</code> method for printing the "Something" string.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define print_something() printf("Something\n")

int main() {
    print_something();
    return 0;
}
</code></pre>
<h2 id="derive-macros"><a class="header" href="#derive-macros">Derive macros</a></h2>
<p>Derive macros are not supported in C and JavaScript.</p>
<h2 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute macros</a></h2>
<p>Attribute macros are not supported in C and JavaScript.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h1>
<p>Both JavaScript and C support asynchronous programming models, which look similar to each other with respect to their usage. The following example shows, on a very high level, how async code looks like in JavaScript:</p>
<pre><code class="language-js">async function printDelayed(message, cancellationToken) {
    await new Promise(resolve =&gt; setTimeout(resolve, 1000));
    return `Message: ${message}`;
}
</code></pre>
<p>C code is structured differently:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt; // Requires GCC
#include &lt;unistd.h&gt;

void* printDelayed(void* args) {
    char* message = (char*)args;
    sleep(1); // Simulating a delay of 1 second
    char* result = malloc(strlen(message) + 10); // Allocating memory for the result
    sprintf(result, "Message: %s", message);
    return result;
}

int main() {
    char* message = "Hello, World!";
    pthread_t tid;
    void* result;

    pthread_create(&amp;tid, NULL, printDelayed, (void*)message);
    pthread_join(tid, &amp;result);

    printf("%s\n", (char*)result);
    free(result); // Freeing allocated memory
    return 0;
}
</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://hackaday.com/2019/09/24/asynchronous-routines-for-c/">Asynchronous programming in C</a></li>
</ul>
<h2 id="executing-tasks"><a class="header" href="#executing-tasks">Executing tasks</a></h2>
<p>From the following example the <code>PrintDelayed</code> method executes, even though it is not awaited:</p>
<pre><code class="language-js">let cancellationToken = undefined; 
printDelayed("message", cancellationToken); // Prints "message" after a second.
await new Promise(resolve =&gt; setTimeout(resolve, 2000));

async function printDelayed(message, cancellationToken) {
    await new Promise(resolve =&gt; setTimeout(resolve, 1000));
    console.log(message);
}
</code></pre>
<p>In C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#ifdef _WIN32
#include &lt;windows.h&gt;
#define sleep(x) Sleep(x * 1000)
#else
#include &lt;unistd.h&gt;
#endif

void printDelayed(char* message) {
    sleep(1); // Delay for 1 second
    printf("%s\n", message);
}

int main() {
    char* message = "message";
    printDelayed(message); // Prints "message" after a second.
    sleep(2); // Delay for 2 seconds
    return 0;
}
</code></pre>
<h2 id="task-cancellation"><a class="header" href="#task-cancellation">Task cancellation</a></h2>
<p>The previous JavaScript examples included passing a <code>CancellationToken</code> to asynchronous methods, as is considered best practice in JavaScript. <code>CancellationToken</code>s can be used to abort an asynchronous operation.</p>
<p>In C language, the concept ofcancellation  can be implemented using custom structures and functions.</p>
<h2 id="executing-multiple-tasks"><a class="header" href="#executing-multiple-tasks">Executing multiple Tasks</a></h2>
<p>In JavaScript, <code>Promise.race</code> is frequently used to handle the execution of multiple tasks.</p>
<p><code>Promise.race</code> completes as soon as any task completes.</p>
<pre><code class="language-js">const delay = (ms) =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));

const delayMessage = async (delayTime) =&gt; {
    await delay(delayTime);
    return `Waited ${delayTime / 1000} second(s).`;
};

const delay1 = delayMessage(1000);
const delay2 = delayMessage(2000);

Promise.race([delay1, delay2]).then(result =&gt; {
    console.log(result); // Output: Waited 1 second(s).
});
</code></pre>
<p>In C, to achieve similar functionality to Promise.race in JavaScript, one can use a combination of threads and synchronization mechanisms like mutexes or semaphores. By creating multiple threads that perform tasks concurrently and using synchronization to determine which thread finishes first, a similar behavior to Promise.race can be achieved in C. Below is a simplified example in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt; // Requires GCC
#include &lt;unistd.h&gt;

void* delayMessage(void* delayTime) {
    int ms = *((int*)delayTime);
    usleep(ms * 1000); // Convert milliseconds to microseconds
    char* message = malloc(100 * sizeof(char));
    sprintf(message, "Waited %d second(s).", ms / 1000);
    return message;
}

int main() {
    pthread_t thread1, thread2;
    int delay1 = 1000;
    int delay2 = 2000;
    char* result1;
    char* result2;

    pthread_create(&amp;thread1, NULL, delayMessage, (void*)&amp;delay1);
    pthread_create(&amp;thread2, NULL, delayMessage, (void*)&amp;delay2);

    pthread_join(thread1, (void**)&amp;result1);
    pthread_join(thread2, (void**)&amp;result2);

    printf("%s\n", result1); // Output: Waited 1 second(s).

    free(result1);
    free(result2);

    return 0;
}
</code></pre>
<h2 id="multiple-consumers"><a class="header" href="#multiple-consumers">Multiple consumers</a></h2>
<p>In JavaScript a <code>Promise</code> can be used across multiple consumers. All of them can await the task and get notified when the task is completed or failed.</p>
<p>In C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#ifdef _WIN32
#include &lt;windows.h&gt; // For Sleep(), DWORD
#else
#include &lt;unistd.h&gt; // For sleep()
#include &lt;sys/types.h&gt; // For pid_t
#include &lt;sys/wait.h&gt; // For wait()
#endif

void background_operation() {
#ifdef _WIN32
    Sleep(2000);
#else
    sleep(2);
#endif
    printf("Background operation completed.\n");
}

#ifdef _WIN32
BOOL WINAPI signal_handler(DWORD dwCtrlType) {
    if (dwCtrlType == CTRL_C_EVENT) {
        printf("Signal received. Cancelling background operation.\n");
        exit(0);
    }
    return TRUE;
}
#else
void signal_handler(int signal) {
    if (signal == SIGINT) {
        printf("Signal received. Cancelling background operation.\n");
        exit(0);
    }
}
#endif

int main() {
#ifdef _WIN32
    SetConsoleCtrlHandler(signal_handler, TRUE);
#else
    signal(SIGINT, signal_handler);
#endif

    DWORD pid = GetCurrentProcessId(); // Get current process ID
    printf("Process ID: %lu\n", pid);

    // Fork and perform background operation
    // ...

    wait(NULL);
    printf("Parent process waiting for child process to finish.\n");

    return 0;
}
</code></pre>
<h2 id="asynchronous-iteration"><a class="header" href="#asynchronous-iteration">Asynchronous iteration</a></h2>
<p>C does not yet have an API for asynchronous iteration in the standard library.</p>
<p>In JavaScript, writing async iterators has comparable syntax to when writing synchronous iterators:</p>
<pre><code class="language-js">async function* RangeAsync(start, count) {
    for (let i = 0; i &lt; count; i++) {
        await new Promise(resolve =&gt; setTimeout(resolve, i * 1000));
        yield start + i;
    }
}

(async () =&gt; {
    for await (const item of RangeAsync(10, 3)) {
        console.log(item + " "); // Prints "10 11 12".
    }
})();
</code></pre>
<p>In C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

typedef struct {
    int start;
    int count;
} Range;

void RangeAsync(Range range) {
    for (int i = 0; i &lt; range.count; i++) {
        usleep(i * 1000000); // Simulating async delay in microseconds
        printf("%d ", range.start + i);
    }
}

int main() {
    Range range = {10, 3};
    RangeAsync(range);
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>The JavaScript standard does not specify a specification for the structure of the project. Generally speaking, all the files in a JavaScript library are usually placed in a folder named after the library. The following is a common JavaScript project specification:</p>
<pre><code>.
+-- src/
|¬†¬† +-- project1.js
+-- styles/
|¬†¬† +-- style1.js
+-- examples/
|¬†¬† +-- some-example.js
+-- tests/
    +-- some-integration-test.js
</code></pre>
<p>The C standard does not specify a specification for the structure of the project.</p>
<h2 id="managing-large-projects"><a class="header" href="#managing-large-projects">Managing large projects</a></h2>
<p>For very large projects in C, different IDEs and different toolchains have different ways to manage large projects.</p>
<h2 id="managing-dependency-versions"><a class="header" href="#managing-dependency-versions">Managing dependency versions</a></h2>
<p>There is no concept of dependency in the C standard, different IDEs and different toolchains have different ways to manage dependency versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation-and-building"><a class="header" href="#compilation-and-building">Compilation and Building</a></h1>
<h2 id="javascript-cli"><a class="header" href="#javascript-cli">JavaScript CLI</a></h2>
<p>There is no concept of CLI in the JavaScript standard. People often use non-browser runtimes such as Node.js and Deno to act as CLIs.</p>
<p>There is no concept of CLI in the C standard, different IDEs and different toolchains have different CLIs.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>When building JavaScript, the scripts coming from dependent packages are generally co-located with the project's output assembly. C compilers compiles the project sources, except the C compiler statically links all code into a single, platform-dependent, binary.</p>
<p>Developers use different ways to prepare a JavaScript executable for distribution, either as a <em>framework-dependent deployment</em> (FDD) or <em>self-contained deployment</em> (SCD). In Rust, there is no way to let the build output already contains a single, platform-dependent binary for each target.</p>
<p>In C, the build output is, again, a platform-dependent, compiled library for each library target.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>There is no concept of dependency in the JavaScript standard. However, some JavaScript runtimes, such as Node.js and Deno, have the concept of dependencies. In Node.js and Deno, the contents of a project file (<code>package.json</code>) define the build options and dependencies. A typical project file will look like:</p>
<pre><code class="language-json">{
  "name": "your-project-name",
  "version": "1.0.0",
  "description": "Your project description",
  "dependencies": {
    "linq": "4.0.3"
  }
}
</code></pre>
<p>There is no concept of dependency in the C standard, different IDEs and different toolchains have different ways to manage dependencies.</p>
<h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<p>There is no concept of packages in the JavaScript standard. However, some JavaScript runtimes, such as Node.js, have the concept of packages. NPM is most commonly used to install packages for Node.js, and various tools supported it.
For example, adding a Node.js package reference with the Node,js CLI will add the
dependency to the project file:</p>
<p><code>npm install linq</code></p>
<p>The most common package registry for Node.js is <a href="https://www.npmjs.com/">npmjs.com</a> .</p>
<p>There is no concept of packages in the C standard, different IDEs and different toolchains have different ways to manage packages.</p>
<h2 id="static-code-analysis"><a class="header" href="#static-code-analysis">Static code analysis</a></h2>
<p>ESLint is an analyzer that provide code quality as well as code-style analysis. The equivalent linting tool in C is Clang Static Analyzer or other tools.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
