[["Map",1,2,9,10,105,106],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.17.3","content-config-digest","5099ab38c92eea4d","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://devscholar.github.io\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"i18n\":{\"defaultLocale\":\"en-us\",\"locales\":[\"en-us\",\"zh-cn\"],\"routing\":{\"prefixDefaultLocale\":true,\"redirectToDefaultLocale\":false,\"fallbackType\":\"redirect\"}},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","devblogs",["Map",11,12,65,66],"en-us/history-of-html-applications",{"id":11,"data":13,"body":18,"filePath":19,"digest":20,"rendered":21,"legacyId":64},{"title":14,"description":15,"pubDate":16,"author":17},"The History of HTML Applications","Exploring the evolution of HTML applications from the 1990s to today.",["Date","2026-02-24T00:00:00.000Z"],"DevScholar","# The History of HTML Applications\n\nThis article refers to desktop applications developed using HTML technologies, such as those based on Microsoft's MSHTA and the Electron platform. This technology enables HTML to run offline and be distributed as a standalone application, while granting it access to operating system APIs typical of desktop applications, such as file operations or reading and writing to the registry.\n\n## MSHTA\n\nIn 1996, Microsoft released Internet Explorer (IE) 3.0, which added standard features like CSS and JS, but also included ready-to-use proprietary features like ActiveX[1]. Users could use ActiveX controls and the ActiveXObject object to directly call system APIs for privileged operations like file reading and writing. It is worth noting that in 1996, desktop application development was still in its infancy, and nobody was concerned about security issues. This stemmed from Microsoft's vision of shaping IE as another Windows development platform, since HTML is well-suited for building user interfaces and JS is easy to learn. At the time, Visual Basic (VB) was easy to use, but achieving artistic UI required using numerous obscure Windows APIs for custom drawing, event handling, and more. The combination of C++ and the Win32 API was even more of a disaster; the `CreateWindow` function alone required filling in a full 11 parameters[2], compounded by the difficulty of C++. So Microsoft decided to turn IE into another development platform. At the time, Microsoft's competitor, the Netscape browser, supported NPAPI and Java applets, which were based on open standards but could do less than IE. NPAPI could call system APIs, but users needed to install a specific browser plugin on demand. Java applets had even more restricted permissions.\n\nThis is how Microsoft gained another Windows technology development platform. However, because the web page ran inside a browser, it always had an unremovable browser chrome. Around that time, Microsoft's programmers had also been suffering from VB and C++ for a long time, and they were actively exploring the possibility of writing applications using HTML. For example, using HTML as the interface for C++ applications via `CHtmlView`, and the \"DHTML Application\" project type in VB, which compiled VB code into visually hidden ActiveX controls for JS to call. There was also Microsoft(R) HTML Application Host (MSHTA)[3], released alongside IE 5.0 in 1999. It is a component provided by Microsoft for creating HTML applications. It allows developers to build fully functional desktop applications using HTML, CSS, and JavaScript, called HTML Applications (HTA). HTA can only run on Windows and can access the operating system's file system APIs. Most importantly, HTA has no browser chrome and looks like a regular desktop application. It also provides the `HTA:APPLICATION` tag to control application characteristics, such as using a specific window frame, setting whether to show maximize and minimize buttons, and so on.\n\nAt the time, other operating systems like Linux and macOS did not provide functionality similar to HTA, because people on those platforms focused on performance and overlooked hobbyist developers, considering C++ and other languages better solutions for writing applications.\n\nDue to constant pressure from third-party developers and competition from Netscape, Microsoft kept developing new features for IE. However, because standardization efforts for technologies like HTML 4.01 had stalled, Microsoft had to release IE's new features as proprietary extensions, and submitted many features to the W3C requesting standardization. Small changes like `innerHTML` were usually accepted, but larger features like IE-specific filters and Vector Markup Language (VML) were usually rejected. By the time IE 6 was released in 2001, IE's market share had reached an astonishing 98%. However, HTML is a public standard, not something Microsoft could control alone. So, for profit, Microsoft decided to stop actively developing IE and instead shifted focus to Microsoft's (at that time, proprietary and Windows-only) .NET platform, launching technologies like WinForms and WPF. Meanwhile, HTA's development stalled along with IE's development.\n\n## PhoneGap and Cordova\n\nWhile HTA was stalling on the desktop, HTML applications found new life on another battlefield. In 2008, as the iPhone ushered in the smartphone era, developers faced an awkward situation: iOS native development required Objective-C, Android required Java, and each platform required separate application code. While web technologies could run in mobile browsers, they could not access hardware functions like the camera, GPS, or contacts.\n\nIn 2009, Brian Leroux and others at Nitobi developed PhoneGap[4]. This was a clever hack: it embedded a WebView control in a native application, using HTML/CSS/JavaScript as the UI layer, then calling underlying native APIs through a JavaScript Bridge. Developers only needed to write one set of web code to package native applications for multiple platforms like iOS, Android, and BlackBerry.\n\nPhoneGap's core innovation was the Hybrid App pattern. Unlike HTA, which directly called system APIs, PhoneGap exposed native capabilities to JavaScript through a plugin architecture. For example, for the camera feature, PhoneGap provided a unified JavaScript API, while the underlying code called iOS's UIImagePickerController or Android's Camera Intent respectively. This abstraction allowed web developers to build \"native-like\" applications without learning native languages.\n\nIn 2011, Adobe acquired Nitobi and donated PhoneGap's core code to the Apache Foundation, renaming it Apache Cordova[5]. This move ensured the technology's openness, but also sowed the seeds of division. Adobe retained the PhoneGap brand and launched the cloud-based PhoneGap Build service, while Cordova became a community-driven open-source project.\n\nCordova quickly became one of the mainstream solutions for mobile development. Its advantages were clear: low development cost (one codebase across platforms), low technical barrier (web developers could get started easily), and a rich ecosystem (tens of thousands of plugins on npm). Many well-known apps from the mid-2010s, such as Instagram, Uber, and early versions of Wikipedia, used Cordova or its derivatives.\n\nHowever, Cordova's limitations became increasingly apparent. First, there was the performance issue. WebView rendering performance never matched native UI, and complex list scrolling and animations often stuttered. Second, there was the experience gap. Although apps could be packaged as APKs or IPAs, their interface styles differed noticeably from native apps, and users could clearly tell \"this is a web page in a shell.\" More serious was the plugin dependency. Whenever iOS or Android released a new system version, Cordova plugins needed separate updates, and many plugins were maintained by individuals, with updates lagging or even being abandoned, causing apps to fail to adapt to new systems in a timely manner.\n\n## Capacitor\n\nIn 2018, the Ionic team launched Capacitor[6], as Cordova's spiritual successor. It retained the basic hybrid app architecture of WebView rendering plus Native Bridge, but made modernized improvements in design.\n\nCapacitor's biggest change was embracing modern web standards. It no longer depended on a specific framework and supported any frontend toolchain (React, Vue, Angular, Svelte, etc.). More importantly, it leveraged the Progressive Web Apps (PWA) technology stack: Service Workers for offline support, Web App Manifest for installation configuration. This meant the same Capacitor app could be distributed as a native app to app stores or as a PWA directly through the browser.\n\nArchitecturally, Capacitor simplified the plugin system. Cordova plugins required writing complex native code for each platform, while Capacitor encouraged implementing functionality in JavaScript, only calling native APIs when necessary. It also provided a clearer Native Bridge with TypeScript type definitions, making communication between the web and native layers more reliable.\n\nBut Capacitor did not solve the fundamental contradiction of hybrid apps: the WebView performance ceiling. Although modern WebViews (WKWebView on iOS, WebView based on Chromium on Android) have significantly improved performance, in heavy graphics scenarios (3D games, video editing, complex animations), they still cannot compete with native solutions or frameworks like React Native and Flutter.\n\nAdditionally, both Capacitor and Cordova faced app store review risks. In the 2020s, Apple intensified restrictions on \"shell apps\" (App Wrappers). If an app's content is primarily web-based and functions are no different from the website, it may be rejected from the store. This forced developers to either provide richer functionality on the web layer than on the website, or switch to native rendering solutions.\n\n## WinJS and Windows 8\n\nReturning to the desktop. Although HTA had stalled, Microsoft did not give up on building desktop applications with web technologies. In 2012, with the release of Windows 8, Microsoft launched WinJS (Windows Library for JavaScript)[7]. This is a JavaScript library designed specifically for Windows Store apps (Metro/Modern UI apps), allowing developers to write native Windows applications using HTML, CSS, and JavaScript.\n\nUnlike HTA, WinJS apps ran on the new Windows Runtime (WinRT) rather than traditional Win32 APIs. They had true native application permissions, could access file systems, cameras, sensors, and other hardware, while maintaining the development experience of web technologies. Microsoft even open-sourced WinJS, trying to attract web developers into the Windows ecosystem.\n\nHowever, Windows 8's Metro interface was highly controversial, and users and developers preferred traditional desktop apps. WinJS apps were restricted to distribution through the app store and could not run on older systems like Windows 7. With the failure of Windows 10's unified platform strategy, WinJS was gradually marginalized by Microsoft, becoming another abandoned attempt at web-based desktop solutions.\n\nIt is worth noting that WinJS's philosophy was similar to Cordova/Capacitor: both were hybrids of web technology plus native runtime. But WinJS was limited to the Windows platform, while Cordova grabbed the pain point of mobile cross-platform development, so their fates were completely different.\n\n## node-webkit and NW.js\n\nThe real turning point came from the open-source community. In 2011, Roger Wang from Intel's Open Source Technology Center launched the node-webkit project[8]. This was a bold innovation: it bundled the Node.js runtime with the WebKit rendering engine, allowing developers to write applications using web technologies while accessing underlying system APIs through Node.js.\n\nWhat did this mean? Developers could finally build interfaces with HTML, write logic with JavaScript, and like traditional desktop applications, read and write files, access databases, call system commands, and all of this was cross-platform, running on Windows, macOS, and Linux. In 2014, the project was renamed NW.js to better reflect its technical essence.\n\nNW.js solved several pain points from the MSHTA era. First, it was based on a modern WebKit engine, supporting HTML5 and CSS3 rather than the outdated IE engine. Second, it was truly cross-platform, no longer restricted to Windows. Most importantly, it brought Node.js's ecosystem to desktop development, allowing developers to use the hundreds of thousands of packages on npm.\n\nHowever, NW.js had its limitations. Its architecture injected the entire Node.js runtime into the web environment, causing context confusion and blurred lines between the main process and renderer processes. Each window was an independent renderer process, but they shared the same Node.js context, which could easily lead to performance issues and memory leaks in complex applications.\n\n## Electron\n\nIn 2013, Cheng Zhao at GitHub developed Atom Shell based on Chromium Content Module and Node.js, aiming to provide a framework for the Atom editor[9]. In 2015, the project was renamed Electron. Unlike NW.js, Electron adopted a clearer multi-process architecture: the main process (Node.js environment) handled system-level operations, the renderer process (Chromium environment) handled UI display, and the two communicated through IPC (Inter-Process Communication).\n\nThis separation brought several key advantages. First, improved stability, where a single window crash would not affect the entire application. Second, improved security, where renderer processes ran in sandbox by default and needed explicit APIs to access system resources. Most importantly, developers could precisely control application lifecycle and resource allocation.\n\nElectron quickly became the de facto standard for HTML desktop applications. Well-known apps like Slack, VS Code, Discord, and Figma were all built on Electron. It even fed back into web technologies themselves; VS Code's popularity drove the adoption of TypeScript and the Language Server Protocol, and Electron's cross-platform capabilities allowed small teams to develop desktop software with full platform support.\n\nBut Electron was not without criticism. Each application bundled a complete Chromium and Node.js, resulting in large installation package sizes (typically over 100MB) and high memory usage.\n\n## PWA\n\nWhile Electron dominated the desktop, browser vendors were exploring another path: giving web applications themselves offline capabilities and system access. In 2015, Google proposed the Progressive Web Apps (PWA) concept[10], which was subsequently supported by Microsoft, Apple, and others.\n\nPWA achieves offline caching through Service Workers, provides native-like app installation experience through Web App Manifest, and gradually expands system access capabilities through a series of Web APIs (File System Access API, Contacts API, Bluetooth API, etc.). In theory, PWA can \"write once, run everywhere,\" without bundling a browser kernel, has a lightweight footprint, and can be distributed directly through app stores or browsers.\n\nMicrosoft actively supported PWA on Windows 10/11, allowing distribution through the Microsoft Store, somewhat returning to WinJS's original intent. However, PWA faces many limitations in practice.\n\nFirst, there is the fundamental flaw in offline capabilities. Service Worker offline caching depends on the browser downloading resources in advance, making it more suitable for \"enhanced web pages\" rather than truly offline applications. If the user's network is unstable during the first visit, or if the caching strategy is improperly configured, the application may not start at all. This is fundamentally different from the Electron app experience of \"download and run offline.\"\n\nSecond, there is the distribution dilemma. Although PWA can be distributed through app stores, policies vary across platforms. Apple imposes strict restrictions on PWA on iOS, not allowing third-party browser engines, and PWA cannot use full Web Push and other features. More importantly, PWA cannot distribute installation packages directly like traditional desktop applications; users must obtain them through browsers or app stores, which is very inflexible in enterprise intranet environments or scenarios requiring specific version control.\n\nThird, there are limitations in system integration. PWA runs in a browser sandbox. Although Web APIs are continuously expanding, many low-level operations still cannot be achieved: cannot listen to global hotkeys, cannot create system tray icons, cannot keep processes running in the background, cannot access certain hardware interfaces. For advanced features requiring deep system integration, PWA still falls short.\n\nFourth, there is platform difference fragmentation. Different browsers have varying levels of support for Web APIs, and developers still need to deal with compatibility issues. Moreover, PWA is always confined to the browser window frame; it cannot create truly frameless windows or customize native menu bars, features that are commonplace in desktop applications but difficult to implement in PWA.\n\nTherefore, PWA is more suitable for content-based, occasionally offline applications, not complex productivity tools. It failed to replace Electron; instead, they formed a complementary relationship: PWA for lightweight scenarios, Electron for heavy desktop applications.\n\n## Post-Electron Era\n\nElectron's bloat problem became increasingly prominent in the 2020s. A \"Hello World\" level Electron application can have a size of 150MB or more, with startup memory usage in the hundreds of megabytes. This is acceptable on modern devices with abundant SSD storage and memory, but becomes a pain point on low-end devices or scenarios that prioritize resource efficiency.\n\nThe deeper problem is technical debt. Electron is deeply bound to specific versions of Node.js and Chromium, making it difficult to adapt to new developments in JavaScript runtimes. When new-generation runtimes like Deno (2018) and Bun (2022) emerged, they provided more secure permission models, better native TypeScript support, and significant performance improvements, but Electron's architecture cannot directly leverage these advantages. Electron applications are trapped in Node.js's ecosystem and cannot enjoy the latest developments in JS infrastructure.\n\nThis sparked exploration of a series of alternatives.\n\nTauri[11] uses a lightweight backend written in Rust, using the operating system's native WebView for frontend rendering. Windows uses WebView2, macOS uses WKWebView, and Linux uses WebKitGTK. Since bundling a browser kernel is unnecessary, application sizes can be compressed to 3 to 5MB, and memory usage is significantly reduced. However, Tauri requires developers to use Rust for system interactions, which is a barrier for pure web developers. Although it provides JavaScript APIs, complex functionality still requires diving deep into the Rust ecosystem, losing the convenience of full-stack JavaScript.\n\nWebUI[12] is a C language-written cross-platform library that does not bundle a browser kernel but uses browsers already installed on the user's computer as the rendering engine. Chrome, Firefox, and Edge can all be used, communicating with the local backend via WebSocket. The size is extremely small, just a single executable. But it is limited by the browser window; it cannot create truly frameless applications, cannot disable the browser's developer tools, and the interface always carries traces of the browser. Relying on an external browser also means rendering consistency cannot be guaranteed; different browser versions may cause compatibility issues.\n\nWails[13] is similar to Tauri, but uses Go as the backend language, also relying on native WebView. It solves the size problem but locks developers into the Go ecosystem.\n\nFlutter Desktop and React Native Desktop abandon the web technology stack altogether, using self-drawn rendering engines. Although they have excellent performance, they lose the openness and ecosystem advantages of web development.\n\nThe common dilemma of these solutions is: keeping the web technology stack results in large sizes, reducing size introduces native language barriers, keeping it lightweight limits it to browser windows. No one has found the perfect balance point.\n\n## New Possibilities\n\nFacing this dilemma, I developed two experimental projects to explore different paths.\n\nnode-ps1-dotnet[14] is a desktop application framework based on Node.js and PowerShell. It leverages the ubiquitous PowerShell and .NET runtime on Windows, allowing Node.js applications to call complete Windows APIs and .NET class libraries without bundling Chromium. The frontend can use the system's built-in WebView2, while the backend deeply integrates with the system through PowerShell scripts. This significantly reduces application size while maintaining the JavaScript and TypeScript development experience.\n\nnode-with-gjs[15] is the corresponding solution for Linux. GJS is GNOME project's JavaScript binding, allowing the use of JavaScript to call GTK and native system APIs.\n\nThe core idea of these two projects is to use runtimes that already exist on the operating system, rather than bundling their own browser and Node.js runtime. This greatly reduces distribution size while allowing deep integration of system capabilities. They adapt not only to Node.js but also to Deno and Bun, and provide first-class support for GUI development and WebView development, with ready-to-use examples.\n\nHowever, they are currently limited to specific platforms. node-ps1-dotnet mainly targets Windows, and node-with-gjs targets Linux. To build truly cross-platform applications, developers need to handle platform differences and write conditional code.\n\n## Next Step\n\nBased on the above exploration, I am developing a unified cross-platform abstraction layer. On Windows, it uses the [node-ps1-dotnet](https://github.com/DevScholar/node-ps1-dotnet) architecture, using WebView2 for interface rendering, and PowerShell and .NET for system interaction. On Linux, it uses the [node-with-gjs](https://github.com/DevScholar/node-with-gjs) architecture, using WebKitGTK for interface rendering, and GJS and GTK for system interaction.\n\nCurrently, I do not plan to support macOS, because I cannot afford a MacBook and have not done development on macOS. However, if there is genuine demand, I can try installing an x86 Hackintosh virtual machine on my computer for development. Although newer macOS versions no longer release x86 versions, since my project does not use native code, only scripting languages and IPC, and Apple does not frequently change the JavaScript for Automation API, development should theoretically be possible.\n\nDevelopers only need to write one set of HTML, CSS, JavaScript frontend code, along with unified JavaScript API calls, without worrying about whether the underlying layer is PowerShell or GJS. The framework will automatically route system API calls to the corresponding platform's native mechanism.\n\nThis solution attempts to combine the advantages of various approaches: maintaining the openness and ecosystem of the web technology stack, significantly reducing application size, supporting deep system integration, and being able to adapt to new-generation JavaScript runtimes like Deno and Bun. The architecture no longer hardcodes Node.js but is abstracted as a general JS runtime interface.\n\nFrom MSHTA's system binding, to Electron's self-contained architecture, to new-generation solutions returning to native system capabilities, the technical trajectory of HTML desktop applications has gone through a cycle. MSHTA used the system's existing runtimes, Electron chose to bundle everything, and new-generation solutions return to the approach of using system runtimes. This time, web standards are more mature, the open-source ecosystem is more complete, and developers have a deeper understanding of cross-platform development.\n\nHTML desktop applications are still evolving.\n\n---\n\n**References**\n\n[1] IE 3.0: https://www.webdesignmuseum.org/software/internet-explorer-3-0-in-1996\n\n[2] CreateWindowA: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowa\n\n[3] MSHTA: https://learn.microsoft.com/en-us/previous-versions/ms536496(v=vs.85)\n\n[4] PhoneGap: https://phonegap.com/\n\n[5] Apache Cordova: https://cordova.apache.org/\n\n[6] Capacitor: https://capacitorjs.com/\n\n[7] WinJS: https://github.com/winjs/winjs\n\n[8] NW.js: https://nwjs.io/\n\n[9] Electron: https://www.electronjs.org/\n\n[10] Progressive Web Apps: https://web.dev/progressive-web-apps/\n\n[11] Tauri: https://tauri.app/\n\n[12] WebUI: https://webui.dev/\n\n[13] Wails: https://wails.io/\n\n[14] node-ps1-dotnet: https://github.com/DevScholar/node-ps1-dotnet\n\n[15] node-with-gjs: https://github.com/DevScholar/node-with-gjs","src/content/devblogs/en-us/history-of-html-applications.md","84bd731d86dbbf94",{"html":22,"metadata":23},"\u003Ch1 id=\"the-history-of-html-applications\">The History of HTML Applications\u003C/h1>\n\u003Cp>This article refers to desktop applications developed using HTML technologies, such as those based on Microsoft’s MSHTA and the Electron platform. This technology enables HTML to run offline and be distributed as a standalone application, while granting it access to operating system APIs typical of desktop applications, such as file operations or reading and writing to the registry.\u003C/p>\n\u003Ch2 id=\"mshta\">MSHTA\u003C/h2>\n\u003Cp>In 1996, Microsoft released Internet Explorer (IE) 3.0, which added standard features like CSS and JS, but also included ready-to-use proprietary features like ActiveX[1]. Users could use ActiveX controls and the ActiveXObject object to directly call system APIs for privileged operations like file reading and writing. It is worth noting that in 1996, desktop application development was still in its infancy, and nobody was concerned about security issues. This stemmed from Microsoft’s vision of shaping IE as another Windows development platform, since HTML is well-suited for building user interfaces and JS is easy to learn. At the time, Visual Basic (VB) was easy to use, but achieving artistic UI required using numerous obscure Windows APIs for custom drawing, event handling, and more. The combination of C++ and the Win32 API was even more of a disaster; the \u003Ccode>CreateWindow\u003C/code> function alone required filling in a full 11 parameters[2], compounded by the difficulty of C++. So Microsoft decided to turn IE into another development platform. At the time, Microsoft’s competitor, the Netscape browser, supported NPAPI and Java applets, which were based on open standards but could do less than IE. NPAPI could call system APIs, but users needed to install a specific browser plugin on demand. Java applets had even more restricted permissions.\u003C/p>\n\u003Cp>This is how Microsoft gained another Windows technology development platform. However, because the web page ran inside a browser, it always had an unremovable browser chrome. Around that time, Microsoft’s programmers had also been suffering from VB and C++ for a long time, and they were actively exploring the possibility of writing applications using HTML. For example, using HTML as the interface for C++ applications via \u003Ccode>CHtmlView\u003C/code>, and the “DHTML Application” project type in VB, which compiled VB code into visually hidden ActiveX controls for JS to call. There was also Microsoft(R) HTML Application Host (MSHTA)[3], released alongside IE 5.0 in 1999. It is a component provided by Microsoft for creating HTML applications. It allows developers to build fully functional desktop applications using HTML, CSS, and JavaScript, called HTML Applications (HTA). HTA can only run on Windows and can access the operating system’s file system APIs. Most importantly, HTA has no browser chrome and looks like a regular desktop application. It also provides the \u003Ccode>HTA:APPLICATION\u003C/code> tag to control application characteristics, such as using a specific window frame, setting whether to show maximize and minimize buttons, and so on.\u003C/p>\n\u003Cp>At the time, other operating systems like Linux and macOS did not provide functionality similar to HTA, because people on those platforms focused on performance and overlooked hobbyist developers, considering C++ and other languages better solutions for writing applications.\u003C/p>\n\u003Cp>Due to constant pressure from third-party developers and competition from Netscape, Microsoft kept developing new features for IE. However, because standardization efforts for technologies like HTML 4.01 had stalled, Microsoft had to release IE’s new features as proprietary extensions, and submitted many features to the W3C requesting standardization. Small changes like \u003Ccode>innerHTML\u003C/code> were usually accepted, but larger features like IE-specific filters and Vector Markup Language (VML) were usually rejected. By the time IE 6 was released in 2001, IE’s market share had reached an astonishing 98%. However, HTML is a public standard, not something Microsoft could control alone. So, for profit, Microsoft decided to stop actively developing IE and instead shifted focus to Microsoft’s (at that time, proprietary and Windows-only) .NET platform, launching technologies like WinForms and WPF. Meanwhile, HTA’s development stalled along with IE’s development.\u003C/p>\n\u003Ch2 id=\"phonegap-and-cordova\">PhoneGap and Cordova\u003C/h2>\n\u003Cp>While HTA was stalling on the desktop, HTML applications found new life on another battlefield. In 2008, as the iPhone ushered in the smartphone era, developers faced an awkward situation: iOS native development required Objective-C, Android required Java, and each platform required separate application code. While web technologies could run in mobile browsers, they could not access hardware functions like the camera, GPS, or contacts.\u003C/p>\n\u003Cp>In 2009, Brian Leroux and others at Nitobi developed PhoneGap[4]. This was a clever hack: it embedded a WebView control in a native application, using HTML/CSS/JavaScript as the UI layer, then calling underlying native APIs through a JavaScript Bridge. Developers only needed to write one set of web code to package native applications for multiple platforms like iOS, Android, and BlackBerry.\u003C/p>\n\u003Cp>PhoneGap’s core innovation was the Hybrid App pattern. Unlike HTA, which directly called system APIs, PhoneGap exposed native capabilities to JavaScript through a plugin architecture. For example, for the camera feature, PhoneGap provided a unified JavaScript API, while the underlying code called iOS’s UIImagePickerController or Android’s Camera Intent respectively. This abstraction allowed web developers to build “native-like” applications without learning native languages.\u003C/p>\n\u003Cp>In 2011, Adobe acquired Nitobi and donated PhoneGap’s core code to the Apache Foundation, renaming it Apache Cordova[5]. This move ensured the technology’s openness, but also sowed the seeds of division. Adobe retained the PhoneGap brand and launched the cloud-based PhoneGap Build service, while Cordova became a community-driven open-source project.\u003C/p>\n\u003Cp>Cordova quickly became one of the mainstream solutions for mobile development. Its advantages were clear: low development cost (one codebase across platforms), low technical barrier (web developers could get started easily), and a rich ecosystem (tens of thousands of plugins on npm). Many well-known apps from the mid-2010s, such as Instagram, Uber, and early versions of Wikipedia, used Cordova or its derivatives.\u003C/p>\n\u003Cp>However, Cordova’s limitations became increasingly apparent. First, there was the performance issue. WebView rendering performance never matched native UI, and complex list scrolling and animations often stuttered. Second, there was the experience gap. Although apps could be packaged as APKs or IPAs, their interface styles differed noticeably from native apps, and users could clearly tell “this is a web page in a shell.” More serious was the plugin dependency. Whenever iOS or Android released a new system version, Cordova plugins needed separate updates, and many plugins were maintained by individuals, with updates lagging or even being abandoned, causing apps to fail to adapt to new systems in a timely manner.\u003C/p>\n\u003Ch2 id=\"capacitor\">Capacitor\u003C/h2>\n\u003Cp>In 2018, the Ionic team launched Capacitor[6], as Cordova’s spiritual successor. It retained the basic hybrid app architecture of WebView rendering plus Native Bridge, but made modernized improvements in design.\u003C/p>\n\u003Cp>Capacitor’s biggest change was embracing modern web standards. It no longer depended on a specific framework and supported any frontend toolchain (React, Vue, Angular, Svelte, etc.). More importantly, it leveraged the Progressive Web Apps (PWA) technology stack: Service Workers for offline support, Web App Manifest for installation configuration. This meant the same Capacitor app could be distributed as a native app to app stores or as a PWA directly through the browser.\u003C/p>\n\u003Cp>Architecturally, Capacitor simplified the plugin system. Cordova plugins required writing complex native code for each platform, while Capacitor encouraged implementing functionality in JavaScript, only calling native APIs when necessary. It also provided a clearer Native Bridge with TypeScript type definitions, making communication between the web and native layers more reliable.\u003C/p>\n\u003Cp>But Capacitor did not solve the fundamental contradiction of hybrid apps: the WebView performance ceiling. Although modern WebViews (WKWebView on iOS, WebView based on Chromium on Android) have significantly improved performance, in heavy graphics scenarios (3D games, video editing, complex animations), they still cannot compete with native solutions or frameworks like React Native and Flutter.\u003C/p>\n\u003Cp>Additionally, both Capacitor and Cordova faced app store review risks. In the 2020s, Apple intensified restrictions on “shell apps” (App Wrappers). If an app’s content is primarily web-based and functions are no different from the website, it may be rejected from the store. This forced developers to either provide richer functionality on the web layer than on the website, or switch to native rendering solutions.\u003C/p>\n\u003Ch2 id=\"winjs-and-windows-8\">WinJS and Windows 8\u003C/h2>\n\u003Cp>Returning to the desktop. Although HTA had stalled, Microsoft did not give up on building desktop applications with web technologies. In 2012, with the release of Windows 8, Microsoft launched WinJS (Windows Library for JavaScript)[7]. This is a JavaScript library designed specifically for Windows Store apps (Metro/Modern UI apps), allowing developers to write native Windows applications using HTML, CSS, and JavaScript.\u003C/p>\n\u003Cp>Unlike HTA, WinJS apps ran on the new Windows Runtime (WinRT) rather than traditional Win32 APIs. They had true native application permissions, could access file systems, cameras, sensors, and other hardware, while maintaining the development experience of web technologies. Microsoft even open-sourced WinJS, trying to attract web developers into the Windows ecosystem.\u003C/p>\n\u003Cp>However, Windows 8’s Metro interface was highly controversial, and users and developers preferred traditional desktop apps. WinJS apps were restricted to distribution through the app store and could not run on older systems like Windows 7. With the failure of Windows 10’s unified platform strategy, WinJS was gradually marginalized by Microsoft, becoming another abandoned attempt at web-based desktop solutions.\u003C/p>\n\u003Cp>It is worth noting that WinJS’s philosophy was similar to Cordova/Capacitor: both were hybrids of web technology plus native runtime. But WinJS was limited to the Windows platform, while Cordova grabbed the pain point of mobile cross-platform development, so their fates were completely different.\u003C/p>\n\u003Ch2 id=\"node-webkit-and-nwjs\">node-webkit and NW.js\u003C/h2>\n\u003Cp>The real turning point came from the open-source community. In 2011, Roger Wang from Intel’s Open Source Technology Center launched the node-webkit project[8]. This was a bold innovation: it bundled the Node.js runtime with the WebKit rendering engine, allowing developers to write applications using web technologies while accessing underlying system APIs through Node.js.\u003C/p>\n\u003Cp>What did this mean? Developers could finally build interfaces with HTML, write logic with JavaScript, and like traditional desktop applications, read and write files, access databases, call system commands, and all of this was cross-platform, running on Windows, macOS, and Linux. In 2014, the project was renamed NW.js to better reflect its technical essence.\u003C/p>\n\u003Cp>NW.js solved several pain points from the MSHTA era. First, it was based on a modern WebKit engine, supporting HTML5 and CSS3 rather than the outdated IE engine. Second, it was truly cross-platform, no longer restricted to Windows. Most importantly, it brought Node.js’s ecosystem to desktop development, allowing developers to use the hundreds of thousands of packages on npm.\u003C/p>\n\u003Cp>However, NW.js had its limitations. Its architecture injected the entire Node.js runtime into the web environment, causing context confusion and blurred lines between the main process and renderer processes. Each window was an independent renderer process, but they shared the same Node.js context, which could easily lead to performance issues and memory leaks in complex applications.\u003C/p>\n\u003Ch2 id=\"electron\">Electron\u003C/h2>\n\u003Cp>In 2013, Cheng Zhao at GitHub developed Atom Shell based on Chromium Content Module and Node.js, aiming to provide a framework for the Atom editor[9]. In 2015, the project was renamed Electron. Unlike NW.js, Electron adopted a clearer multi-process architecture: the main process (Node.js environment) handled system-level operations, the renderer process (Chromium environment) handled UI display, and the two communicated through IPC (Inter-Process Communication).\u003C/p>\n\u003Cp>This separation brought several key advantages. First, improved stability, where a single window crash would not affect the entire application. Second, improved security, where renderer processes ran in sandbox by default and needed explicit APIs to access system resources. Most importantly, developers could precisely control application lifecycle and resource allocation.\u003C/p>\n\u003Cp>Electron quickly became the de facto standard for HTML desktop applications. Well-known apps like Slack, VS Code, Discord, and Figma were all built on Electron. It even fed back into web technologies themselves; VS Code’s popularity drove the adoption of TypeScript and the Language Server Protocol, and Electron’s cross-platform capabilities allowed small teams to develop desktop software with full platform support.\u003C/p>\n\u003Cp>But Electron was not without criticism. Each application bundled a complete Chromium and Node.js, resulting in large installation package sizes (typically over 100MB) and high memory usage.\u003C/p>\n\u003Ch2 id=\"pwa\">PWA\u003C/h2>\n\u003Cp>While Electron dominated the desktop, browser vendors were exploring another path: giving web applications themselves offline capabilities and system access. In 2015, Google proposed the Progressive Web Apps (PWA) concept[10], which was subsequently supported by Microsoft, Apple, and others.\u003C/p>\n\u003Cp>PWA achieves offline caching through Service Workers, provides native-like app installation experience through Web App Manifest, and gradually expands system access capabilities through a series of Web APIs (File System Access API, Contacts API, Bluetooth API, etc.). In theory, PWA can “write once, run everywhere,” without bundling a browser kernel, has a lightweight footprint, and can be distributed directly through app stores or browsers.\u003C/p>\n\u003Cp>Microsoft actively supported PWA on Windows 10/11, allowing distribution through the Microsoft Store, somewhat returning to WinJS’s original intent. However, PWA faces many limitations in practice.\u003C/p>\n\u003Cp>First, there is the fundamental flaw in offline capabilities. Service Worker offline caching depends on the browser downloading resources in advance, making it more suitable for “enhanced web pages” rather than truly offline applications. If the user’s network is unstable during the first visit, or if the caching strategy is improperly configured, the application may not start at all. This is fundamentally different from the Electron app experience of “download and run offline.”\u003C/p>\n\u003Cp>Second, there is the distribution dilemma. Although PWA can be distributed through app stores, policies vary across platforms. Apple imposes strict restrictions on PWA on iOS, not allowing third-party browser engines, and PWA cannot use full Web Push and other features. More importantly, PWA cannot distribute installation packages directly like traditional desktop applications; users must obtain them through browsers or app stores, which is very inflexible in enterprise intranet environments or scenarios requiring specific version control.\u003C/p>\n\u003Cp>Third, there are limitations in system integration. PWA runs in a browser sandbox. Although Web APIs are continuously expanding, many low-level operations still cannot be achieved: cannot listen to global hotkeys, cannot create system tray icons, cannot keep processes running in the background, cannot access certain hardware interfaces. For advanced features requiring deep system integration, PWA still falls short.\u003C/p>\n\u003Cp>Fourth, there is platform difference fragmentation. Different browsers have varying levels of support for Web APIs, and developers still need to deal with compatibility issues. Moreover, PWA is always confined to the browser window frame; it cannot create truly frameless windows or customize native menu bars, features that are commonplace in desktop applications but difficult to implement in PWA.\u003C/p>\n\u003Cp>Therefore, PWA is more suitable for content-based, occasionally offline applications, not complex productivity tools. It failed to replace Electron; instead, they formed a complementary relationship: PWA for lightweight scenarios, Electron for heavy desktop applications.\u003C/p>\n\u003Ch2 id=\"post-electron-era\">Post-Electron Era\u003C/h2>\n\u003Cp>Electron’s bloat problem became increasingly prominent in the 2020s. A “Hello World” level Electron application can have a size of 150MB or more, with startup memory usage in the hundreds of megabytes. This is acceptable on modern devices with abundant SSD storage and memory, but becomes a pain point on low-end devices or scenarios that prioritize resource efficiency.\u003C/p>\n\u003Cp>The deeper problem is technical debt. Electron is deeply bound to specific versions of Node.js and Chromium, making it difficult to adapt to new developments in JavaScript runtimes. When new-generation runtimes like Deno (2018) and Bun (2022) emerged, they provided more secure permission models, better native TypeScript support, and significant performance improvements, but Electron’s architecture cannot directly leverage these advantages. Electron applications are trapped in Node.js’s ecosystem and cannot enjoy the latest developments in JS infrastructure.\u003C/p>\n\u003Cp>This sparked exploration of a series of alternatives.\u003C/p>\n\u003Cp>Tauri[11] uses a lightweight backend written in Rust, using the operating system’s native WebView for frontend rendering. Windows uses WebView2, macOS uses WKWebView, and Linux uses WebKitGTK. Since bundling a browser kernel is unnecessary, application sizes can be compressed to 3 to 5MB, and memory usage is significantly reduced. However, Tauri requires developers to use Rust for system interactions, which is a barrier for pure web developers. Although it provides JavaScript APIs, complex functionality still requires diving deep into the Rust ecosystem, losing the convenience of full-stack JavaScript.\u003C/p>\n\u003Cp>WebUI[12] is a C language-written cross-platform library that does not bundle a browser kernel but uses browsers already installed on the user’s computer as the rendering engine. Chrome, Firefox, and Edge can all be used, communicating with the local backend via WebSocket. The size is extremely small, just a single executable. But it is limited by the browser window; it cannot create truly frameless applications, cannot disable the browser’s developer tools, and the interface always carries traces of the browser. Relying on an external browser also means rendering consistency cannot be guaranteed; different browser versions may cause compatibility issues.\u003C/p>\n\u003Cp>Wails[13] is similar to Tauri, but uses Go as the backend language, also relying on native WebView. It solves the size problem but locks developers into the Go ecosystem.\u003C/p>\n\u003Cp>Flutter Desktop and React Native Desktop abandon the web technology stack altogether, using self-drawn rendering engines. Although they have excellent performance, they lose the openness and ecosystem advantages of web development.\u003C/p>\n\u003Cp>The common dilemma of these solutions is: keeping the web technology stack results in large sizes, reducing size introduces native language barriers, keeping it lightweight limits it to browser windows. No one has found the perfect balance point.\u003C/p>\n\u003Ch2 id=\"new-possibilities\">New Possibilities\u003C/h2>\n\u003Cp>Facing this dilemma, I developed two experimental projects to explore different paths.\u003C/p>\n\u003Cp>node-ps1-dotnet[14] is a desktop application framework based on Node.js and PowerShell. It leverages the ubiquitous PowerShell and .NET runtime on Windows, allowing Node.js applications to call complete Windows APIs and .NET class libraries without bundling Chromium. The frontend can use the system’s built-in WebView2, while the backend deeply integrates with the system through PowerShell scripts. This significantly reduces application size while maintaining the JavaScript and TypeScript development experience.\u003C/p>\n\u003Cp>node-with-gjs[15] is the corresponding solution for Linux. GJS is GNOME project’s JavaScript binding, allowing the use of JavaScript to call GTK and native system APIs.\u003C/p>\n\u003Cp>The core idea of these two projects is to use runtimes that already exist on the operating system, rather than bundling their own browser and Node.js runtime. This greatly reduces distribution size while allowing deep integration of system capabilities. They adapt not only to Node.js but also to Deno and Bun, and provide first-class support for GUI development and WebView development, with ready-to-use examples.\u003C/p>\n\u003Cp>However, they are currently limited to specific platforms. node-ps1-dotnet mainly targets Windows, and node-with-gjs targets Linux. To build truly cross-platform applications, developers need to handle platform differences and write conditional code.\u003C/p>\n\u003Ch2 id=\"next-step\">Next Step\u003C/h2>\n\u003Cp>Based on the above exploration, I am developing a unified cross-platform abstraction layer. On Windows, it uses the \u003Ca href=\"https://github.com/DevScholar/node-ps1-dotnet\">node-ps1-dotnet\u003C/a> architecture, using WebView2 for interface rendering, and PowerShell and .NET for system interaction. On Linux, it uses the \u003Ca href=\"https://github.com/DevScholar/node-with-gjs\">node-with-gjs\u003C/a> architecture, using WebKitGTK for interface rendering, and GJS and GTK for system interaction.\u003C/p>\n\u003Cp>Currently, I do not plan to support macOS, because I cannot afford a MacBook and have not done development on macOS. However, if there is genuine demand, I can try installing an x86 Hackintosh virtual machine on my computer for development. Although newer macOS versions no longer release x86 versions, since my project does not use native code, only scripting languages and IPC, and Apple does not frequently change the JavaScript for Automation API, development should theoretically be possible.\u003C/p>\n\u003Cp>Developers only need to write one set of HTML, CSS, JavaScript frontend code, along with unified JavaScript API calls, without worrying about whether the underlying layer is PowerShell or GJS. The framework will automatically route system API calls to the corresponding platform’s native mechanism.\u003C/p>\n\u003Cp>This solution attempts to combine the advantages of various approaches: maintaining the openness and ecosystem of the web technology stack, significantly reducing application size, supporting deep system integration, and being able to adapt to new-generation JavaScript runtimes like Deno and Bun. The architecture no longer hardcodes Node.js but is abstracted as a general JS runtime interface.\u003C/p>\n\u003Cp>From MSHTA’s system binding, to Electron’s self-contained architecture, to new-generation solutions returning to native system capabilities, the technical trajectory of HTML desktop applications has gone through a cycle. MSHTA used the system’s existing runtimes, Electron chose to bundle everything, and new-generation solutions return to the approach of using system runtimes. This time, web standards are more mature, the open-source ecosystem is more complete, and developers have a deeper understanding of cross-platform development.\u003C/p>\n\u003Cp>HTML desktop applications are still evolving.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cstrong>References\u003C/strong>\u003C/p>\n\u003Cp>[1] IE 3.0: \u003Ca href=\"https://www.webdesignmuseum.org/software/internet-explorer-3-0-in-1996\">https://www.webdesignmuseum.org/software/internet-explorer-3-0-in-1996\u003C/a>\u003C/p>\n\u003Cp>[2] CreateWindowA: \u003Ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowa\">https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowa\u003C/a>\u003C/p>\n\u003Cp>[3] MSHTA: \u003Ca href=\"https://learn.microsoft.com/en-us/previous-versions/ms536496(v=vs.85)\">https://learn.microsoft.com/en-us/previous-versions/ms536496(v=vs.85)\u003C/a>\u003C/p>\n\u003Cp>[4] PhoneGap: \u003Ca href=\"https://phonegap.com/\">https://phonegap.com/\u003C/a>\u003C/p>\n\u003Cp>[5] Apache Cordova: \u003Ca href=\"https://cordova.apache.org/\">https://cordova.apache.org/\u003C/a>\u003C/p>\n\u003Cp>[6] Capacitor: \u003Ca href=\"https://capacitorjs.com/\">https://capacitorjs.com/\u003C/a>\u003C/p>\n\u003Cp>[7] WinJS: \u003Ca href=\"https://github.com/winjs/winjs\">https://github.com/winjs/winjs\u003C/a>\u003C/p>\n\u003Cp>[8] NW.js: \u003Ca href=\"https://nwjs.io/\">https://nwjs.io/\u003C/a>\u003C/p>\n\u003Cp>[9] Electron: \u003Ca href=\"https://www.electronjs.org/\">https://www.electronjs.org/\u003C/a>\u003C/p>\n\u003Cp>[10] Progressive Web Apps: \u003Ca href=\"https://web.dev/progressive-web-apps/\">https://web.dev/progressive-web-apps/\u003C/a>\u003C/p>\n\u003Cp>[11] Tauri: \u003Ca href=\"https://tauri.app/\">https://tauri.app/\u003C/a>\u003C/p>\n\u003Cp>[12] WebUI: \u003Ca href=\"https://webui.dev/\">https://webui.dev/\u003C/a>\u003C/p>\n\u003Cp>[13] Wails: \u003Ca href=\"https://wails.io/\">https://wails.io/\u003C/a>\u003C/p>\n\u003Cp>[14] node-ps1-dotnet: \u003Ca href=\"https://github.com/DevScholar/node-ps1-dotnet\">https://github.com/DevScholar/node-ps1-dotnet\u003C/a>\u003C/p>\n\u003Cp>[15] node-with-gjs: \u003Ca href=\"https://github.com/DevScholar/node-with-gjs\">https://github.com/DevScholar/node-with-gjs\u003C/a>\u003C/p>",{"headings":24,"localImagePaths":59,"remoteImagePaths":60,"frontmatter":61,"imagePaths":63},[25,28,32,35,38,41,44,47,50,53,56],{"depth":26,"slug":27,"text":14},1,"the-history-of-html-applications",{"depth":29,"slug":30,"text":31},2,"mshta","MSHTA",{"depth":29,"slug":33,"text":34},"phonegap-and-cordova","PhoneGap and Cordova",{"depth":29,"slug":36,"text":37},"capacitor","Capacitor",{"depth":29,"slug":39,"text":40},"winjs-and-windows-8","WinJS and Windows 8",{"depth":29,"slug":42,"text":43},"node-webkit-and-nwjs","node-webkit and NW.js",{"depth":29,"slug":45,"text":46},"electron","Electron",{"depth":29,"slug":48,"text":49},"pwa","PWA",{"depth":29,"slug":51,"text":52},"post-electron-era","Post-Electron Era",{"depth":29,"slug":54,"text":55},"new-possibilities","New Possibilities",{"depth":29,"slug":57,"text":58},"next-step","Next Step",[],[],{"title":14,"description":15,"pubDate":62,"author":17},"2026-02-24",[],"en-us/history-of-html-applications.md","zh-cn/history-of-html-applications",{"id":65,"data":67,"body":71,"filePath":72,"digest":73,"rendered":74,"legacyId":104},{"title":68,"description":69,"pubDate":70,"author":17},"HTML 应用发展史","探索 HTML 应用从 1990 年代至今的演变历程。",["Date","2026-02-24T00:00:00.000Z"],"# HTML 应用发展史\n\n本文所述 \"HTML 应用程序\"是指使用 HTML 技术开发的桌面应用程序，例如基于微软的 MSHTA 和 Electron 平台的应用程序。这种技术旨在使得 HTML 可以离线运行和分发，并赋予其桌面应用程序特有的操作系统 API 访问权限，比如文件操作或读写注册表。\n\n## MSHTA\n\n1996 年，微软发布了 Internet Explorer (IE) 3.0，它加入了 CSS 和 JS 等标准功能，但是也加入了 ActiveX 等开箱即用的私有功能[1]。用户可以利用 ActiveX 控件 和 ActiveXObject 对象直接调用系统 API，进行文件读写等特权操作。请注意在 1996 年，桌面应用程序开发才刚起步，没有人注意安全问题。这源于微软希望把 IE 塑造为又一个 Windows 开发平台的愿景，因为 HTML 很适合构建用户界面，JS 也很容易掌握。当时 Visual Basic (VB) 虽然易用，但是如果想要艺术化界面就需要用到大量晦涩难懂的 Windows API 进行自绘，事件处理等等。C++ 和 Win32 API 配合更是灾难，仅仅是`CreateWindow`函数就需要填入整整 11 个参数[2]，再叠加 C++ 的难度。于是微软决定把 IE 变成又一个开发平台。而当时 IE 的竞争对手网景浏览器 (Netscape) 支持 NPAPI 和 Java 小应用程序，它们基于开放标准，但是能做的事情比 IE 少。NPAPI 虽然可以调用系统 API，但是用户需按需安装某个浏览器插件。Java 小应用程序更是权限受限。\n\n就这样，微软多了一个 Windows 技术的开发平台。但是因为网页运行在浏览器里面，它始终有不可去除的浏览器边框。而这时，微软的程序员们也苦 VB 和 C++ 已久，他们也在积极探索利用 HTML 编写应用程序的可能性，例如用 HTML 作为 C++ 应用程序界面的`CHtmlView`，以及 VB 中的\"DHTML 应用程序\"项目类型，把 VB 代码编译为视觉上隐藏的 ActiveX 控件给 JS 调用。以及随 IE5.0（1999 年）一同推出的 Microsoft (R) HTML 应用程序主机 (MSHTA)[3]。它是微软提供的一个用于创建 HTML 应用程序的组件。它允许开发人员使用 HTML、CSS 和 JavaScript 来构建功能完善的桌面应用程序，称为 HTML 应用程序 (HTA)。HTA 只能在 Windows 操作系统上运行，可以访问操作系统的文件系统的 API。最重要的是，HTA 没有浏览器边框，看上去就像普通的桌面应用程序一样。而且它提供了`HTA:APPLICATION`标签，可以控制应用程序的特性，比如使用某种特定的窗口边框，设置是否显示最大化和向下还原按钮等。\n\n当时，其他操作系统，比如 Linux 和 macOS，并没有提供类似 HTA 的功能，因为这些平台上的人注重性能而忽略业余开发者，认为 C++ 等是编写应用程序的更好方案。\n\n由于第三方开发者不断催促微软，再加上网景浏览器的竞争，于是微软不断为 IE 开发新功能。但是因为 HTML 4.01 等标准化技术发展停滞，于是微软不得不以专有扩展的形式发布 IE 的新功能，还将许多功能提交给 W3C 请求标准化。`innerHTML`等小型变更通常被接受，但是例如 IE 特有滤镜和矢量图形标记语言 (VML) 等大型功能通常被拒绝。等到 IE 6 发布（2001 年），IE 的市占率已达到惊人的 98%。但是 HTML 属于公开标准，并非微软一家所能控制。于是，为了盈利，微软决定停止积极开发 IE，而是转而将力量投入微软的（在那时是专有且仅限 Windows 运行的）.NET 平台当中，推出了 WinForms 和 WPF 等多项技术。而 HTA 的发展则随着 IE 的发展陷入停滞。\n\n## PhoneGap 与 Cordova\n\n当桌面端的 HTA 陷入停滞时，HTML 应用却在另一个战场找到了生机。2008 年，随着 iPhone 开启智能手机时代，开发者面临一个尴尬局面：iOS 原生开发需要 Objective-C，Android 需要 Java，每个平台都要单独编写应用。而 Web 技术虽然可以运行在移动浏览器中，但无法访问相机、GPS、联系人等硬件功能。\n\n2009 年，Nitobi 公司的 Brian Leroux 等人开发了 PhoneGap[4]。这是一个巧妙的 hack：它在原生应用中嵌入一个 WebView 控件，让 HTML/CSS/JavaScript 作为界面层，然后通过 JavaScript Bridge 调用底层的原生 API。开发者只需编写一套 Web 代码，就能打包成 iOS、Android、BlackBerry 等多个平台的原生应用。\n\nPhoneGap 的核心创新在于**混合应用 (Hybrid App)**模式。它不像 HTA 那样直接调用系统 API，而是通过插件架构将原生能力暴露给 JavaScript。比如相机功能，PhoneGap 提供统一的 JavaScript API，底层则分别调用 iOS 的 UIImagePickerController 或 Android 的 Camera Intent。这种抽象让 Web 开发者无需学习原生语言，就能构建\"类原生\"应用。\n\n2011 年，Adobe 收购了 Nitobi，并将 PhoneGap 的核心代码捐赠给 Apache 基金会，更名为 Apache Cordova[5]。这一举措确保了技术的开放性，但也埋下了分裂的种子。Adobe 保留了 PhoneGap 的品牌，推出基于云的 PhoneGap Build 服务，而 Cordova 则成为社区驱动的开源项目。\n\nCordova 迅速成为移动开发的主流方案之一。它的优势显而易见：开发成本低（一套代码跨平台）、技术门槛低（Web 开发者即可上手）、生态丰富（npm 上的插件数以万计）。2010 年代中期的许多知名应用，如 Instagram、Uber、Wikipedia 的早期版本，都曾使用 Cordova 或其衍生技术。\n\n然而，Cordova 的局限也日益明显。首先是**性能问题**。WebView 的渲染性能始终不如原生 UI，复杂列表滚动、动画效果经常出现卡顿。其次是**体验割裂**。虽然应用可以打包成 APK 或 IPA，但界面风格与原生应用差异明显，用户能明显察觉\"这是一个套了壳的网页\"。更严重的是**插件依赖**。每当 iOS 或 Android 发布新系统版本，Cordova 插件需要单独更新，而许多插件由个人维护，更新滞后甚至 abandoned，导致应用无法及时适配新系统。\n\n## Capacitor\n\n2018 年，Ionic 团队推出了 Capacitor[6]，作为 Cordova 的精神继承者。它保留了混合应用的基本架构，也就是 WebView 渲染 + Native Bridge，但在设计上做了现代化改进。\n\nCapacitor 最大的变化是**拥抱现代 Web 标准**。它不再依赖特定框架，支持任何前端工具链（React、Vue、Angular、Svelte 均可）。更重要的是，它利用了 Progressive Web Apps (PWA) 的技术栈：Service Worker 用于离线支持，Web App Manifest 用于安装配置。这意味着同一个 Capacitor 应用，既可以作为原生应用分发到应用商店，也可以作为 PWA 直接通过浏览器访问。\n\n在架构上，Capacitor 简化了插件系统。Cordova 的插件需要为每个平台编写复杂的原生代码，而 Capacitor 鼓励使用 JavaScript 实现功能，仅在必要时调用原生 API。它还提供了更清晰的 Native Bridge，支持 TypeScript 类型定义，让 Web 与原生层的通信更可靠。\n\n但 Capacitor 并未解决混合应用的根本矛盾：**WebView 的性能天花板**。虽然现代 WebView（iOS 的 WKWebView、Android 的 WebView 基于 Chromium）性能已大幅提升，但在重度图形场景（3D 游戏、视频编辑、复杂动画）下，仍无法与原生或 React Native、Flutter 等方案竞争。\n\n此外，Capacitor 和 Cordova 都面临**应用商店的审查风险**。苹果在 2020 年代加强了对\"壳应用\"（App Wrapper）的限制，如果应用内容主要是网页，且功能与网站无异，可能被拒绝上架。这迫使开发者必须在 Web 层提供比网站更丰富的功能，或转向原生渲染方案。\n\n## WinJS 与 Windows 8\n\n回到桌面端。HTA 虽然停滞，但微软并未放弃用 Web 技术构建桌面应用的尝试。2012 年，随着 Windows 8 的发布，微软推出了 WinJS（Windows Library for JavaScript）[7]。这是一个专为 Windows 应用商店应用（Metro/Modern UI 应用）设计的 JavaScript 库，允许开发者使用 HTML、CSS 和 JavaScript 编写原生 Windows 应用。\n\n与 HTA 不同，WinJS 应用运行在全新的 Windows Runtime（WinRT）之上，而非传统的 Win32 API。它们拥有真正的原生应用权限，可以访问文件系统、摄像头、传感器等硬件，同时保持了 Web 技术的开发体验。微软甚至将 WinJS 开源，试图吸引 Web 开发者进入 Windows 生态系统。\n\n然而，Windows 8 的 Metro 界面饱受争议，用户和开发者更青睐传统的桌面应用。WinJS 应用被限制在应用商店中分发，且无法运行在 Windows 7 等旧系统上。随着 Windows 10 统一平台战略的失败，WinJS 也逐渐被微软边缘化，成为又一个被遗弃的 Web 桌面化尝试。\n\n值得注意的是，WinJS 的理念与 Cordova/Capacitor 有相似之处：都是 Web 技术 + 原生运行时的混合。但 WinJS 局限于 Windows 平台，而 Cordova 抓住了移动跨平台的痛点，因此命运截然不同。\n\n## node-webkit 与 NW.js\n\n真正的转机来自开源社区。2011 年，英特尔开源技术中心的 Roger Wang 启动了 node-webkit 项目[8]。这是一个大胆的创新：它将 Node.js 运行时与 WebKit 渲染引擎捆绑在一起，让开发者可以用 Web 技术编写应用，同时通过 Node.js 访问底层系统 API。\n\n这意味着什么？开发者终于可以用 HTML 构建界面，用 JavaScript 编写逻辑，并且像传统桌面应用一样读写文件、访问数据库、调用系统命令，而且这一切是跨平台的，可以在 Windows、macOS 和 Linux 上运行。2014 年，项目更名为 NW.js，以更好地反映其技术本质。\n\nNW.js 解决了 MSHTA 时代的几个痛点：首先，它基于现代的 WebKit 内核，支持 HTML5 和 CSS3，而非老旧的 IE 引擎；其次，它是真正的跨平台，不再受制于 Windows；最重要的是，它将 Node.js 的生态系统带入了桌面开发，开发者可以使用 npm 上数十万个包。\n\n然而，NW.js 也有其局限。它的架构是将整个 Node.js 运行时注入 Web 环境，这导致上下文混乱，主进程和渲染进程的界限模糊。每个窗口都是一个独立的渲染进程，但共享同一个 Node.js 上下文，这在复杂应用中容易引发性能问题和内存泄漏。\n\n## Electron\n\n2013 年，GitHub 的 Cheng Zhao 基于 Chromium Content Module 和 Node.js 开发了 Atom Shell，旨在为 Atom 编辑器提供框架[9]。2015 年，项目更名为 Electron。与 NW.js 不同，Electron 采用了更清晰的多进程架构：主进程（Node.js 环境）负责系统级操作，渲染进程（Chromium 环境）负责界面展示，两者通过 IPC（进程间通信）交互。\n\n这种分离带来了几个关键优势。首先，稳定性提升，单个窗口的崩溃不会影响整个应用；其次，安全性改善，渲染进程默认运行在沙箱中，需要通过显式 API 才能访问系统资源；最重要的是，开发者可以精确控制应用的生命周期和资源分配。\n\nElectron 迅速成为 HTML 桌面应用的事实标准。Slack、VS Code、Discord、Figma 等知名应用都基于 Electron 构建。它甚至反哺了 Web 技术本身，VS Code 的流行推动了 TypeScript 和 Language Server Protocol 的普及，而 Electron 的跨平台能力让小型团队也能开发出全平台支持的桌面软件。\n\n但 Electron 并非没有批评。每个应用都捆绑完整的 Chromium 和 Node.js，导致安装包体积庞大（通常超过 100MB），内存占用高。\n\n## PWA\n\n在 Electron 统治桌面端的同时，浏览器厂商也在探索另一条路径：让 Web 应用本身具备离线能力和系统访问权限。2015 年，Google 提出了 Progressive Web Apps (PWA) 概念[10]，随后得到了微软、苹果等厂商的支持。\n\nPWA 通过 Service Worker 实现离线缓存，通过 Web App Manifest 提供类原生应用的安装体验，还通过一系列 Web API（File System Access API、Contacts API、Bluetooth API 等）逐步扩展系统访问能力。理论上，PWA 可以\"一次编写，到处运行\"，无需捆绑浏览器内核，体积轻量，且能通过应用商店或浏览器直接分发。\n\n微软在 Windows 10/11 中积极支持 PWA，允许其通过 Microsoft Store 分发，某种程度上回归了 WinJS 的初心。然而，PWA 在实际应用中面临诸多限制：\n\n首先是**离线能力的本质缺陷**。Service Worker 的离线缓存依赖于浏览器事先下载资源，它更适合\"增强型网页\"而非真正的离线应用。一旦用户首次访问时网络不畅，或者缓存策略配置不当，应用可能根本无法启动。这与 Electron 应用\"下载即可离线运行\"的体验有本质区别。\n\n其次是**分发的困境**。虽然 PWA 可以通过应用商店分发，但各平台政策不一。苹果对 iOS 上的 PWA 限制极严，不允许第三方浏览器引擎，PWA 无法使用完整的 Web Push 等功能。更重要的是，PWA 无法像传统桌面应用那样直接分发安装包，用户必须通过浏览器或应用商店获取，这在企业内网环境或需要特定版本控制的场景下极不灵活。\n\n再者是**系统集成的局限**。PWA 运行在浏览器沙箱中，虽然 Web API 在不断扩展，但许多底层操作仍无法实现：无法监听全局快捷键、无法创建系统托盘图标、无法在后台保持进程运行、无法访问某些硬件接口。对于需要深度系统集成的高级功能，PWA 仍然力不从心。\n\n最后是**平台差异的碎片化**。不同浏览器对 Web API 的支持程度不一，开发者仍需处理兼容性问题。而且 PWA 始终受限于浏览器窗口的框架，它无法创建真正的无边框窗口，无法自定义原生菜单栏，这些在桌面应用中习以为常的功能在 PWA 中难以实现。\n\n因此，PWA 更适合内容型、偶尔离线的应用，而非功能复杂的生产力工具。它未能替代 Electron，反而与 Electron 形成了互补：轻量级场景用 PWA，重度桌面应用仍需要 Electron。\n\n## 后 Electron 时代\n\nElectron 的臃肿问题在 2020 年代愈发突出。一个\"Hello World\"级别的 Electron 应用体积可达 150MB 以上，启动内存占用数百兆。这在 SSD 和内存充裕的现代设备上尚可接受，但在低配设备或注重资源效率的场景下成为痛点。\n\n更深层的问题是技术债务。Electron 深度绑定 Node.js 和 Chromium 的特定版本，难以适配 JavaScript 运行时的新发展。当 Deno（2018）和 Bun（2022）等新一代运行时出现时，它们提供了更安全的权限模型、更好的 TypeScript 原生支持、显著的性能提升，但 Electron 的架构无法直接利用这些优势。Electron 应用被困在 Node.js 的生态中，无法享受 JS 基础设施的最新成果。\n\n这催生了一系列替代方案的探索。\n\nTauri[11] 采用 Rust 编写的轻量级后端，使用操作系统原生的 WebView 渲染前端。Windows 上用的是 WebView2，macOS 上用 WKWebView，Linux 上用 WebKitGTK。由于不需要捆绑浏览器内核，应用体积可以压缩到 3 到 5MB，内存占用也大幅降低。不过 Tauri 要求开发者用 Rust 处理系统交互，这对纯 Web 开发者来说是个门槛。虽然它提供了 JavaScript API，但复杂功能仍然需要深入 Rust 生态，这就失去了全栈 JavaScript 的便利性。\n\nWebUI[12] 是一个 C 语言编写的跨平台库，它不用捆绑浏览器内核，而是调用用户电脑上已经安装的浏览器作为渲染引擎。Chrome、Firefox、Edge 都可以用，通过 WebSocket 和本地后端通信。体积极小，只有一个可执行文件。但它受限于浏览器窗口，无法创建真正的无边框应用，也无法禁用浏览器的开发者工具，界面始终带有浏览器的痕迹。依赖外部浏览器还意味着无法保证渲染一致性，不同版本的浏览器可能导致兼容性问题。\n\nWails[13] 和 Tauri 类似，不过后端用的是 Go 语言，同样依赖原生 WebView。它解决了体积问题，但把开发者锁定在了 Go 生态中。\n\nFlutter Desktop 和 React Native Desktop 则放弃了 Web 技术栈，改用自绘渲染引擎。虽然性能优秀，但失去了 Web 开发的开放性和生态优势。\n\n这些方案的共同困境在于：保持 Web 技术栈就体积庞大，缩小体积就引入原生语言门槛，保持轻量就受限于浏览器窗口。没有人找到完美的平衡点。\n\n## 新的可能性\n\n面对这一困境，我开发了两个实验性项目，试图探索不同的路径。\n\nnode-ps1-dotnet[14] 是一个基于 Node.js 和 PowerShell 的桌面应用框架。它利用 Windows 上无处不在的 PowerShell 和 .NET 运行时，让 Node.js 应用能够调用完整的 Windows API 和 .NET 类库，而无需捆绑 Chromium。前端可以使用系统内置的 WebView2，后端则通过 PowerShell 脚本与系统深度集成。这显著减小了应用体积，同时保持 JavaScript 和 TypeScript 的开发体验。\n\nnode-with-gjs[15] 则是面向 Linux 的对应方案。GJS 是 GNOME 项目的 JavaScript 绑定，允许使用 JavaScript 调用 GTK 和原生系统 API。\n\n这两个项目的核心思想是利用操作系统已存在的运行时，而不是捆绑自己的浏览器和 Node.js 运行时。这样做大幅减小了分发体积，同时允许应用深度集成系统功能。它们除了适配 Node.js，也适配 Deno 和 Bun，并且为 GUI 开发和 WebView 开发提供了第一等支持，有开箱即用的示例。\n\n不过它们目前仍局限于特定平台。node-ps1-dotnet 主要针对 Windows，node-with-gjs 针对 Linux。要构建真正的跨平台应用，开发者需要处理平台差异，编写条件代码。\n\n## 下一步\n\n基于以上探索，我正在开发一个统一的跨平台封装层。在 Windows 上，它使用 [node-ps1-dotnet](https://github.com/DevScholar/node-ps1-dotnet)，利用 WebView2 渲染界面，PowerShell 和 .NET 处理系统交互。在 Linux 上，它使用 [node-with-gjs](https://github.com/DevScholar/node-with-gjs)，利用 WebKitGTK 渲染界面，GJS 和 GTK 处理系统交互。\n\n目前我没有打算支持 macOS，因为我没有钱买 MacBook 也没有在 macOS 上做过开发。不过如果确实存在需求，我可以尝试在电脑上安装 x86 黑苹果虚拟机进行开发。虽然新版 macOS 不再推出 x86 版本，但由于我的项目不使用原生代码，只使用脚本语言和 IPC，并且苹果公司不会经常变更 JavaScript for Automation 的 API，理论上可以进行开发。\n\n开发者只需编写一套 HTML、CSS、JavaScript 前端代码，以及统一的 JavaScript API 调用，无需关心底层是 PowerShell 还是 GJS。框架会自动将系统 API 调用路由到对应平台的原生机制。\n\n这一方案试图结合各家的优点：保持 Web 技术栈的开放性和生态，显著减小应用体积，支持深度系统集成，并且能适配 Deno、Bun 等新一代 JavaScript 运行时。架构不再硬编码 Node.js，而是抽象为通用的 JS 运行时接口。\n\n从 MSHTA 的系统绑定，到 Electron 的自包含架构，再到新一代方案回归系统原生能力，HTML 桌面应用的技术路线经历了一个循环。MSHTA 利用系统已有的运行时，Electron 选择捆绑一切，新一代方案又回到利用系统运行时的思路。这一次，Web 标准更加成熟，开源生态也更完善，开发者对跨平台开发有了更深的理解。\n\nHTML 桌面应用仍然在发展。\n\n---\n\n**参考文献**\n\n[1] IE 3.0: https://www.webdesignmuseum.org/software/internet-explorer-3-0-in-1996\n\n[2] CreateWindowA: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowa\n\n[3] MSHTA: https://learn.microsoft.com/en-us/previous-versions/ms536496(v=vs.85)\n\n[4] PhoneGap: https://phonegap.com/\n\n[5] Apache Cordova: https://cordova.apache.org/\n\n[6] Capacitor: https://capacitorjs.com/\n\n[7] WinJS: https://github.com/winjs/winjs\n\n[8] NW.js: https://nwjs.io/\n\n[9] Electron: https://www.electronjs.org/\n\n[10] Progressive Web Apps: https://web.dev/progressive-web-apps/\n\n[11] Tauri: https://tauri.app/\n\n[12] WebUI: https://webui.dev/\n\n[13] Wails: https://wails.io/\n\n[14] node-ps1-dotnet: https://github.com/DevScholar/node-ps1-dotnet\n\n[15] node-with-gjs: https://github.com/DevScholar/node-with-gjs","src/content/devblogs/zh-cn/history-of-html-applications.md","34beaa694401955d",{"html":75,"metadata":76},"\u003Ch1 id=\"html-应用发展史\">HTML 应用发展史\u003C/h1>\n\u003Cp>本文所述 “HTML 应用程序”是指使用 HTML 技术开发的桌面应用程序，例如基于微软的 MSHTA 和 Electron 平台的应用程序。这种技术旨在使得 HTML 可以离线运行和分发，并赋予其桌面应用程序特有的操作系统 API 访问权限，比如文件操作或读写注册表。\u003C/p>\n\u003Ch2 id=\"mshta\">MSHTA\u003C/h2>\n\u003Cp>1996 年，微软发布了 Internet Explorer (IE) 3.0，它加入了 CSS 和 JS 等标准功能，但是也加入了 ActiveX 等开箱即用的私有功能[1]。用户可以利用 ActiveX 控件 和 ActiveXObject 对象直接调用系统 API，进行文件读写等特权操作。请注意在 1996 年，桌面应用程序开发才刚起步，没有人注意安全问题。这源于微软希望把 IE 塑造为又一个 Windows 开发平台的愿景，因为 HTML 很适合构建用户界面，JS 也很容易掌握。当时 Visual Basic (VB) 虽然易用，但是如果想要艺术化界面就需要用到大量晦涩难懂的 Windows API 进行自绘，事件处理等等。C++ 和 Win32 API 配合更是灾难，仅仅是\u003Ccode>CreateWindow\u003C/code>函数就需要填入整整 11 个参数[2]，再叠加 C++ 的难度。于是微软决定把 IE 变成又一个开发平台。而当时 IE 的竞争对手网景浏览器 (Netscape) 支持 NPAPI 和 Java 小应用程序，它们基于开放标准，但是能做的事情比 IE 少。NPAPI 虽然可以调用系统 API，但是用户需按需安装某个浏览器插件。Java 小应用程序更是权限受限。\u003C/p>\n\u003Cp>就这样，微软多了一个 Windows 技术的开发平台。但是因为网页运行在浏览器里面，它始终有不可去除的浏览器边框。而这时，微软的程序员们也苦 VB 和 C++ 已久，他们也在积极探索利用 HTML 编写应用程序的可能性，例如用 HTML 作为 C++ 应用程序界面的\u003Ccode>CHtmlView\u003C/code>，以及 VB 中的”DHTML 应用程序”项目类型，把 VB 代码编译为视觉上隐藏的 ActiveX 控件给 JS 调用。以及随 IE5.0（1999 年）一同推出的 Microsoft (R) HTML 应用程序主机 (MSHTA)[3]。它是微软提供的一个用于创建 HTML 应用程序的组件。它允许开发人员使用 HTML、CSS 和 JavaScript 来构建功能完善的桌面应用程序，称为 HTML 应用程序 (HTA)。HTA 只能在 Windows 操作系统上运行，可以访问操作系统的文件系统的 API。最重要的是，HTA 没有浏览器边框，看上去就像普通的桌面应用程序一样。而且它提供了\u003Ccode>HTA:APPLICATION\u003C/code>标签，可以控制应用程序的特性，比如使用某种特定的窗口边框，设置是否显示最大化和向下还原按钮等。\u003C/p>\n\u003Cp>当时，其他操作系统，比如 Linux 和 macOS，并没有提供类似 HTA 的功能，因为这些平台上的人注重性能而忽略业余开发者，认为 C++ 等是编写应用程序的更好方案。\u003C/p>\n\u003Cp>由于第三方开发者不断催促微软，再加上网景浏览器的竞争，于是微软不断为 IE 开发新功能。但是因为 HTML 4.01 等标准化技术发展停滞，于是微软不得不以专有扩展的形式发布 IE 的新功能，还将许多功能提交给 W3C 请求标准化。\u003Ccode>innerHTML\u003C/code>等小型变更通常被接受，但是例如 IE 特有滤镜和矢量图形标记语言 (VML) 等大型功能通常被拒绝。等到 IE 6 发布（2001 年），IE 的市占率已达到惊人的 98%。但是 HTML 属于公开标准，并非微软一家所能控制。于是，为了盈利，微软决定停止积极开发 IE，而是转而将力量投入微软的（在那时是专有且仅限 Windows 运行的）.NET 平台当中，推出了 WinForms 和 WPF 等多项技术。而 HTA 的发展则随着 IE 的发展陷入停滞。\u003C/p>\n\u003Ch2 id=\"phonegap-与-cordova\">PhoneGap 与 Cordova\u003C/h2>\n\u003Cp>当桌面端的 HTA 陷入停滞时，HTML 应用却在另一个战场找到了生机。2008 年，随着 iPhone 开启智能手机时代，开发者面临一个尴尬局面：iOS 原生开发需要 Objective-C，Android 需要 Java，每个平台都要单独编写应用。而 Web 技术虽然可以运行在移动浏览器中，但无法访问相机、GPS、联系人等硬件功能。\u003C/p>\n\u003Cp>2009 年，Nitobi 公司的 Brian Leroux 等人开发了 PhoneGap[4]。这是一个巧妙的 hack：它在原生应用中嵌入一个 WebView 控件，让 HTML/CSS/JavaScript 作为界面层，然后通过 JavaScript Bridge 调用底层的原生 API。开发者只需编写一套 Web 代码，就能打包成 iOS、Android、BlackBerry 等多个平台的原生应用。\u003C/p>\n\u003Cp>PhoneGap 的核心创新在于**混合应用 (Hybrid App)**模式。它不像 HTA 那样直接调用系统 API，而是通过插件架构将原生能力暴露给 JavaScript。比如相机功能，PhoneGap 提供统一的 JavaScript API，底层则分别调用 iOS 的 UIImagePickerController 或 Android 的 Camera Intent。这种抽象让 Web 开发者无需学习原生语言，就能构建”类原生”应用。\u003C/p>\n\u003Cp>2011 年，Adobe 收购了 Nitobi，并将 PhoneGap 的核心代码捐赠给 Apache 基金会，更名为 Apache Cordova[5]。这一举措确保了技术的开放性，但也埋下了分裂的种子。Adobe 保留了 PhoneGap 的品牌，推出基于云的 PhoneGap Build 服务，而 Cordova 则成为社区驱动的开源项目。\u003C/p>\n\u003Cp>Cordova 迅速成为移动开发的主流方案之一。它的优势显而易见：开发成本低（一套代码跨平台）、技术门槛低（Web 开发者即可上手）、生态丰富（npm 上的插件数以万计）。2010 年代中期的许多知名应用，如 Instagram、Uber、Wikipedia 的早期版本，都曾使用 Cordova 或其衍生技术。\u003C/p>\n\u003Cp>然而，Cordova 的局限也日益明显。首先是\u003Cstrong>性能问题\u003C/strong>。WebView 的渲染性能始终不如原生 UI，复杂列表滚动、动画效果经常出现卡顿。其次是\u003Cstrong>体验割裂\u003C/strong>。虽然应用可以打包成 APK 或 IPA，但界面风格与原生应用差异明显，用户能明显察觉”这是一个套了壳的网页”。更严重的是\u003Cstrong>插件依赖\u003C/strong>。每当 iOS 或 Android 发布新系统版本，Cordova 插件需要单独更新，而许多插件由个人维护，更新滞后甚至 abandoned，导致应用无法及时适配新系统。\u003C/p>\n\u003Ch2 id=\"capacitor\">Capacitor\u003C/h2>\n\u003Cp>2018 年，Ionic 团队推出了 Capacitor[6]，作为 Cordova 的精神继承者。它保留了混合应用的基本架构，也就是 WebView 渲染 + Native Bridge，但在设计上做了现代化改进。\u003C/p>\n\u003Cp>Capacitor 最大的变化是\u003Cstrong>拥抱现代 Web 标准\u003C/strong>。它不再依赖特定框架，支持任何前端工具链（React、Vue、Angular、Svelte 均可）。更重要的是，它利用了 Progressive Web Apps (PWA) 的技术栈：Service Worker 用于离线支持，Web App Manifest 用于安装配置。这意味着同一个 Capacitor 应用，既可以作为原生应用分发到应用商店，也可以作为 PWA 直接通过浏览器访问。\u003C/p>\n\u003Cp>在架构上，Capacitor 简化了插件系统。Cordova 的插件需要为每个平台编写复杂的原生代码，而 Capacitor 鼓励使用 JavaScript 实现功能，仅在必要时调用原生 API。它还提供了更清晰的 Native Bridge，支持 TypeScript 类型定义，让 Web 与原生层的通信更可靠。\u003C/p>\n\u003Cp>但 Capacitor 并未解决混合应用的根本矛盾：\u003Cstrong>WebView 的性能天花板\u003C/strong>。虽然现代 WebView（iOS 的 WKWebView、Android 的 WebView 基于 Chromium）性能已大幅提升，但在重度图形场景（3D 游戏、视频编辑、复杂动画）下，仍无法与原生或 React Native、Flutter 等方案竞争。\u003C/p>\n\u003Cp>此外，Capacitor 和 Cordova 都面临\u003Cstrong>应用商店的审查风险\u003C/strong>。苹果在 2020 年代加强了对”壳应用”（App Wrapper）的限制，如果应用内容主要是网页，且功能与网站无异，可能被拒绝上架。这迫使开发者必须在 Web 层提供比网站更丰富的功能，或转向原生渲染方案。\u003C/p>\n\u003Ch2 id=\"winjs-与-windows-8\">WinJS 与 Windows 8\u003C/h2>\n\u003Cp>回到桌面端。HTA 虽然停滞，但微软并未放弃用 Web 技术构建桌面应用的尝试。2012 年，随着 Windows 8 的发布，微软推出了 WinJS（Windows Library for JavaScript）[7]。这是一个专为 Windows 应用商店应用（Metro/Modern UI 应用）设计的 JavaScript 库，允许开发者使用 HTML、CSS 和 JavaScript 编写原生 Windows 应用。\u003C/p>\n\u003Cp>与 HTA 不同，WinJS 应用运行在全新的 Windows Runtime（WinRT）之上，而非传统的 Win32 API。它们拥有真正的原生应用权限，可以访问文件系统、摄像头、传感器等硬件，同时保持了 Web 技术的开发体验。微软甚至将 WinJS 开源，试图吸引 Web 开发者进入 Windows 生态系统。\u003C/p>\n\u003Cp>然而，Windows 8 的 Metro 界面饱受争议，用户和开发者更青睐传统的桌面应用。WinJS 应用被限制在应用商店中分发，且无法运行在 Windows 7 等旧系统上。随着 Windows 10 统一平台战略的失败，WinJS 也逐渐被微软边缘化，成为又一个被遗弃的 Web 桌面化尝试。\u003C/p>\n\u003Cp>值得注意的是，WinJS 的理念与 Cordova/Capacitor 有相似之处：都是 Web 技术 + 原生运行时的混合。但 WinJS 局限于 Windows 平台，而 Cordova 抓住了移动跨平台的痛点，因此命运截然不同。\u003C/p>\n\u003Ch2 id=\"node-webkit-与-nwjs\">node-webkit 与 NW.js\u003C/h2>\n\u003Cp>真正的转机来自开源社区。2011 年，英特尔开源技术中心的 Roger Wang 启动了 node-webkit 项目[8]。这是一个大胆的创新：它将 Node.js 运行时与 WebKit 渲染引擎捆绑在一起，让开发者可以用 Web 技术编写应用，同时通过 Node.js 访问底层系统 API。\u003C/p>\n\u003Cp>这意味着什么？开发者终于可以用 HTML 构建界面，用 JavaScript 编写逻辑，并且像传统桌面应用一样读写文件、访问数据库、调用系统命令，而且这一切是跨平台的，可以在 Windows、macOS 和 Linux 上运行。2014 年，项目更名为 NW.js，以更好地反映其技术本质。\u003C/p>\n\u003Cp>NW.js 解决了 MSHTA 时代的几个痛点：首先，它基于现代的 WebKit 内核，支持 HTML5 和 CSS3，而非老旧的 IE 引擎；其次，它是真正的跨平台，不再受制于 Windows；最重要的是，它将 Node.js 的生态系统带入了桌面开发，开发者可以使用 npm 上数十万个包。\u003C/p>\n\u003Cp>然而，NW.js 也有其局限。它的架构是将整个 Node.js 运行时注入 Web 环境，这导致上下文混乱，主进程和渲染进程的界限模糊。每个窗口都是一个独立的渲染进程，但共享同一个 Node.js 上下文，这在复杂应用中容易引发性能问题和内存泄漏。\u003C/p>\n\u003Ch2 id=\"electron\">Electron\u003C/h2>\n\u003Cp>2013 年，GitHub 的 Cheng Zhao 基于 Chromium Content Module 和 Node.js 开发了 Atom Shell，旨在为 Atom 编辑器提供框架[9]。2015 年，项目更名为 Electron。与 NW.js 不同，Electron 采用了更清晰的多进程架构：主进程（Node.js 环境）负责系统级操作，渲染进程（Chromium 环境）负责界面展示，两者通过 IPC（进程间通信）交互。\u003C/p>\n\u003Cp>这种分离带来了几个关键优势。首先，稳定性提升，单个窗口的崩溃不会影响整个应用；其次，安全性改善，渲染进程默认运行在沙箱中，需要通过显式 API 才能访问系统资源；最重要的是，开发者可以精确控制应用的生命周期和资源分配。\u003C/p>\n\u003Cp>Electron 迅速成为 HTML 桌面应用的事实标准。Slack、VS Code、Discord、Figma 等知名应用都基于 Electron 构建。它甚至反哺了 Web 技术本身，VS Code 的流行推动了 TypeScript 和 Language Server Protocol 的普及，而 Electron 的跨平台能力让小型团队也能开发出全平台支持的桌面软件。\u003C/p>\n\u003Cp>但 Electron 并非没有批评。每个应用都捆绑完整的 Chromium 和 Node.js，导致安装包体积庞大（通常超过 100MB），内存占用高。\u003C/p>\n\u003Ch2 id=\"pwa\">PWA\u003C/h2>\n\u003Cp>在 Electron 统治桌面端的同时，浏览器厂商也在探索另一条路径：让 Web 应用本身具备离线能力和系统访问权限。2015 年，Google 提出了 Progressive Web Apps (PWA) 概念[10]，随后得到了微软、苹果等厂商的支持。\u003C/p>\n\u003Cp>PWA 通过 Service Worker 实现离线缓存，通过 Web App Manifest 提供类原生应用的安装体验，还通过一系列 Web API（File System Access API、Contacts API、Bluetooth API 等）逐步扩展系统访问能力。理论上，PWA 可以”一次编写，到处运行”，无需捆绑浏览器内核，体积轻量，且能通过应用商店或浏览器直接分发。\u003C/p>\n\u003Cp>微软在 Windows 10/11 中积极支持 PWA，允许其通过 Microsoft Store 分发，某种程度上回归了 WinJS 的初心。然而，PWA 在实际应用中面临诸多限制：\u003C/p>\n\u003Cp>首先是\u003Cstrong>离线能力的本质缺陷\u003C/strong>。Service Worker 的离线缓存依赖于浏览器事先下载资源，它更适合”增强型网页”而非真正的离线应用。一旦用户首次访问时网络不畅，或者缓存策略配置不当，应用可能根本无法启动。这与 Electron 应用”下载即可离线运行”的体验有本质区别。\u003C/p>\n\u003Cp>其次是\u003Cstrong>分发的困境\u003C/strong>。虽然 PWA 可以通过应用商店分发，但各平台政策不一。苹果对 iOS 上的 PWA 限制极严，不允许第三方浏览器引擎，PWA 无法使用完整的 Web Push 等功能。更重要的是，PWA 无法像传统桌面应用那样直接分发安装包，用户必须通过浏览器或应用商店获取，这在企业内网环境或需要特定版本控制的场景下极不灵活。\u003C/p>\n\u003Cp>再者是\u003Cstrong>系统集成的局限\u003C/strong>。PWA 运行在浏览器沙箱中，虽然 Web API 在不断扩展，但许多底层操作仍无法实现：无法监听全局快捷键、无法创建系统托盘图标、无法在后台保持进程运行、无法访问某些硬件接口。对于需要深度系统集成的高级功能，PWA 仍然力不从心。\u003C/p>\n\u003Cp>最后是\u003Cstrong>平台差异的碎片化\u003C/strong>。不同浏览器对 Web API 的支持程度不一，开发者仍需处理兼容性问题。而且 PWA 始终受限于浏览器窗口的框架，它无法创建真正的无边框窗口，无法自定义原生菜单栏，这些在桌面应用中习以为常的功能在 PWA 中难以实现。\u003C/p>\n\u003Cp>因此，PWA 更适合内容型、偶尔离线的应用，而非功能复杂的生产力工具。它未能替代 Electron，反而与 Electron 形成了互补：轻量级场景用 PWA，重度桌面应用仍需要 Electron。\u003C/p>\n\u003Ch2 id=\"后-electron-时代\">后 Electron 时代\u003C/h2>\n\u003Cp>Electron 的臃肿问题在 2020 年代愈发突出。一个”Hello World”级别的 Electron 应用体积可达 150MB 以上，启动内存占用数百兆。这在 SSD 和内存充裕的现代设备上尚可接受，但在低配设备或注重资源效率的场景下成为痛点。\u003C/p>\n\u003Cp>更深层的问题是技术债务。Electron 深度绑定 Node.js 和 Chromium 的特定版本，难以适配 JavaScript 运行时的新发展。当 Deno（2018）和 Bun（2022）等新一代运行时出现时，它们提供了更安全的权限模型、更好的 TypeScript 原生支持、显著的性能提升，但 Electron 的架构无法直接利用这些优势。Electron 应用被困在 Node.js 的生态中，无法享受 JS 基础设施的最新成果。\u003C/p>\n\u003Cp>这催生了一系列替代方案的探索。\u003C/p>\n\u003Cp>Tauri[11] 采用 Rust 编写的轻量级后端，使用操作系统原生的 WebView 渲染前端。Windows 上用的是 WebView2，macOS 上用 WKWebView，Linux 上用 WebKitGTK。由于不需要捆绑浏览器内核，应用体积可以压缩到 3 到 5MB，内存占用也大幅降低。不过 Tauri 要求开发者用 Rust 处理系统交互，这对纯 Web 开发者来说是个门槛。虽然它提供了 JavaScript API，但复杂功能仍然需要深入 Rust 生态，这就失去了全栈 JavaScript 的便利性。\u003C/p>\n\u003Cp>WebUI[12] 是一个 C 语言编写的跨平台库，它不用捆绑浏览器内核，而是调用用户电脑上已经安装的浏览器作为渲染引擎。Chrome、Firefox、Edge 都可以用，通过 WebSocket 和本地后端通信。体积极小，只有一个可执行文件。但它受限于浏览器窗口，无法创建真正的无边框应用，也无法禁用浏览器的开发者工具，界面始终带有浏览器的痕迹。依赖外部浏览器还意味着无法保证渲染一致性，不同版本的浏览器可能导致兼容性问题。\u003C/p>\n\u003Cp>Wails[13] 和 Tauri 类似，不过后端用的是 Go 语言，同样依赖原生 WebView。它解决了体积问题，但把开发者锁定在了 Go 生态中。\u003C/p>\n\u003Cp>Flutter Desktop 和 React Native Desktop 则放弃了 Web 技术栈，改用自绘渲染引擎。虽然性能优秀，但失去了 Web 开发的开放性和生态优势。\u003C/p>\n\u003Cp>这些方案的共同困境在于：保持 Web 技术栈就体积庞大，缩小体积就引入原生语言门槛，保持轻量就受限于浏览器窗口。没有人找到完美的平衡点。\u003C/p>\n\u003Ch2 id=\"新的可能性\">新的可能性\u003C/h2>\n\u003Cp>面对这一困境，我开发了两个实验性项目，试图探索不同的路径。\u003C/p>\n\u003Cp>node-ps1-dotnet[14] 是一个基于 Node.js 和 PowerShell 的桌面应用框架。它利用 Windows 上无处不在的 PowerShell 和 .NET 运行时，让 Node.js 应用能够调用完整的 Windows API 和 .NET 类库，而无需捆绑 Chromium。前端可以使用系统内置的 WebView2，后端则通过 PowerShell 脚本与系统深度集成。这显著减小了应用体积，同时保持 JavaScript 和 TypeScript 的开发体验。\u003C/p>\n\u003Cp>node-with-gjs[15] 则是面向 Linux 的对应方案。GJS 是 GNOME 项目的 JavaScript 绑定，允许使用 JavaScript 调用 GTK 和原生系统 API。\u003C/p>\n\u003Cp>这两个项目的核心思想是利用操作系统已存在的运行时，而不是捆绑自己的浏览器和 Node.js 运行时。这样做大幅减小了分发体积，同时允许应用深度集成系统功能。它们除了适配 Node.js，也适配 Deno 和 Bun，并且为 GUI 开发和 WebView 开发提供了第一等支持，有开箱即用的示例。\u003C/p>\n\u003Cp>不过它们目前仍局限于特定平台。node-ps1-dotnet 主要针对 Windows，node-with-gjs 针对 Linux。要构建真正的跨平台应用，开发者需要处理平台差异，编写条件代码。\u003C/p>\n\u003Ch2 id=\"下一步\">下一步\u003C/h2>\n\u003Cp>基于以上探索，我正在开发一个统一的跨平台封装层。在 Windows 上，它使用 \u003Ca href=\"https://github.com/DevScholar/node-ps1-dotnet\">node-ps1-dotnet\u003C/a>，利用 WebView2 渲染界面，PowerShell 和 .NET 处理系统交互。在 Linux 上，它使用 \u003Ca href=\"https://github.com/DevScholar/node-with-gjs\">node-with-gjs\u003C/a>，利用 WebKitGTK 渲染界面，GJS 和 GTK 处理系统交互。\u003C/p>\n\u003Cp>目前我没有打算支持 macOS，因为我没有钱买 MacBook 也没有在 macOS 上做过开发。不过如果确实存在需求，我可以尝试在电脑上安装 x86 黑苹果虚拟机进行开发。虽然新版 macOS 不再推出 x86 版本，但由于我的项目不使用原生代码，只使用脚本语言和 IPC，并且苹果公司不会经常变更 JavaScript for Automation 的 API，理论上可以进行开发。\u003C/p>\n\u003Cp>开发者只需编写一套 HTML、CSS、JavaScript 前端代码，以及统一的 JavaScript API 调用，无需关心底层是 PowerShell 还是 GJS。框架会自动将系统 API 调用路由到对应平台的原生机制。\u003C/p>\n\u003Cp>这一方案试图结合各家的优点：保持 Web 技术栈的开放性和生态，显著减小应用体积，支持深度系统集成，并且能适配 Deno、Bun 等新一代 JavaScript 运行时。架构不再硬编码 Node.js，而是抽象为通用的 JS 运行时接口。\u003C/p>\n\u003Cp>从 MSHTA 的系统绑定，到 Electron 的自包含架构，再到新一代方案回归系统原生能力，HTML 桌面应用的技术路线经历了一个循环。MSHTA 利用系统已有的运行时，Electron 选择捆绑一切，新一代方案又回到利用系统运行时的思路。这一次，Web 标准更加成熟，开源生态也更完善，开发者对跨平台开发有了更深的理解。\u003C/p>\n\u003Cp>HTML 桌面应用仍然在发展。\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cstrong>参考文献\u003C/strong>\u003C/p>\n\u003Cp>[1] IE 3.0: \u003Ca href=\"https://www.webdesignmuseum.org/software/internet-explorer-3-0-in-1996\">https://www.webdesignmuseum.org/software/internet-explorer-3-0-in-1996\u003C/a>\u003C/p>\n\u003Cp>[2] CreateWindowA: \u003Ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowa\">https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowa\u003C/a>\u003C/p>\n\u003Cp>[3] MSHTA: \u003Ca href=\"https://learn.microsoft.com/en-us/previous-versions/ms536496(v=vs.85)\">https://learn.microsoft.com/en-us/previous-versions/ms536496(v=vs.85)\u003C/a>\u003C/p>\n\u003Cp>[4] PhoneGap: \u003Ca href=\"https://phonegap.com/\">https://phonegap.com/\u003C/a>\u003C/p>\n\u003Cp>[5] Apache Cordova: \u003Ca href=\"https://cordova.apache.org/\">https://cordova.apache.org/\u003C/a>\u003C/p>\n\u003Cp>[6] Capacitor: \u003Ca href=\"https://capacitorjs.com/\">https://capacitorjs.com/\u003C/a>\u003C/p>\n\u003Cp>[7] WinJS: \u003Ca href=\"https://github.com/winjs/winjs\">https://github.com/winjs/winjs\u003C/a>\u003C/p>\n\u003Cp>[8] NW.js: \u003Ca href=\"https://nwjs.io/\">https://nwjs.io/\u003C/a>\u003C/p>\n\u003Cp>[9] Electron: \u003Ca href=\"https://www.electronjs.org/\">https://www.electronjs.org/\u003C/a>\u003C/p>\n\u003Cp>[10] Progressive Web Apps: \u003Ca href=\"https://web.dev/progressive-web-apps/\">https://web.dev/progressive-web-apps/\u003C/a>\u003C/p>\n\u003Cp>[11] Tauri: \u003Ca href=\"https://tauri.app/\">https://tauri.app/\u003C/a>\u003C/p>\n\u003Cp>[12] WebUI: \u003Ca href=\"https://webui.dev/\">https://webui.dev/\u003C/a>\u003C/p>\n\u003Cp>[13] Wails: \u003Ca href=\"https://wails.io/\">https://wails.io/\u003C/a>\u003C/p>\n\u003Cp>[14] node-ps1-dotnet: \u003Ca href=\"https://github.com/DevScholar/node-ps1-dotnet\">https://github.com/DevScholar/node-ps1-dotnet\u003C/a>\u003C/p>\n\u003Cp>[15] node-with-gjs: \u003Ca href=\"https://github.com/DevScholar/node-with-gjs\">https://github.com/DevScholar/node-with-gjs\u003C/a>\u003C/p>",{"headings":77,"localImagePaths":100,"remoteImagePaths":101,"frontmatter":102,"imagePaths":103},[78,80,81,84,85,88,91,92,93,96,98],{"depth":26,"slug":79,"text":68},"html-应用发展史",{"depth":29,"slug":30,"text":31},{"depth":29,"slug":82,"text":83},"phonegap-与-cordova","PhoneGap 与 Cordova",{"depth":29,"slug":36,"text":37},{"depth":29,"slug":86,"text":87},"winjs-与-windows-8","WinJS 与 Windows 8",{"depth":29,"slug":89,"text":90},"node-webkit-与-nwjs","node-webkit 与 NW.js",{"depth":29,"slug":45,"text":46},{"depth":29,"slug":48,"text":49},{"depth":29,"slug":94,"text":95},"后-electron-时代","后 Electron 时代",{"depth":29,"slug":97,"text":97},"新的可能性",{"depth":29,"slug":99,"text":99},"下一步",[],[],{"title":68,"description":69,"pubDate":62,"author":17},[],"zh-cn/history-of-html-applications.md","projects",["Map",107,108,127,128,149,150,169,170,188,189,207,208,226,227,246,247],"system/zh-cn/rust-for-js-devs",{"id":107,"data":109,"body":113,"filePath":114,"digest":115,"rendered":116,"legacyId":126},{"name":110,"description":111,"category":112},"Rust for JS Devs（英文）","给 JavaScript 开发者的 Rust 教程","system","# Rust for JS Devs（英文）\n这是一个给 JavaScript 开发者看的 Rust 教程项目。目前该项目只有英文版。该项目涵盖了 JS 与 Rust 的基本语法、数据类型、控制流、函数、模块、闭包、所有权、借用、生命周期对照等内容。\n\n该项目目前出于不活跃开发状态，自 2024 年以来未更新。直到有新的议题 (issue) 被打开，该项目才会继续开发。\n\n[了解更多](https://github.com/DevScholar/rust-for-js-devs)","src/content/projects/system/zh-cn/rust-for-js-devs.md","7672ed65954f0f77",{"html":117,"metadata":118},"\u003Ch1 id=\"rust-for-js-devs英文\">Rust for JS Devs（英文）\u003C/h1>\n\u003Cp>这是一个给 JavaScript 开发者看的 Rust 教程项目。目前该项目只有英文版。该项目涵盖了 JS 与 Rust 的基本语法、数据类型、控制流、函数、模块、闭包、所有权、借用、生命周期对照等内容。\u003C/p>\n\u003Cp>该项目目前出于不活跃开发状态，自 2024 年以来未更新。直到有新的议题 (issue) 被打开，该项目才会继续开发。\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/rust-for-js-devs\">了解更多\u003C/a>\u003C/p>",{"headings":119,"localImagePaths":122,"remoteImagePaths":123,"frontmatter":124,"imagePaths":125},[120],{"depth":26,"slug":121,"text":110},"rust-for-js-devs英文",[],[],{"name":110,"description":111,"category":112},[],"system/zh-cn/rust-for-js-devs.md","web/zh-cn/node-ps1-dotnet",{"id":127,"data":129,"body":133,"filePath":134,"digest":135,"rendered":136,"legacyId":148},{"name":130,"description":131,"category":132},"Node PS1 for .NET","适用于 Node.js/Deno/Bun 的对 .NET Framework 的绑定","web","# Node PS1 for .NET\n![WebView2 示例](/assets/images/screenshots/node-ps1-dotnet-webview2.png)\n\nNode PS1 for .NET 是适用于 Node.js/Deno/Bun 对 .NET Framework 的绑定，其 API 风格模仿微软的 Node API for .NET，但使用系统自带的低版本 .NET 以减小应用程序体积。并且用跨进程通信 (IPC) 替代 C++ Addon 以兼容多种 JS 脚本宿主。此项目为 GUI 程序（含 WinForms 和 WPF）和 WebView2 提供了第一等支持，有开箱即用的示例。\n\n## 特性\n\n**可修改**\n\n此项目使用 TS+C#（利用 PowerShell 的`Add-Type``指令免编译执行）而不是原生编程语言编写。这意味着用本项目进行开发无需下载庞大的原生编程语言构建工具，而且你可以根据自己的需要修改此项目的源码而无需等待开发者加入此功能。这对于”加入对系统特有 API“的支持等场景特别有用。\n\n**轻量级**\n\n此项目使用系统自带的 .NET Framework 替代高版本 .NET 运行时。因此，用户无需下载大体积的高版本 .NET 运行时即可运行本软件。\n\n**GUI 支持**\n\n此项目为 GUI 提供第一等支持，包括 WinForms 和 WPF，以及 WebView2。这些示例都是开箱即用的。\n\n**高性能**\n\n此项目特别为拖拽等高频 IPC 交互场景进行了优化。用户可以运行项目示例自带的 Drag Box 示例并感受一下。\n\n**使用标准 API**\n\n此项目的 API 模仿微软的 Node API for .NET 项目。用户无需学习新的 API 即可上手。\n\n**多宿主**\n\n此项目同时支持 Node.js,Deno 和 Bun。用户可以选择自己喜欢的 JS 运行时。\n\n[了解更多](https://github.com/DevScholar/node-ps1-dotnet)","src/content/projects/web/zh-cn/node-ps1-dotnet.md","5c7689c97d222d7a",{"html":137,"metadata":138},"\u003Ch1 id=\"node-ps1-for-net\">Node PS1 for .NET\u003C/h1>\n\u003Cp>\u003Cimg src=\"/assets/images/screenshots/node-ps1-dotnet-webview2.png\" alt=\"WebView2 示例\">\u003C/p>\n\u003Cp>Node PS1 for .NET 是适用于 Node.js/Deno/Bun 对 .NET Framework 的绑定，其 API 风格模仿微软的 Node API for .NET，但使用系统自带的低版本 .NET 以减小应用程序体积。并且用跨进程通信 (IPC) 替代 C++ Addon 以兼容多种 JS 脚本宿主。此项目为 GUI 程序（含 WinForms 和 WPF）和 WebView2 提供了第一等支持，有开箱即用的示例。\u003C/p>\n\u003Ch2 id=\"特性\">特性\u003C/h2>\n\u003Cp>\u003Cstrong>可修改\u003C/strong>\u003C/p>\n\u003Cp>此项目使用 TS+C#（利用 PowerShell 的`Add-Type“指令免编译执行）而不是原生编程语言编写。这意味着用本项目进行开发无需下载庞大的原生编程语言构建工具，而且你可以根据自己的需要修改此项目的源码而无需等待开发者加入此功能。这对于”加入对系统特有 API“的支持等场景特别有用。\u003C/p>\n\u003Cp>\u003Cstrong>轻量级\u003C/strong>\u003C/p>\n\u003Cp>此项目使用系统自带的 .NET Framework 替代高版本 .NET 运行时。因此，用户无需下载大体积的高版本 .NET 运行时即可运行本软件。\u003C/p>\n\u003Cp>\u003Cstrong>GUI 支持\u003C/strong>\u003C/p>\n\u003Cp>此项目为 GUI 提供第一等支持，包括 WinForms 和 WPF，以及 WebView2。这些示例都是开箱即用的。\u003C/p>\n\u003Cp>\u003Cstrong>高性能\u003C/strong>\u003C/p>\n\u003Cp>此项目特别为拖拽等高频 IPC 交互场景进行了优化。用户可以运行项目示例自带的 Drag Box 示例并感受一下。\u003C/p>\n\u003Cp>\u003Cstrong>使用标准 API\u003C/strong>\u003C/p>\n\u003Cp>此项目的 API 模仿微软的 Node API for .NET 项目。用户无需学习新的 API 即可上手。\u003C/p>\n\u003Cp>\u003Cstrong>多宿主\u003C/strong>\u003C/p>\n\u003Cp>此项目同时支持 Node.js,Deno 和 Bun。用户可以选择自己喜欢的 JS 运行时。\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/node-ps1-dotnet\">了解更多\u003C/a>\u003C/p>",{"headings":139,"localImagePaths":144,"remoteImagePaths":145,"frontmatter":146,"imagePaths":147},[140,142],{"depth":26,"slug":141,"text":130},"node-ps1-for-net",{"depth":29,"slug":143,"text":143},"特性",[],[],{"name":130,"description":131,"category":132},[],"web/zh-cn/node-ps1-dotnet.md","web/zh-cn/node-with-gjs",{"id":149,"data":151,"body":154,"filePath":155,"digest":156,"rendered":157,"legacyId":168},{"name":152,"description":153,"category":132},"Node with GJS","适用于 Node.js/Deno/Bun 对 GNOME JavaScript 的绑定","# Node with GJS\r\n\r\n![WebKitGTK 示例](/assets/images/screenshots/node-with-gjs-webkitgtk.png)\r\n\r\nNode with GJS 是适用于 Node.js/Deno/Bun 对 GNOME JavaScript(GJS) 的绑定，其 API 风格模仿启用了模块支持 (`-m`) 的 GJS。并且用跨进程通信 (IPC) 替代 C++ Addon 以兼容多种 JS 脚本宿主。此项目为 GUI 程序（含 GTK 4 和 Adwaita）和 WebKitGTK 提供了第一等支持，有开箱即用的示例。\r\n\r\n## 特性\r\n\r\n**可修改**\r\n\r\n此项目使用 TS+JS（利用 JSDoc 解决 GJS 不支持 TS 的问题且加入类型注解以方便开发，Node.js 端使用 TS）而不是原生编程语言编写。这意味着用本项目进行开发无需下载庞大的原生编程语言构建工具，而且你可以根据自己的需要修改此项目的源码而无需等待开发者加入此功能。这对于”加入对系统特有 API“的支持等场景特别有用。\r\n\r\n**轻量级**\r\n\r\n此项目使用系统自带的 GJS 运行时，它通常已安装在使用 GNOME 的 Linux 发行版上。因此，用户无需下载大体积的第三方依赖即可运行本软件。\r\n\r\n**GUI 支持**\r\n\r\n此项目为 GUI 提供第一等支持，包括 GTK 4 和 Adwaita，以及 WebKitGTK。这些示例都是开箱即用的。\r\n\r\n**高性能**\r\n\r\n此项目特别为拖拽等高频 IPC 交互场景进行了优化。用户可以运行项目示例自带的 Drag Box 示例并感受一下。\r\n\r\n**使用标准 API**\r\n\r\n此项目的 API 模仿启用了模块支持 (`-m`) 的 GJS。用户无需学习新的 API 即可上手。\r\n\r\n**多宿主**\r\n\r\n此项目同时支持 Node.js,Deno 和 Bun。用户可以选择自己喜欢的 JS 运行时。\r\n\r\n[了解更多](https://github.com/DevScholar/node-with-gjs)","src/content/projects/web/zh-cn/node-with-gjs.md","0901db15e3e6e3c2",{"html":158,"metadata":159},"\u003Ch1 id=\"node-with-gjs\">Node with GJS\u003C/h1>\n\u003Cp>\u003Cimg src=\"/assets/images/screenshots/node-with-gjs-webkitgtk.png\" alt=\"WebKitGTK 示例\">\u003C/p>\n\u003Cp>Node with GJS 是适用于 Node.js/Deno/Bun 对 GNOME JavaScript(GJS) 的绑定，其 API 风格模仿启用了模块支持 (\u003Ccode>-m\u003C/code>) 的 GJS。并且用跨进程通信 (IPC) 替代 C++ Addon 以兼容多种 JS 脚本宿主。此项目为 GUI 程序（含 GTK 4 和 Adwaita）和 WebKitGTK 提供了第一等支持，有开箱即用的示例。\u003C/p>\n\u003Ch2 id=\"特性\">特性\u003C/h2>\n\u003Cp>\u003Cstrong>可修改\u003C/strong>\u003C/p>\n\u003Cp>此项目使用 TS+JS（利用 JSDoc 解决 GJS 不支持 TS 的问题且加入类型注解以方便开发，Node.js 端使用 TS）而不是原生编程语言编写。这意味着用本项目进行开发无需下载庞大的原生编程语言构建工具，而且你可以根据自己的需要修改此项目的源码而无需等待开发者加入此功能。这对于”加入对系统特有 API“的支持等场景特别有用。\u003C/p>\n\u003Cp>\u003Cstrong>轻量级\u003C/strong>\u003C/p>\n\u003Cp>此项目使用系统自带的 GJS 运行时，它通常已安装在使用 GNOME 的 Linux 发行版上。因此，用户无需下载大体积的第三方依赖即可运行本软件。\u003C/p>\n\u003Cp>\u003Cstrong>GUI 支持\u003C/strong>\u003C/p>\n\u003Cp>此项目为 GUI 提供第一等支持，包括 GTK 4 和 Adwaita，以及 WebKitGTK。这些示例都是开箱即用的。\u003C/p>\n\u003Cp>\u003Cstrong>高性能\u003C/strong>\u003C/p>\n\u003Cp>此项目特别为拖拽等高频 IPC 交互场景进行了优化。用户可以运行项目示例自带的 Drag Box 示例并感受一下。\u003C/p>\n\u003Cp>\u003Cstrong>使用标准 API\u003C/strong>\u003C/p>\n\u003Cp>此项目的 API 模仿启用了模块支持 (\u003Ccode>-m\u003C/code>) 的 GJS。用户无需学习新的 API 即可上手。\u003C/p>\n\u003Cp>\u003Cstrong>多宿主\u003C/strong>\u003C/p>\n\u003Cp>此项目同时支持 Node.js,Deno 和 Bun。用户可以选择自己喜欢的 JS 运行时。\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/node-with-gjs\">了解更多\u003C/a>\u003C/p>",{"headings":160,"localImagePaths":164,"remoteImagePaths":165,"frontmatter":166,"imagePaths":167},[161,163],{"depth":26,"slug":162,"text":152},"node-with-gjs",{"depth":29,"slug":143,"text":143},[],[],{"name":152,"description":153,"category":132},[],"web/zh-cn/node-with-gjs.md","system/zh-cn/c-for-js-devs",{"id":169,"data":171,"body":174,"filePath":175,"digest":176,"rendered":177,"legacyId":187},{"name":172,"description":173,"category":112},"C for JS Devs（英文）","给 JavaScript 开发者的 C 教程","# C for JS Devs（英文）\r\n这是一个给 JavaScript 开发者看的 C 教程项目。目前该项目只有英文版。该项目涵盖了 C 与 JS 的基本语法、数据类型、控制流、函数、模块、闭包、所有权、借用、生命周期对照等内容。\r\n\r\n该项目目前出于不活跃开发状态，自 2024 年以来未更新。直到有新的议题 (issue) 被打开，该项目才会继续开发。\r\n\r\n[了解更多](https://github.com/DevScholar/c-for-js-devs)","src/content/projects/system/zh-cn/c-for-js-devs.md","c918b4acbaf09489",{"html":178,"metadata":179},"\u003Ch1 id=\"c-for-js-devs英文\">C for JS Devs（英文）\u003C/h1>\n\u003Cp>这是一个给 JavaScript 开发者看的 C 教程项目。目前该项目只有英文版。该项目涵盖了 C 与 JS 的基本语法、数据类型、控制流、函数、模块、闭包、所有权、借用、生命周期对照等内容。\u003C/p>\n\u003Cp>该项目目前出于不活跃开发状态，自 2024 年以来未更新。直到有新的议题 (issue) 被打开，该项目才会继续开发。\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/c-for-js-devs\">了解更多\u003C/a>\u003C/p>",{"headings":180,"localImagePaths":183,"remoteImagePaths":184,"frontmatter":185,"imagePaths":186},[181],{"depth":26,"slug":182,"text":172},"c-for-js-devs英文",[],[],{"name":172,"description":173,"category":112},[],"system/zh-cn/c-for-js-devs.md","system/en-us/c-for-js-devs",{"id":188,"data":190,"body":193,"filePath":194,"digest":195,"rendered":196,"legacyId":206},{"name":191,"description":192,"category":112},"C for JS Devs","A C tutorial for JavaScript developers","# C for JS Devs\nThis is a C tutorial project designed for JavaScript developers. Currently, this project only has an English version. The project covers basic syntax, data types, control flow, functions, modules, closures, ownership, borrowing, and lifetime comparisons between C and JS.\n\nThe project is currently in an inactive development state and has not been updated since 2024. Development will resume only when new issues are opened.\n\n[Learn more](https://github.com/DevScholar/c-for-js-devs)","src/content/projects/system/en-us/c-for-js-devs.md","d125ae9832458bad",{"html":197,"metadata":198},"\u003Ch1 id=\"c-for-js-devs\">C for JS Devs\u003C/h1>\n\u003Cp>This is a C tutorial project designed for JavaScript developers. Currently, this project only has an English version. The project covers basic syntax, data types, control flow, functions, modules, closures, ownership, borrowing, and lifetime comparisons between C and JS.\u003C/p>\n\u003Cp>The project is currently in an inactive development state and has not been updated since 2024. Development will resume only when new issues are opened.\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/c-for-js-devs\">Learn more\u003C/a>\u003C/p>",{"headings":199,"localImagePaths":202,"remoteImagePaths":203,"frontmatter":204,"imagePaths":205},[200],{"depth":26,"slug":201,"text":191},"c-for-js-devs",[],[],{"name":191,"description":192,"category":112},[],"system/en-us/c-for-js-devs.md","system/en-us/rust-for-js-devs",{"id":207,"data":209,"body":212,"filePath":213,"digest":214,"rendered":215,"legacyId":225},{"name":210,"description":211,"category":112},"Rust for JS Devs","A Rust tutorial for JavaScript developers","# Rust for JS Devs\nThis is a Rust tutorial project designed for JavaScript developers. Currently, this project only has an English version. The project covers basic syntax, data types, control flow, functions, modules, closures, ownership, borrowing, and lifetime comparisons between JS and Rust.\n\nThe project is currently in an inactive development state and has not been updated since 2024. Development will resume only when new issues are opened.\n\n[Learn more](https://github.com/DevScholar/rust-for-js-devs)","src/content/projects/system/en-us/rust-for-js-devs.md","7529fadeb9059b34",{"html":216,"metadata":217},"\u003Ch1 id=\"rust-for-js-devs\">Rust for JS Devs\u003C/h1>\n\u003Cp>This is a Rust tutorial project designed for JavaScript developers. Currently, this project only has an English version. The project covers basic syntax, data types, control flow, functions, modules, closures, ownership, borrowing, and lifetime comparisons between JS and Rust.\u003C/p>\n\u003Cp>The project is currently in an inactive development state and has not been updated since 2024. Development will resume only when new issues are opened.\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/rust-for-js-devs\">Learn more\u003C/a>\u003C/p>",{"headings":218,"localImagePaths":221,"remoteImagePaths":222,"frontmatter":223,"imagePaths":224},[219],{"depth":26,"slug":220,"text":210},"rust-for-js-devs",[],[],{"name":210,"description":211,"category":112},[],"system/en-us/rust-for-js-devs.md","web/en-us/node-ps1-dotnet",{"id":226,"data":228,"body":230,"filePath":231,"digest":232,"rendered":233,"legacyId":245},{"name":130,"description":229,"category":132},"Bindings for .NET Framework for Node.js/Deno/Bun","# Node PS1 for .NET\n![WebView2 Example](/assets/images/screenshots/node-ps1-dotnet-webview2.png)\n\nNode PS1 for .NET provides bindings for .NET Framework for Node.js/Deno/Bun. Its API style mimics Microsoft's Node API for .NET, but uses the system's built-in lower version of .NET to reduce application size. It also uses Inter-Process Communication (IPC) instead of C++ Addons to be compatible with multiple JS script hosts. This project provides first-class support for GUI programs (including WinForms and WPF) and WebView2, with ready-to-use examples.\n\n## Features\n\n**Modifiable**\n\nThis project is written in TS+C# (using PowerShell's `Add-Type` directive for compilation-free execution) rather than native programming languages. This means you don't need to download large native programming language build tools to develop with this project, and you can modify the source code according to your needs without waiting for the developer to add this feature. This is especially useful for scenarios like \"adding support for system-specific APIs\".\n\n**Lightweight**\n\nThis project uses the system's built-in .NET Framework instead of higher-version .NET runtime. Therefore, users don't need to download large higher-version .NET runtime to run this software.\n\n**GUI Support**\n\nThis project provides first-class support for GUI, including WinForms and WPF, as well as WebView2. All these examples are ready to use out of the box.\n\n**High Performance**\n\nThis project is specifically optimized for high-frequency IPC interaction scenarios such as drag-and-drop. You can run the Drag Box example included in the project examples to experience it.\n\n**Standard API**\n\nThis project's API mimics Microsoft's Node API for .NET project. Users can get started without learning new APIs.\n\n**Multi-Host**\n\nThis project supports Node.js, Deno, and Bun simultaneously. Users can choose their favorite JS runtime.\n\n[Learn more](https://github.com/DevScholar/node-ps1-dotnet)","src/content/projects/web/en-us/node-ps1-dotnet.md","256cbba3ba7ec1f0",{"html":234,"metadata":235},"\u003Ch1 id=\"node-ps1-for-net\">Node PS1 for .NET\u003C/h1>\n\u003Cp>\u003Cimg src=\"/assets/images/screenshots/node-ps1-dotnet-webview2.png\" alt=\"WebView2 Example\">\u003C/p>\n\u003Cp>Node PS1 for .NET provides bindings for .NET Framework for Node.js/Deno/Bun. Its API style mimics Microsoft’s Node API for .NET, but uses the system’s built-in lower version of .NET to reduce application size. It also uses Inter-Process Communication (IPC) instead of C++ Addons to be compatible with multiple JS script hosts. This project provides first-class support for GUI programs (including WinForms and WPF) and WebView2, with ready-to-use examples.\u003C/p>\n\u003Ch2 id=\"features\">Features\u003C/h2>\n\u003Cp>\u003Cstrong>Modifiable\u003C/strong>\u003C/p>\n\u003Cp>This project is written in TS+C# (using PowerShell’s \u003Ccode>Add-Type\u003C/code> directive for compilation-free execution) rather than native programming languages. This means you don’t need to download large native programming language build tools to develop with this project, and you can modify the source code according to your needs without waiting for the developer to add this feature. This is especially useful for scenarios like “adding support for system-specific APIs”.\u003C/p>\n\u003Cp>\u003Cstrong>Lightweight\u003C/strong>\u003C/p>\n\u003Cp>This project uses the system’s built-in .NET Framework instead of higher-version .NET runtime. Therefore, users don’t need to download large higher-version .NET runtime to run this software.\u003C/p>\n\u003Cp>\u003Cstrong>GUI Support\u003C/strong>\u003C/p>\n\u003Cp>This project provides first-class support for GUI, including WinForms and WPF, as well as WebView2. All these examples are ready to use out of the box.\u003C/p>\n\u003Cp>\u003Cstrong>High Performance\u003C/strong>\u003C/p>\n\u003Cp>This project is specifically optimized for high-frequency IPC interaction scenarios such as drag-and-drop. You can run the Drag Box example included in the project examples to experience it.\u003C/p>\n\u003Cp>\u003Cstrong>Standard API\u003C/strong>\u003C/p>\n\u003Cp>This project’s API mimics Microsoft’s Node API for .NET project. Users can get started without learning new APIs.\u003C/p>\n\u003Cp>\u003Cstrong>Multi-Host\u003C/strong>\u003C/p>\n\u003Cp>This project supports Node.js, Deno, and Bun simultaneously. Users can choose their favorite JS runtime.\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/node-ps1-dotnet\">Learn more\u003C/a>\u003C/p>",{"headings":236,"localImagePaths":241,"remoteImagePaths":242,"frontmatter":243,"imagePaths":244},[237,238],{"depth":26,"slug":141,"text":130},{"depth":29,"slug":239,"text":240},"features","Features",[],[],{"name":130,"description":229,"category":132},[],"web/en-us/node-ps1-dotnet.md","web/en-us/node-with-gjs",{"id":246,"data":248,"body":250,"filePath":251,"digest":252,"rendered":253,"legacyId":263},{"name":152,"description":249,"category":132},"Bindings for GNOME JavaScript for Node.js/Deno/Bun","# Node with GJS\n![WebKitGTK Example](/assets/images/screenshots/node-with-gjs-webkitgtk.png)\n\nNode with GJS provides bindings for GNOME JavaScript (GJS) for Node.js/Deno/Bun. Its API style mimics GJS with module support (`-m`) enabled. It also uses Inter-Process Communication (IPC) instead of C++ Addons to be compatible with multiple JS script hosts. This project provides first-class support for GUI programs (including GTK 4 and Adwaita) and WebKitGTK, with ready-to-use examples.\n\n## Features\n\n**Modifiable**\n\nThis project is written in TS+JS (using JSDoc to solve GJS's lack of TypeScript support while adding type annotations for better development; Node.js side uses TS) rather than native programming languages. This means you don't need to download large native programming language build tools to develop with this project, and you can modify the source code according to your needs without waiting for the developer to add this feature. This is especially useful for scenarios like \"adding support for system-specific APIs\".\n\n**Lightweight**\n\nThis project uses the system's built-in GJS runtime, which is usually pre-installed on Linux distributions using GNOME. Therefore, users don't need to download large third-party dependencies to run this software.\n\n**GUI Support**\n\nThis project provides first-class support for GUI, including GTK 4 and Adwaita, as well as WebKitGTK. All these examples are ready to use out of the box.\n\n**High Performance**\n\nThis project is specifically optimized for high-frequency IPC interaction scenarios such as drag-and-drop. You can run the Drag Box example included in the project examples to experience it.\n\n**Standard API**\n\nThis project's API mimics GJS with module support (`-m`) enabled. Users can get started without learning new APIs.\n\n**Multi-Host**\n\nThis project supports Node.js, Deno, and Bun simultaneously. Users can choose their favorite JS runtime.\n\n[Learn more](https://github.com/DevScholar/node-with-gjs)","src/content/projects/web/en-us/node-with-gjs.md","d8fd145560cec33f",{"html":254,"metadata":255},"\u003Ch1 id=\"node-with-gjs\">Node with GJS\u003C/h1>\n\u003Cp>\u003Cimg src=\"/assets/images/screenshots/node-with-gjs-webkitgtk.png\" alt=\"WebKitGTK Example\">\u003C/p>\n\u003Cp>Node with GJS provides bindings for GNOME JavaScript (GJS) for Node.js/Deno/Bun. Its API style mimics GJS with module support (\u003Ccode>-m\u003C/code>) enabled. It also uses Inter-Process Communication (IPC) instead of C++ Addons to be compatible with multiple JS script hosts. This project provides first-class support for GUI programs (including GTK 4 and Adwaita) and WebKitGTK, with ready-to-use examples.\u003C/p>\n\u003Ch2 id=\"features\">Features\u003C/h2>\n\u003Cp>\u003Cstrong>Modifiable\u003C/strong>\u003C/p>\n\u003Cp>This project is written in TS+JS (using JSDoc to solve GJS’s lack of TypeScript support while adding type annotations for better development; Node.js side uses TS) rather than native programming languages. This means you don’t need to download large native programming language build tools to develop with this project, and you can modify the source code according to your needs without waiting for the developer to add this feature. This is especially useful for scenarios like “adding support for system-specific APIs”.\u003C/p>\n\u003Cp>\u003Cstrong>Lightweight\u003C/strong>\u003C/p>\n\u003Cp>This project uses the system’s built-in GJS runtime, which is usually pre-installed on Linux distributions using GNOME. Therefore, users don’t need to download large third-party dependencies to run this software.\u003C/p>\n\u003Cp>\u003Cstrong>GUI Support\u003C/strong>\u003C/p>\n\u003Cp>This project provides first-class support for GUI, including GTK 4 and Adwaita, as well as WebKitGTK. All these examples are ready to use out of the box.\u003C/p>\n\u003Cp>\u003Cstrong>High Performance\u003C/strong>\u003C/p>\n\u003Cp>This project is specifically optimized for high-frequency IPC interaction scenarios such as drag-and-drop. You can run the Drag Box example included in the project examples to experience it.\u003C/p>\n\u003Cp>\u003Cstrong>Standard API\u003C/strong>\u003C/p>\n\u003Cp>This project’s API mimics GJS with module support (\u003Ccode>-m\u003C/code>) enabled. Users can get started without learning new APIs.\u003C/p>\n\u003Cp>\u003Cstrong>Multi-Host\u003C/strong>\u003C/p>\n\u003Cp>This project supports Node.js, Deno, and Bun simultaneously. Users can choose their favorite JS runtime.\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/DevScholar/node-with-gjs\">Learn more\u003C/a>\u003C/p>",{"headings":256,"localImagePaths":259,"remoteImagePaths":260,"frontmatter":261,"imagePaths":262},[257,258],{"depth":26,"slug":162,"text":152},{"depth":29,"slug":239,"text":240},[],[],{"name":152,"description":249,"category":132},[],"web/en-us/node-with-gjs.md"]